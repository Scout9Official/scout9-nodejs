/* tslint:disable */
/* eslint-disable */
/**
 * Scout9 API
 * Scout9 APIs for managing Scout9 users and conversations with your Scout9 agents
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Agent
 */
export interface Agent {
  /**
   * Agent first name
   * @type {string}
   * @memberof Agent
   */
  'firstName'?: string;
  /**
   * Agent last name
   * @type {string}
   * @memberof Agent
   */
  'lastName'?: string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof Agent
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof Agent
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof Agent
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof Agent
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof Agent
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof Agent
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof Agent
   */
  'title'?: string;
  /**
   * Context of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof Agent
   */
  'context'?: string;
  /**
   * Locations ids the agent is included in
   * @type {Array<string>}
   * @memberof Agent
   */
  'includedLocations'?: Array<string>;
  /**
   * AI Model
   * @type {string}
   * @memberof Agent
   */
  'model'?: AgentModelEnum;
  /**
   * Locations id the agent is excluded from
   * @type {Array<string>}
   * @memberof Agent
   */
  'excludedLocations'?: Array<string>;
}

export const AgentModelEnum = {
  Scout9: 'Scout9',
  Bard: 'bard',
  Null: 'null'
} as const;

export type AgentModelEnum = typeof AgentModelEnum[keyof typeof AgentModelEnum];

/**
 * @type AnyValue
 * @export
 */
export type AnyValue = boolean | number | object | string;

/**
 *
 * @export
 * @interface ApiOperation
 */
export interface ApiOperation {
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ApiOperation
   */
  'time': string;
  /**
   * The model that was created, updated, or deleted
   * @type {string}
   * @memberof ApiOperation
   */
  'model': string;
  /**
   * The method that was called
   * @type {string}
   * @memberof ApiOperation
   */
  'method': ApiOperationMethodEnum;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof ApiOperation
   */
  'results': { [key: string]: any; };
}

export const ApiOperationMethodEnum = {
  Get: 'get',
  Post: 'post',
  Put: 'put',
  Delete: 'delete',
  Patch: 'patch'
} as const;

export type ApiOperationMethodEnum = typeof ApiOperationMethodEnum[keyof typeof ApiOperationMethodEnum];

/**
 *
 * @export
 * @interface BlockInfo
 */
export interface BlockInfo {
  /**
   *
   * @type {string}
   * @memberof BlockInfo
   */
  'message'?: string;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof BlockInfo
   */
  'time'?: string;
}
/**
 *
 * @export
 * @interface Context
 */
export interface Context {
  /**
   * The name of the context
   * @type {string}
   * @memberof Context
   */
  'name': string;
  /**
   * Whether or not the context is modifiable
   * @type {boolean}
   * @memberof Context
   */
  'modifiable': boolean;
  /**
   * The description of the context
   * @type {string}
   * @memberof Context
   */
  'description'?: string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof Context
   */
  'detection'?: ContextDetectionParams;
  /**
   * The ID column of the context
   * @type {string}
   * @memberof Context
   */
  'idColumn': string;
  /**
   * The columns of the context
   * @type {Array<string>}
   * @memberof Context
   */
  'columns': Array<string>;
  /**
   * The required columns of the context
   * @type {Array<string>}
   * @memberof Context
   */
  'requiredColumns'?: Array<string>;
}
/**
 *
 * @export
 * @interface ContextDetectionDocument
 */
export interface ContextDetectionDocument {
  /**
   * The languages the entity is available in
   * @type {Array<string>}
   * @memberof ContextDetectionDocument
   */
  'languages'?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof ContextDetectionDocument
   */
  'text': string;
  /**
   *
   * @type {string}
   * @memberof ContextDetectionDocument
   */
  'id': string;
}
/**
 *
 * @export
 * @interface ContextDetectionEntity
 */
export interface ContextDetectionEntity {
  /**
   * The utterance ID of the entity
   * @type {string}
   * @memberof ContextDetectionEntity
   */
  'utteranceId': string;
  /**
   * The classification of the given text
   * @type {string}
   * @memberof ContextDetectionEntity
   */
  'option': string;
  /**
   * The languages the entity is available in
   * @type {Array<string>}
   * @memberof ContextDetectionEntity
   */
  'languages'?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ContextDetectionEntity
   */
  'text': Array<string>;
}
/**
 *
 * @export
 * @interface ContextDetectionParams
 */
export interface ContextDetectionParams {
  /**
   *
   * @type {Array<ContextDetectionEntity>}
   * @memberof ContextDetectionParams
   */
  'entities': Array<ContextDetectionEntity>;
  /**
   *
   * @type {Array<ContextDetectionDocument>}
   * @memberof ContextDetectionParams
   */
  'documents': Array<ContextDetectionDocument>;
  /**
   *
   * @type {Array<ContextDetectionTest>}
   * @memberof ContextDetectionParams
   */
  'test'?: Array<ContextDetectionTest>;
}
/**
 *
 * @export
 * @interface ContextDetectionTest
 */
export interface ContextDetectionTest {
  /**
   *
   * @type {string}
   * @memberof ContextDetectionTest
   */
  'language'?: string;
  /**
   *
   * @type {string}
   * @memberof ContextDetectionTest
   */
  'text': string;
  /**
   *
   * @type {string}
   * @memberof ContextDetectionTest
   */
  'targetUtteranceId': string;
  /**
   *
   * @type {string}
   * @memberof ContextDetectionTest
   */
  'targetOption': string;
}
/**
 *
 * @export
 * @interface Conversation
 */
export interface Conversation {
  /**
   * Default agent assigned to the conversation(s)
   * @type {string}
   * @memberof Conversation
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof Conversation
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof Conversation
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof Conversation
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof Conversation
   */
  'environment': ConversationEnvironment;
}


/**
 *
 * @export
 * @interface ConversationAllOf
 */
export interface ConversationAllOf {
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof ConversationAllOf
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ConversationAllOf
   */
  'environment': ConversationEnvironment;
}


/**
 * Base props all conversation types will have
 * @export
 * @interface ConversationBase
 */
export interface ConversationBase {
  /**
   * Default agent assigned to the conversation(s)
   * @type {string}
   * @memberof ConversationBase
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ConversationBase
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ConversationBase
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
}
/**
 * Environment properties for the conversation
 * @export
 * @interface ConversationBaseEnvironmentProps
 */
export interface ConversationBaseEnvironmentProps {
  /**
   * HTML subject line
   * @type {string}
   * @memberof ConversationBaseEnvironmentProps
   */
  'subject'?: string;
  /**
   * Used to sync email messages with the conversation
   * @type {string}
   * @memberof ConversationBaseEnvironmentProps
   */
  'platformEmailThreadId'?: string;
}
/**
 *
 * @export
 * @interface ConversationContextField
 */
export interface ConversationContextField {
  /**
   * The ID of the context
   * @type {string}
   * @memberof ConversationContextField
   */
  'id': string;
  /**
   * The time the context was created
   * @type {string}
   * @memberof ConversationContextField
   */
  'time'?: string;
  /**
   * The context of the conversation
   * @type {string}
   * @memberof ConversationContextField
   */
  'context': string;
  /**
   * The note of the conversation
   * @type {string}
   * @memberof ConversationContextField
   */
  'note'?: string;
  /**
   * The metadata of the conversation
   * @type {object}
   * @memberof ConversationContextField
   */
  'metadata'?: object;
  /**
   * The conditions of the conversation
   * @type {Array<ConversationContextGroup>}
   * @memberof ConversationContextField
   */
  'conditions'?: Array<ConversationContextGroup>;
  /**
   * The triggers of the conversation
   * @type {Array<string>}
   * @memberof ConversationContextField
   */
  'triggers'?: Array<string>;
}
/**
 *
 * @export
 * @interface ConversationContextFieldCondition
 */
export interface ConversationContextFieldCondition {
  /**
   * The key of the condition
   * @type {string}
   * @memberof ConversationContextFieldCondition
   */
  'key': string;
  /**
   * The operator of the condition or query
   * @type {string}
   * @memberof ConversationContextFieldCondition
   */
  'operator': ConversationContextFieldConditionOperatorEnum;
  /**
   * The regex of the condition
   * @type {string}
   * @memberof ConversationContextFieldCondition
   */
  'regex'?: string;
  /**
   *
   * @type {AnyValue}
   * @memberof ConversationContextFieldCondition
   */
  'value': AnyValue;
}

export const ConversationContextFieldConditionOperatorEnum = {
  Eq: 'eq',
  Equal: 'equal',
  Ne: 'ne',
  NotEquals: 'not-equals',
  Gt: 'gt',
  GreaterThan: 'greater-than',
  Gte: 'gte',
  GreaterThanEquals: 'greater-than-equals',
  Lt: 'lt',
  LessThan: 'less-than',
  Lte: 'lte',
  LessThanEquals: 'less-than-equals',
  ArrayContains: 'array-contains',
  In: 'in',
  ArrayContainsAny: 'array-contains-any',
  NotIn: 'not-in',
  Exists: 'exists',
  NotExists: 'notExists',
  Contains: 'contains',
  NotContains: 'notContains',
  StartsWith: 'startsWith',
  EndsWith: 'endsWith'
} as const;

export type ConversationContextFieldConditionOperatorEnum = typeof ConversationContextFieldConditionOperatorEnum[keyof typeof ConversationContextFieldConditionOperatorEnum];

/**
 *
 * @export
 * @interface ConversationContextGroup
 */
export interface ConversationContextGroup {
  /**
   * The conditions of the conversation
   * @type {Array<ConversationContextFieldCondition>}
   * @memberof ConversationContextGroup
   */
  'conditions': Array<ConversationContextFieldCondition>;
}
/**
 *
 * @export
 * @interface ConversationCreateRequest
 */
export interface ConversationCreateRequest {
  /**
   * Default agent assigned to the conversation(s)
   * @type {string}
   * @memberof ConversationCreateRequest
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ConversationCreateRequest
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ConversationCreateRequest
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof ConversationCreateRequest
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ConversationCreateRequest
   */
  'environment': ConversationEnvironment;
  /**
   *
   * @type {ConversationUpdateRequestBaseWorkflow}
   * @memberof ConversationCreateRequest
   */
  '$workflow'?: ConversationUpdateRequestBaseWorkflow;
}


/**
 *
 * @export
 * @interface ConversationCreateRequestBase
 */
export interface ConversationCreateRequestBase {
  /**
   *
   * @type {ConversationUpdateRequestBaseWorkflow}
   * @memberof ConversationCreateRequestBase
   */
  '$workflow'?: ConversationUpdateRequestBaseWorkflow;
}
/**
 *
 * @export
 * @interface ConversationCreateResponse
 */
export interface ConversationCreateResponse {
  /**
   *
   * @type {boolean}
   * @memberof ConversationCreateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ConversationCreateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ConversationCreateResponse
   */
  'id': string;
  /**
   * The client web url of the conversation
   * @type {string}
   * @memberof ConversationCreateResponse
   */
  'clientWebUrl'?: string;
  /**
   * The agent web url of the conversation (requires phone two-factor authentication)
   * @type {string}
   * @memberof ConversationCreateResponse
   */
  'agentWebUrl'?: string;
  /**
   * The agent test web url of the conversation, used for testing the conversation without notifying the customer
   * @type {string}
   * @memberof ConversationCreateResponse
   */
  'agentTestWebUrl'?: string;
  /**
   * ISO 8601 date string of when the conversation was initiated
   * @type {string}
   * @memberof ConversationCreateResponse
   */
  'initiated': string;
}
/**
 *
 * @export
 * @interface ConversationCreateResponseAllOf
 */
export interface ConversationCreateResponseAllOf {
  /**
   * ISO 8601 date string of when the conversation was initiated
   * @type {string}
   * @memberof ConversationCreateResponseAllOf
   */
  'initiated': string;
}
/**
 * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
 * @export
 * @enum {string}
 */

export const ConversationEnvironment = {
  Phone: 'phone',
  Web: 'web',
  Email: 'email'
} as const;

export type ConversationEnvironment = typeof ConversationEnvironment[keyof typeof ConversationEnvironment];


/**
 *
 * @export
 * @interface ConversationGetResponse
 */
export interface ConversationGetResponse {
  /**
   * Default agent assigned to the conversation(s)
   * @type {string}
   * @memberof ConversationGetResponse
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ConversationGetResponse
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ConversationGetResponse
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof ConversationGetResponse
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ConversationGetResponse
   */
  'environment': ConversationEnvironment;
  /**
   * The client web url of the conversation
   * @type {string}
   * @memberof ConversationGetResponse
   */
  'clientWebUrl'?: string;
  /**
   * The agent web url of the conversation (requires phone two-factor authentication)
   * @type {string}
   * @memberof ConversationGetResponse
   */
  'agentWebUrl'?: string;
  /**
   * The agent test web url of the conversation, used for testing the conversation without notifying the customer
   * @type {string}
   * @memberof ConversationGetResponse
   */
  'agentTestWebUrl'?: string;
  /**
   * The ID of the workflow used for this conversation
   * @type {string}
   * @memberof ConversationGetResponse
   */
  '$workflow': string;
  /**
   * ISO 8601 date string of when the conversation was initiated
   * @type {string}
   * @memberof ConversationGetResponse
   */
  'initiated': string;
  /**
   * The ID of the conversation
   * @type {string}
   * @memberof ConversationGetResponse
   */
  '$id': string;
}


/**
 *
 * @export
 * @interface ConversationGetResponseAllOf
 */
export interface ConversationGetResponseAllOf {
  /**
   * ISO 8601 date string of when the conversation was initiated
   * @type {string}
   * @memberof ConversationGetResponseAllOf
   */
  'initiated': string;
  /**
   * The ID of the conversation
   * @type {string}
   * @memberof ConversationGetResponseAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ConversationGetResponseBase
 */
export interface ConversationGetResponseBase {
  /**
   * The ID of the workflow used for this conversation
   * @type {string}
   * @memberof ConversationGetResponseBase
   */
  '$workflow': string;
}
/**
 *
 * @export
 * @interface ConversationRemoveResponse
 */
export interface ConversationRemoveResponse {
  /**
   *
   * @type {boolean}
   * @memberof ConversationRemoveResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ConversationRemoveResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ConversationRemoveResponse
   */
  'id': string;
}
/**
 * Base properties for all scheduled conversation types
 * @export
 * @interface ConversationScheduleParams
 */
export interface ConversationScheduleParams {
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ConversationScheduleParams
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ConversationScheduleParams
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ConversationScheduleParams
   */
  'initialMessageHtml'?: string | null;
}
/**
 *
 * @export
 * @interface ConversationUpdateRequest
 */
export interface ConversationUpdateRequest {
  /**
   * Default agent assigned to the conversation(s)
   * @type {string}
   * @memberof ConversationUpdateRequest
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ConversationUpdateRequest
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ConversationUpdateRequest
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof ConversationUpdateRequest
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ConversationUpdateRequest
   */
  'environment': ConversationEnvironment;
  /**
   *
   * @type {ConversationUpdateRequestAllOfWorkflow}
   * @memberof ConversationUpdateRequest
   */
  '$workflow'?: ConversationUpdateRequestAllOfWorkflow;
  /**
   * The ID of the conversation to update
   * @type {string}
   * @memberof ConversationUpdateRequest
   */
  '$id': string;
}


/**
 *
 * @export
 * @interface ConversationUpdateRequestAllOf
 */
export interface ConversationUpdateRequestAllOf {
  /**
   * The ID of the conversation to update
   * @type {string}
   * @memberof ConversationUpdateRequestAllOf
   */
  '$id': string;
  /**
   *
   * @type {ConversationUpdateRequestAllOfWorkflow}
   * @memberof ConversationUpdateRequestAllOf
   */
  '$workflow'?: ConversationUpdateRequestAllOfWorkflow;
}
/**
 * @type ConversationUpdateRequestAllOfWorkflow
 * @export
 */
export type ConversationUpdateRequestAllOfWorkflow = Workflow | string;

/**
 *
 * @export
 * @interface ConversationUpdateRequestBase
 */
export interface ConversationUpdateRequestBase {
  /**
   *
   * @type {ConversationUpdateRequestBaseWorkflow}
   * @memberof ConversationUpdateRequestBase
   */
  '$workflow'?: ConversationUpdateRequestBaseWorkflow;
}
/**
 * @type ConversationUpdateRequestBaseWorkflow
 * @export
 */
export type ConversationUpdateRequestBaseWorkflow = Workflow | string;

/**
 *
 * @export
 * @interface ConversationUpdateResponse
 */
export interface ConversationUpdateResponse {
  /**
   *
   * @type {boolean}
   * @memberof ConversationUpdateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ConversationUpdateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ConversationUpdateResponse
   */
  'id': string;
}
/**
 * Conversation web urls
 * @export
 * @interface ConversationUrls
 */
export interface ConversationUrls {
  /**
   * The client web url of the conversation
   * @type {string}
   * @memberof ConversationUrls
   */
  'clientWebUrl'?: string;
  /**
   * The agent web url of the conversation (requires phone two-factor authentication)
   * @type {string}
   * @memberof ConversationUrls
   */
  'agentWebUrl'?: string;
  /**
   * The agent test web url of the conversation, used for testing the conversation without notifying the customer
   * @type {string}
   * @memberof ConversationUrls
   */
  'agentTestWebUrl'?: string;
}
/**
 *
 * @export
 * @interface CreateAgentRequest
 */
export interface CreateAgentRequest {
  /**
   * Agent first name
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'firstName': string;
  /**
   * Agent last name
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'lastName': string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof CreateAgentRequest
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'forwardEmail': string;
  /**
   * Forward phone
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'forwardPhone': string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'title'?: string;
  /**
   * Context of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'context'?: string;
  /**
   * Locations ids the agent is included in
   * @type {Array<string>}
   * @memberof CreateAgentRequest
   */
  'includedLocations'?: Array<string>;
  /**
   * AI Model
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'model'?: CreateAgentRequestModelEnum;
  /**
   * Locations id the agent is excluded from
   * @type {Array<string>}
   * @memberof CreateAgentRequest
   */
  'excludedLocations'?: Array<string>;
  /**
   * Sample conversations that help build out your agent to mimic your responses
   * @type {Array<CreateAgentRequestAllOfConversationsInner>}
   * @memberof CreateAgentRequest
   */
  'conversations'?: Array<CreateAgentRequestAllOfConversationsInner>;
  /**
   * Sample audio files that help build out your agent to mimic your voice
   * @type {Array<string>}
   * @memberof CreateAgentRequest
   */
  'audio'?: Array<string>;
}

export const CreateAgentRequestModelEnum = {
  Scout9: 'Scout9',
  Bard: 'bard',
  Null: 'null'
} as const;

export type CreateAgentRequestModelEnum = typeof CreateAgentRequestModelEnum[keyof typeof CreateAgentRequestModelEnum];

/**
 *
 * @export
 * @interface CreateAgentRequestAllOf
 */
export interface CreateAgentRequestAllOf {
  /**
   * Sample conversations that help build out your agent to mimic your responses
   * @type {Array<CreateAgentRequestAllOfConversationsInner>}
   * @memberof CreateAgentRequestAllOf
   */
  'conversations'?: Array<CreateAgentRequestAllOfConversationsInner>;
  /**
   * Sample audio files that help build out your agent to mimic your voice
   * @type {Array<string>}
   * @memberof CreateAgentRequestAllOf
   */
  'audio'?: Array<string>;
}
/**
 * @type CreateAgentRequestAllOfConversationsInner
 * @export
 */
export type CreateAgentRequestAllOfConversationsInner = CreateAgentRequestAllOfConversationsInnerOneOf | string;

/**
 * Conversation sample
 * @export
 * @interface CreateAgentRequestAllOfConversationsInnerOneOf
 */
export interface CreateAgentRequestAllOfConversationsInnerOneOf {
  /**
   * The type or category of the conversation (this helps with associating work flows)
   * @type {string}
   * @memberof CreateAgentRequestAllOfConversationsInnerOneOf
   */
  'type': string;
  /**
   * The context of the conversation, this helps with associating work flows, or any caveats to the conversation
   * @type {string}
   * @memberof CreateAgentRequestAllOfConversationsInnerOneOf
   */
  'context'?: string;
  /**
   * Conversation
   * @type {Array<CreateAgentRequestAllOfConversationsInnerOneOfConversationInner>}
   * @memberof CreateAgentRequestAllOfConversationsInnerOneOf
   */
  'conversation': Array<CreateAgentRequestAllOfConversationsInnerOneOfConversationInner>;
}
/**
 *
 * @export
 * @interface CreateAgentRequestAllOfConversationsInnerOneOfConversationInner
 */
export interface CreateAgentRequestAllOfConversationsInnerOneOfConversationInner {
  /**
   * The speaker of the message, if this from the agent then this must have \"agent\" or match the agent\'s first or full name
   * @type {string}
   * @memberof CreateAgentRequestAllOfConversationsInnerOneOfConversationInner
   */
  'speaker': string;
  /**
   * The message content
   * @type {string}
   * @memberof CreateAgentRequestAllOfConversationsInnerOneOfConversationInner
   */
  'message': string;
}
/**
 *
 * @export
 * @interface CreateAgentResponse
 */
export interface CreateAgentResponse {
  /**
   *
   * @type {boolean}
   * @memberof CreateAgentResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof CreateAgentResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof CreateAgentResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface CreateAgentsRequest
 */
export interface CreateAgentsRequest {
  /**
   *
   * @type {Array<CreateAgentsRequestAgentsInner>}
   * @memberof CreateAgentsRequest
   */
  'agents'?: Array<CreateAgentsRequestAgentsInner>;
}
/**
 *
 * @export
 * @interface CreateAgentsRequestAgentsInner
 */
export interface CreateAgentsRequestAgentsInner {
  /**
   * Agent first name
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'firstName': string;
  /**
   * Agent last name
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'lastName': string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'title'?: string;
  /**
   * Context of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'context'?: string;
  /**
   * Locations ids the agent is included in
   * @type {Array<string>}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'includedLocations'?: Array<string>;
  /**
   * AI Model
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'model'?: CreateAgentsRequestAgentsInnerModelEnum;
  /**
   * Locations id the agent is excluded from
   * @type {Array<string>}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'excludedLocations'?: Array<string>;
}

export const CreateAgentsRequestAgentsInnerModelEnum = {
  Scout9: 'Scout9',
  Bard: 'bard',
  Null: 'null'
} as const;

export type CreateAgentsRequestAgentsInnerModelEnum = typeof CreateAgentsRequestAgentsInnerModelEnum[keyof typeof CreateAgentsRequestAgentsInnerModelEnum];

/**
 *
 * @export
 * @interface CreateAgentsResponse
 */
export interface CreateAgentsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof CreateAgentsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof CreateAgentsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface CreateContextRequest
 */
export interface CreateContextRequest {
  /**
   * The name of the context
   * @type {string}
   * @memberof CreateContextRequest
   */
  'name': string;
  /**
   * Whether or not the context is modifiable
   * @type {boolean}
   * @memberof CreateContextRequest
   */
  'modifiable': boolean;
  /**
   * The description of the context
   * @type {string}
   * @memberof CreateContextRequest
   */
  'description'?: string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof CreateContextRequest
   */
  'detection'?: ContextDetectionParams;
  /**
   * The ID column of the context
   * @type {string}
   * @memberof CreateContextRequest
   */
  'idColumn': string;
  /**
   * The columns of the context
   * @type {Array<string>}
   * @memberof CreateContextRequest
   */
  'columns': Array<string>;
  /**
   * The required columns of the context
   * @type {Array<string>}
   * @memberof CreateContextRequest
   */
  'requiredColumns'?: Array<string>;
}
/**
 *
 * @export
 * @interface CreateContextResponse
 */
export interface CreateContextResponse {
  /**
   *
   * @type {boolean}
   * @memberof CreateContextResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof CreateContextResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof CreateContextResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface CreateContextsRequest
 */
export interface CreateContextsRequest {
  /**
   *
   * @type {Array<CreateContextsRequestContextsInner>}
   * @memberof CreateContextsRequest
   */
  'contexts'?: Array<CreateContextsRequestContextsInner>;
}
/**
 *
 * @export
 * @interface CreateContextsRequestContextsInner
 */
export interface CreateContextsRequestContextsInner {
  /**
   * The name of the context
   * @type {string}
   * @memberof CreateContextsRequestContextsInner
   */
  'name': string;
  /**
   * Whether or not the context is modifiable
   * @type {boolean}
   * @memberof CreateContextsRequestContextsInner
   */
  'modifiable': boolean;
  /**
   * The description of the context
   * @type {string}
   * @memberof CreateContextsRequestContextsInner
   */
  'description'?: string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof CreateContextsRequestContextsInner
   */
  'detection'?: ContextDetectionParams;
  /**
   * The ID column of the context
   * @type {string}
   * @memberof CreateContextsRequestContextsInner
   */
  'idColumn': string;
  /**
   * The columns of the context
   * @type {Array<string>}
   * @memberof CreateContextsRequestContextsInner
   */
  'columns': Array<string>;
  /**
   * The required columns of the context
   * @type {Array<string>}
   * @memberof CreateContextsRequestContextsInner
   */
  'requiredColumns'?: Array<string>;
}
/**
 *
 * @export
 * @interface CreateContextsResponse
 */
export interface CreateContextsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof CreateContextsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof CreateContextsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface CreateCustomerGroupRequest
 */
export interface CreateCustomerGroupRequest {
  /**
   * The name of the customer group
   * @type {string}
   * @memberof CreateCustomerGroupRequest
   */
  'name': string;
  /**
   * The description of the customer group
   * @type {string}
   * @memberof CreateCustomerGroupRequest
   */
  'description'?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof CreateCustomerGroupRequest
   */
  'metadata'?: { [key: string]: any; };
  /**
   *
   * @type {Array<CustomerGroupRecord>}
   * @memberof CreateCustomerGroupRequest
   */
  'customers': Array<CustomerGroupRecord>;
}
/**
 *
 * @export
 * @interface CreateCustomerGroupResponse
 */
export interface CreateCustomerGroupResponse {
  /**
   *
   * @type {boolean}
   * @memberof CreateCustomerGroupResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof CreateCustomerGroupResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof CreateCustomerGroupResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface CreateCustomerGroupsRequest
 */
export interface CreateCustomerGroupsRequest {
  /**
   *
   * @type {Array<CustomerGroup>}
   * @memberof CreateCustomerGroupsRequest
   */
  'CustomerGroups': Array<CustomerGroup>;
}
/**
 *
 * @export
 * @interface CreateCustomerGroupsResponse
 */
export interface CreateCustomerGroupsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof CreateCustomerGroupsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof CreateCustomerGroupsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface CreateCustomerRequest
 */
export interface CreateCustomerRequest {
  /**
   * The customers first name
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  'firstName'?: string;
  /**
   * The customers last name
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  'lastName'?: string;
  /**
   * The customers full name
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  'name': string;
  /**
   * The customers email address
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  'email'?: string | null;
  /**
   * The customers phone number
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  'phone'?: string | null;
  /**
   * The customers profile image
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  'img'?: string | null;
  /**
   * The customers neighborhood
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  'neighborhood'?: string | null;
  /**
   * The customers city
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  'city'?: string | null;
  /**
   * The customers 2-letter country code
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  'country'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  'line1'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  'line2'?: string | null;
  /**
   * The customers postal code
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  'postal_code'?: string | null;
  /**
   * The customers state, county, province, or region
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  'state'?: string | null;
  /**
   * The customers town (only used in Japan)
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  'town'?: string | null;
  /**
   *
   * @type {BlockInfo}
   * @memberof CreateCustomerRequest
   */
  'blocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof CreateCustomerRequest
   */
  'phoneBlocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof CreateCustomerRequest
   */
  'emailBlocked'?: BlockInfo;
  /**
   * The date the customer joined the business
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  'joined'?: string | null;
  /**
   * The customers stripe ID
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  'stripe'?: string | null;
  /**
   * The customers stripe ID in the dev environment
   * @type {string}
   * @memberof CreateCustomerRequest
   */
  'stripeDev'?: string | null;
}
/**
 *
 * @export
 * @interface CreateCustomerResponse
 */
export interface CreateCustomerResponse {
  /**
   *
   * @type {boolean}
   * @memberof CreateCustomerResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof CreateCustomerResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof CreateCustomerResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface CreateCustomersRequest
 */
export interface CreateCustomersRequest {
  /**
   *
   * @type {Array<Customer>}
   * @memberof CreateCustomersRequest
   */
  'customers': Array<Customer>;
}
/**
 *
 * @export
 * @interface CreateCustomersResponse
 */
export interface CreateCustomersResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof CreateCustomersResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof CreateCustomersResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface CreateWorkflowRequest
 */
export interface CreateWorkflowRequest {
  /**
   * The name of the workflow
   * @type {string}
   * @memberof CreateWorkflowRequest
   */
  'name': string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof CreateWorkflowRequest
   */
  'initiators': ContextDetectionParams;
  /**
   * The fields of the workflow
   * @type {Array<ConversationContextField>}
   * @memberof CreateWorkflowRequest
   */
  'fields': Array<ConversationContextField>;
  /**
   * About this conversation - used as initial context
   * @type {string}
   * @memberof CreateWorkflowRequest
   */
  'context': string;
  /**
   * The webhook to call when a workflow is created
   * @type {string}
   * @memberof CreateWorkflowRequest
   */
  'onCreated'?: string;
  /**
   * The webhook to call when a workflow is updated
   * @type {string}
   * @memberof CreateWorkflowRequest
   */
  'onUpdated'?: string;
  /**
   * The webhook to call when a workflow is deleted
   * @type {string}
   * @memberof CreateWorkflowRequest
   */
  'onDeleted'?: string;
  /**
   * The webhook to call when a workflow has an error
   * @type {string}
   * @memberof CreateWorkflowRequest
   */
  'onError'?: string;
}
/**
 *
 * @export
 * @interface CreateWorkflowResponse
 */
export interface CreateWorkflowResponse {
  /**
   *
   * @type {boolean}
   * @memberof CreateWorkflowResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof CreateWorkflowResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof CreateWorkflowResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface CreateWorkflowsRequest
 */
export interface CreateWorkflowsRequest {
  /**
   *
   * @type {Array<CreateWorkflowsRequestWorkflowsInner>}
   * @memberof CreateWorkflowsRequest
   */
  'workflows'?: Array<CreateWorkflowsRequestWorkflowsInner>;
}
/**
 *
 * @export
 * @interface CreateWorkflowsRequestWorkflowsInner
 */
export interface CreateWorkflowsRequestWorkflowsInner {
  /**
   * The name of the workflow
   * @type {string}
   * @memberof CreateWorkflowsRequestWorkflowsInner
   */
  'name': string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof CreateWorkflowsRequestWorkflowsInner
   */
  'initiators': ContextDetectionParams;
  /**
   * The fields of the workflow
   * @type {Array<ConversationContextField>}
   * @memberof CreateWorkflowsRequestWorkflowsInner
   */
  'fields': Array<ConversationContextField>;
  /**
   * About this conversation - used as initial context
   * @type {string}
   * @memberof CreateWorkflowsRequestWorkflowsInner
   */
  'context': string;
  /**
   * The webhook to call when a workflow is created
   * @type {string}
   * @memberof CreateWorkflowsRequestWorkflowsInner
   */
  'onCreated'?: string;
  /**
   * The webhook to call when a workflow is updated
   * @type {string}
   * @memberof CreateWorkflowsRequestWorkflowsInner
   */
  'onUpdated'?: string;
  /**
   * The webhook to call when a workflow is deleted
   * @type {string}
   * @memberof CreateWorkflowsRequestWorkflowsInner
   */
  'onDeleted'?: string;
  /**
   * The webhook to call when a workflow has an error
   * @type {string}
   * @memberof CreateWorkflowsRequestWorkflowsInner
   */
  'onError'?: string;
}
/**
 *
 * @export
 * @interface CreateWorkflowsResponse
 */
export interface CreateWorkflowsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof CreateWorkflowsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof CreateWorkflowsResponse
   */
  '$operation': string;
}
/**
 * Represents a customer for your business or organization
 * @export
 * @interface Customer
 */
export interface Customer {
  [key: string]: CustomerValue | any;

  /**
   * The customers first name
   * @type {string}
   * @memberof Customer
   */
  'firstName'?: string;
  /**
   * The customers last name
   * @type {string}
   * @memberof Customer
   */
  'lastName'?: string;
  /**
   * The customers full name
   * @type {string}
   * @memberof Customer
   */
  'name': string;
  /**
   * The customers email address
   * @type {string}
   * @memberof Customer
   */
  'email'?: string | null;
  /**
   * The customers phone number
   * @type {string}
   * @memberof Customer
   */
  'phone'?: string | null;
  /**
   * The customers profile image
   * @type {string}
   * @memberof Customer
   */
  'img'?: string | null;
  /**
   * The customers neighborhood
   * @type {string}
   * @memberof Customer
   */
  'neighborhood'?: string | null;
  /**
   * The customers city
   * @type {string}
   * @memberof Customer
   */
  'city'?: string | null;
  /**
   * The customers 2-letter country code
   * @type {string}
   * @memberof Customer
   */
  'country'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof Customer
   */
  'line1'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof Customer
   */
  'line2'?: string | null;
  /**
   * The customers postal code
   * @type {string}
   * @memberof Customer
   */
  'postal_code'?: string | null;
  /**
   * The customers state, county, province, or region
   * @type {string}
   * @memberof Customer
   */
  'state'?: string | null;
  /**
   * The customers town (only used in Japan)
   * @type {string}
   * @memberof Customer
   */
  'town'?: string | null;
  /**
   *
   * @type {BlockInfo}
   * @memberof Customer
   */
  'blocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof Customer
   */
  'phoneBlocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof Customer
   */
  'emailBlocked'?: BlockInfo;
  /**
   * The date the customer joined the business
   * @type {string}
   * @memberof Customer
   */
  'joined'?: string | null;
  /**
   * The customers stripe ID
   * @type {string}
   * @memberof Customer
   */
  'stripe'?: string | null;
  /**
   * The customers stripe ID in the dev environment
   * @type {string}
   * @memberof Customer
   */
  'stripeDev'?: string | null;
}
/**
 * A way for a business to group customers to use in scheduling batch conversations
 * @export
 * @interface CustomerGroup
 */
export interface CustomerGroup {
  /**
   * The name of the customer group
   * @type {string}
   * @memberof CustomerGroup
   */
  'name': string;
  /**
   * The description of the customer group
   * @type {string}
   * @memberof CustomerGroup
   */
  'description'?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof CustomerGroup
   */
  'metadata'?: { [key: string]: any; };
  /**
   *
   * @type {Array<CustomerGroupRecord>}
   * @memberof CustomerGroup
   */
  'customers': Array<CustomerGroupRecord>;
}
/**
 * A way for a business to group customers to use in scheduling batch conversations
 * @export
 * @interface CustomerGroupRecord
 */
export interface CustomerGroupRecord {
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof CustomerGroupRecord
   */
  'id': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof CustomerGroupRecord
   */
  'environment': ConversationEnvironment;
  /**
   * Overrides the default $agent for this customer
   * @type {string}
   * @memberof CustomerGroupRecord
   */
  '$agent'?: string;
}


/**
 * @type CustomerValue
 * @export
 */
export type CustomerValue = boolean | number | string;

/**
 *
 * @export
 * @interface DeleteAgentResponse
 */
export interface DeleteAgentResponse {
  /**
   *
   * @type {boolean}
   * @memberof DeleteAgentResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof DeleteAgentResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof DeleteAgentResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface DeleteAgentsResponse
 */
export interface DeleteAgentsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof DeleteAgentsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof DeleteAgentsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface DeleteContextResponse
 */
export interface DeleteContextResponse {
  /**
   *
   * @type {boolean}
   * @memberof DeleteContextResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof DeleteContextResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof DeleteContextResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface DeleteContextsResponse
 */
export interface DeleteContextsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof DeleteContextsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof DeleteContextsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface DeleteCustomerGroupResponse
 */
export interface DeleteCustomerGroupResponse {
  /**
   *
   * @type {boolean}
   * @memberof DeleteCustomerGroupResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof DeleteCustomerGroupResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof DeleteCustomerGroupResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface DeleteCustomerGroupsResponse
 */
export interface DeleteCustomerGroupsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof DeleteCustomerGroupsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof DeleteCustomerGroupsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface DeleteCustomerResponse
 */
export interface DeleteCustomerResponse {
  /**
   *
   * @type {boolean}
   * @memberof DeleteCustomerResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof DeleteCustomerResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof DeleteCustomerResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface DeleteCustomersResponse
 */
export interface DeleteCustomersResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof DeleteCustomersResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof DeleteCustomersResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface DeleteFileResponse
 */
export interface DeleteFileResponse {
  /**
   *
   * @type {string}
   * @memberof DeleteFileResponse
   */
  'id': string;
  /**
   *
   * @type {string}
   * @memberof DeleteFileResponse
   */
  'object': string;
  /**
   *
   * @type {boolean}
   * @memberof DeleteFileResponse
   */
  'deleted': boolean;
}
/**
 *
 * @export
 * @interface DeleteWorkflowResponse
 */
export interface DeleteWorkflowResponse {
  /**
   *
   * @type {boolean}
   * @memberof DeleteWorkflowResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof DeleteWorkflowResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof DeleteWorkflowResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface DeleteWorkflowsResponse
 */
export interface DeleteWorkflowsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof DeleteWorkflowsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof DeleteWorkflowsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
  /**
   *
   * @type {Error}
   * @memberof ErrorResponse
   */
  'error': Error;
}
/**
 *
 * @export
 * @interface GenerateRequest
 */
export interface GenerateRequest {
  /**
   *
   * @type {GenerateRequestConvo}
   * @memberof GenerateRequest
   */
  'convo': GenerateRequestConvo;
  /**
   *
   * @type {GenerateRequestMocks}
   * @memberof GenerateRequest
   */
  'mocks'?: GenerateRequestMocks;
}
/**
 * @type GenerateRequestConvo
 * The conversation to generate a message from
 * @export
 */
export type GenerateRequestConvo = ConversationCreateRequest | string;

/**
 * If any mocks are provided, the response will be mocked and conversation will not be created. Requires .convo to be a Conversation object
 * @export
 * @interface GenerateRequestMocks
 */
export interface GenerateRequestMocks {
  /**
   * Any key,value information about the conversation, customr, or offer goes here
   * @type {{ [key: string]: any; }}
   * @memberof GenerateRequestMocks
   */
  'info'?: { [key: string]: any; };
  /**
   * Conversation Context fields to mock, use this to test out conversation logic
   * @type {Array<ConversationContextField>}
   * @memberof GenerateRequestMocks
   */
  'context'?: Array<ConversationContextField>;
  /**
   * Conversation Messages to mock, use this to test out anticipated responses
   * @type {Array<MessageBase>}
   * @memberof GenerateRequestMocks
   */
  'messages'?: Array<MessageBase>;
}
/**
 *
 * @export
 * @interface GenerateResponse
 */
export interface GenerateResponse {
  /**
   * The role of the message (customer, agent, or business)
   * @type {string}
   * @memberof GenerateResponse
   */
  'role': GenerateResponseRoleEnum;
  /**
   * The content of the message
   * @type {string}
   * @memberof GenerateResponse
   */
  'content': string;
  /**
   * The name of the sender
   * @type {string}
   * @memberof GenerateResponse
   */
  'name'?: string;
  /**
   * The time the message was sent
   * @type {string}
   * @memberof GenerateResponse
   */
  'time': string;
  /**
   * Any key,value information about the conversation, customr, or offer goes here
   * @type {{ [key: string]: any; }}
   * @memberof GenerateResponse
   */
  'info': { [key: string]: any; };
  /**
   * Conversation Context fields to mock, use this to test out conversation logic
   * @type {Array<ConversationContextField>}
   * @memberof GenerateResponse
   */
  'included': Array<ConversationContextField>;
}

export const GenerateResponseRoleEnum = {
  Customer: 'customer',
  Agent: 'agent',
  Context: 'context'
} as const;

export type GenerateResponseRoleEnum = typeof GenerateResponseRoleEnum[keyof typeof GenerateResponseRoleEnum];

/**
 *
 * @export
 * @interface GenerateResponseAllOf
 */
export interface GenerateResponseAllOf {
  /**
   * Any key,value information about the conversation, customr, or offer goes here
   * @type {{ [key: string]: any; }}
   * @memberof GenerateResponseAllOf
   */
  'info': { [key: string]: any; };
  /**
   * Conversation Context fields to mock, use this to test out conversation logic
   * @type {Array<ConversationContextField>}
   * @memberof GenerateResponseAllOf
   */
  'included': Array<ConversationContextField>;
}
/**
 *
 * @export
 * @interface GetAgentResponse
 */
export interface GetAgentResponse {
  /**
   * Agent first name
   * @type {string}
   * @memberof GetAgentResponse
   */
  'firstName': string;
  /**
   * Agent last name
   * @type {string}
   * @memberof GetAgentResponse
   */
  'lastName': string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof GetAgentResponse
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof GetAgentResponse
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof GetAgentResponse
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof GetAgentResponse
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof GetAgentResponse
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof GetAgentResponse
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof GetAgentResponse
   */
  'title'?: string;
  /**
   * Context of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof GetAgentResponse
   */
  'context'?: string;
  /**
   * Locations ids the agent is included in
   * @type {Array<string>}
   * @memberof GetAgentResponse
   */
  'includedLocations'?: Array<string>;
  /**
   * AI Model
   * @type {string}
   * @memberof GetAgentResponse
   */
  'model'?: GetAgentResponseModelEnum;
  /**
   * Locations id the agent is excluded from
   * @type {Array<string>}
   * @memberof GetAgentResponse
   */
  'excludedLocations'?: Array<string>;
  /**
   * The ID of the agent
   * @type {string}
   * @memberof GetAgentResponse
   */
  '$id': string;
}

export const GetAgentResponseModelEnum = {
  Scout9: 'Scout9',
  Bard: 'bard',
  Null: 'null'
} as const;

export type GetAgentResponseModelEnum = typeof GetAgentResponseModelEnum[keyof typeof GetAgentResponseModelEnum];

/**
 *
 * @export
 * @interface GetAgentResponseAllOf
 */
export interface GetAgentResponseAllOf {
  /**
   * The ID of the agent
   * @type {string}
   * @memberof GetAgentResponseAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface GetApiOperationResponse
 */
export interface GetApiOperationResponse {
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof GetApiOperationResponse
   */
  'time': string;
  /**
   * The model that was created, updated, or deleted
   * @type {string}
   * @memberof GetApiOperationResponse
   */
  'model': string;
  /**
   * The method that was called
   * @type {string}
   * @memberof GetApiOperationResponse
   */
  'method': GetApiOperationResponseMethodEnum;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof GetApiOperationResponse
   */
  'results': { [key: string]: any; };
  /**
   * The ID of the operation
   * @type {string}
   * @memberof GetApiOperationResponse
   */
  '$id': string;
}

export const GetApiOperationResponseMethodEnum = {
  Get: 'get',
  Post: 'post',
  Put: 'put',
  Delete: 'delete',
  Patch: 'patch'
} as const;

export type GetApiOperationResponseMethodEnum = typeof GetApiOperationResponseMethodEnum[keyof typeof GetApiOperationResponseMethodEnum];

/**
 *
 * @export
 * @interface GetApiOperationResponseAllOf
 */
export interface GetApiOperationResponseAllOf {
  /**
   * The ID of the operation
   * @type {string}
   * @memberof GetApiOperationResponseAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface GetContextResponse
 */
export interface GetContextResponse {
  /**
   * The name of the context
   * @type {string}
   * @memberof GetContextResponse
   */
  'name': string;
  /**
   * Whether or not the context is modifiable
   * @type {boolean}
   * @memberof GetContextResponse
   */
  'modifiable': boolean;
  /**
   * The description of the context
   * @type {string}
   * @memberof GetContextResponse
   */
  'description'?: string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof GetContextResponse
   */
  'detection'?: ContextDetectionParams;
  /**
   * The ID column of the context
   * @type {string}
   * @memberof GetContextResponse
   */
  'idColumn': string;
  /**
   * The columns of the context
   * @type {Array<string>}
   * @memberof GetContextResponse
   */
  'columns': Array<string>;
  /**
   * The required columns of the context
   * @type {Array<string>}
   * @memberof GetContextResponse
   */
  'requiredColumns'?: Array<string>;
  /**
   * The ID of the context
   * @type {string}
   * @memberof GetContextResponse
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface GetContextResponseAllOf
 */
export interface GetContextResponseAllOf {
  /**
   * The ID of the context
   * @type {string}
   * @memberof GetContextResponseAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface GetCustomerGroupResponse
 */
export interface GetCustomerGroupResponse {
  /**
   * The name of the customer group
   * @type {string}
   * @memberof GetCustomerGroupResponse
   */
  'name': string;
  /**
   * The description of the customer group
   * @type {string}
   * @memberof GetCustomerGroupResponse
   */
  'description'?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof GetCustomerGroupResponse
   */
  'metadata'?: { [key: string]: any; };
  /**
   *
   * @type {Array<CustomerGroupRecord>}
   * @memberof GetCustomerGroupResponse
   */
  'customers': Array<CustomerGroupRecord>;
  /**
   * The ID of the CustomerGroup
   * @type {string}
   * @memberof GetCustomerGroupResponse
   */
  '$id'?: string;
}
/**
 *
 * @export
 * @interface GetCustomerGroupResponseAllOf
 */
export interface GetCustomerGroupResponseAllOf {
  /**
   * The ID of the CustomerGroup
   * @type {string}
   * @memberof GetCustomerGroupResponseAllOf
   */
  '$id'?: string;
}
/**
 *
 * @export
 * @interface GetCustomerResponse
 */
export interface GetCustomerResponse {
  /**
   * The customers first name
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'firstName': string;
  /**
   * The customers last name
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'lastName': string;
  /**
   * The customers full name
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'name': string;
  /**
   * The customers email address
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'email'?: string | null;
  /**
   * The customers phone number
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'phone'?: string | null;
  /**
   * The customers profile image
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'img'?: string | null;
  /**
   * The customers neighborhood
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'neighborhood'?: string | null;
  /**
   * The customers city
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'city'?: string | null;
  /**
   * The customers 2-letter country code
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'country'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'line1'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'line2'?: string | null;
  /**
   * The customers postal code
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'postal_code'?: string | null;
  /**
   * The customers state, county, province, or region
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'state'?: string | null;
  /**
   * The customers town (only used in Japan)
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'town'?: string | null;
  /**
   *
   * @type {BlockInfo}
   * @memberof GetCustomerResponse
   */
  'blocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof GetCustomerResponse
   */
  'phoneBlocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof GetCustomerResponse
   */
  'emailBlocked'?: BlockInfo;
  /**
   * The date the customer joined the business
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'joined'?: string | null;
  /**
   * The customers stripe ID
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'stripe'?: string | null;
  /**
   * The customers stripe ID in the dev environment
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'stripeDev'?: string | null;
  /**
   * The ID of the customer
   * @type {string}
   * @memberof GetCustomerResponse
   */
  '$id'?: string;
}
/**
 *
 * @export
 * @interface GetCustomerResponseAllOf
 */
export interface GetCustomerResponseAllOf {
  /**
   * The ID of the customer
   * @type {string}
   * @memberof GetCustomerResponseAllOf
   */
  '$id'?: string;
}
/**
 *
 * @export
 * @interface GetWorkflowResponse
 */
export interface GetWorkflowResponse {
  /**
   * The name of the workflow
   * @type {string}
   * @memberof GetWorkflowResponse
   */
  'name': string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof GetWorkflowResponse
   */
  'initiators': ContextDetectionParams;
  /**
   * The fields of the workflow
   * @type {Array<ConversationContextField>}
   * @memberof GetWorkflowResponse
   */
  'fields': Array<ConversationContextField>;
  /**
   * About this conversation - used as initial context
   * @type {string}
   * @memberof GetWorkflowResponse
   */
  'context': string;
  /**
   * The webhook to call when a workflow is created
   * @type {string}
   * @memberof GetWorkflowResponse
   */
  'onCreated'?: string;
  /**
   * The webhook to call when a workflow is updated
   * @type {string}
   * @memberof GetWorkflowResponse
   */
  'onUpdated'?: string;
  /**
   * The webhook to call when a workflow is deleted
   * @type {string}
   * @memberof GetWorkflowResponse
   */
  'onDeleted'?: string;
  /**
   * The webhook to call when a workflow has an error
   * @type {string}
   * @memberof GetWorkflowResponse
   */
  'onError'?: string;
  /**
   * The ID of the workflow
   * @type {string}
   * @memberof GetWorkflowResponse
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface GetWorkflowResponseAllOf
 */
export interface GetWorkflowResponseAllOf {
  /**
   * The ID of the workflow
   * @type {string}
   * @memberof GetWorkflowResponseAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListAgentsResponseInner
 */
export interface ListAgentsResponseInner {
  /**
   * Agent first name
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'firstName'?: string;
  /**
   * Agent last name
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'lastName'?: string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof ListAgentsResponseInner
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'title'?: string;
  /**
   * Context of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'context'?: string;
  /**
   * Locations ids the agent is included in
   * @type {Array<string>}
   * @memberof ListAgentsResponseInner
   */
  'includedLocations'?: Array<string>;
  /**
   * AI Model
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'model'?: ListAgentsResponseInnerModelEnum;
  /**
   * Locations id the agent is excluded from
   * @type {Array<string>}
   * @memberof ListAgentsResponseInner
   */
  'excludedLocations'?: Array<string>;
  /**
   * The ID of the agent
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  '$id': string;
}

export const ListAgentsResponseInnerModelEnum = {
  Scout9: 'Scout9',
  Bard: 'bard',
  Null: 'null'
} as const;

export type ListAgentsResponseInnerModelEnum = typeof ListAgentsResponseInnerModelEnum[keyof typeof ListAgentsResponseInnerModelEnum];

/**
 *
 * @export
 * @interface ListAgentsResponseInnerAllOf
 */
export interface ListAgentsResponseInnerAllOf {
  /**
   * The ID of the agent
   * @type {string}
   * @memberof ListAgentsResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListApiOperationsResponseInner
 */
export interface ListApiOperationsResponseInner {
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ListApiOperationsResponseInner
   */
  'time': string;
  /**
   * The model that was created, updated, or deleted
   * @type {string}
   * @memberof ListApiOperationsResponseInner
   */
  'model': string;
  /**
   * The method that was called
   * @type {string}
   * @memberof ListApiOperationsResponseInner
   */
  'method': ListApiOperationsResponseInnerMethodEnum;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof ListApiOperationsResponseInner
   */
  'results': { [key: string]: any; };
  /**
   * The ID of the operation
   * @type {string}
   * @memberof ListApiOperationsResponseInner
   */
  '$id': string;
}

export const ListApiOperationsResponseInnerMethodEnum = {
  Get: 'get',
  Post: 'post',
  Put: 'put',
  Delete: 'delete',
  Patch: 'patch'
} as const;

export type ListApiOperationsResponseInnerMethodEnum = typeof ListApiOperationsResponseInnerMethodEnum[keyof typeof ListApiOperationsResponseInnerMethodEnum];

/**
 *
 * @export
 * @interface ListApiOperationsResponseInnerAllOf
 */
export interface ListApiOperationsResponseInnerAllOf {
  /**
   * The ID of the operation
   * @type {string}
   * @memberof ListApiOperationsResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListContextsResponseInner
 */
export interface ListContextsResponseInner {
  /**
   * The name of the context
   * @type {string}
   * @memberof ListContextsResponseInner
   */
  'name': string;
  /**
   * Whether or not the context is modifiable
   * @type {boolean}
   * @memberof ListContextsResponseInner
   */
  'modifiable': boolean;
  /**
   * The description of the context
   * @type {string}
   * @memberof ListContextsResponseInner
   */
  'description'?: string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof ListContextsResponseInner
   */
  'detection'?: ContextDetectionParams;
  /**
   * The ID column of the context
   * @type {string}
   * @memberof ListContextsResponseInner
   */
  'idColumn': string;
  /**
   * The columns of the context
   * @type {Array<string>}
   * @memberof ListContextsResponseInner
   */
  'columns': Array<string>;
  /**
   * The required columns of the context
   * @type {Array<string>}
   * @memberof ListContextsResponseInner
   */
  'requiredColumns'?: Array<string>;
  /**
   * The ID of the context
   * @type {string}
   * @memberof ListContextsResponseInner
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListContextsResponseInnerAllOf
 */
export interface ListContextsResponseInnerAllOf {
  /**
   * The ID of the context
   * @type {string}
   * @memberof ListContextsResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListCustomerGroupsResponseInner
 */
export interface ListCustomerGroupsResponseInner {
  /**
   * The name of the customer group
   * @type {string}
   * @memberof ListCustomerGroupsResponseInner
   */
  'name': string;
  /**
   * The description of the customer group
   * @type {string}
   * @memberof ListCustomerGroupsResponseInner
   */
  'description'?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof ListCustomerGroupsResponseInner
   */
  'metadata'?: { [key: string]: any; };
  /**
   *
   * @type {Array<CustomerGroupRecord>}
   * @memberof ListCustomerGroupsResponseInner
   */
  'customers': Array<CustomerGroupRecord>;
  /**
   * The ID of the CustomerGroup
   * @type {string}
   * @memberof ListCustomerGroupsResponseInner
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListCustomerGroupsResponseInnerAllOf
 */
export interface ListCustomerGroupsResponseInnerAllOf {
  /**
   * The ID of the CustomerGroup
   * @type {string}
   * @memberof ListCustomerGroupsResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListCustomersResponseInner
 */
export interface ListCustomersResponseInner {
  /**
   * The customers first name
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'firstName'?: string;
  /**
   * The customers last name
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'lastName'?: string;
  /**
   * The customers full name
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'name': string;
  /**
   * The customers email address
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'email'?: string | null;
  /**
   * The customers phone number
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'phone'?: string | null;
  /**
   * The customers profile image
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'img'?: string | null;
  /**
   * The customers neighborhood
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'neighborhood'?: string | null;
  /**
   * The customers city
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'city'?: string | null;
  /**
   * The customers 2-letter country code
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'country'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'line1'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'line2'?: string | null;
  /**
   * The customers postal code
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'postal_code'?: string | null;
  /**
   * The customers state, county, province, or region
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'state'?: string | null;
  /**
   * The customers town (only used in Japan)
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'town'?: string | null;
  /**
   *
   * @type {BlockInfo}
   * @memberof ListCustomersResponseInner
   */
  'blocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof ListCustomersResponseInner
   */
  'phoneBlocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof ListCustomersResponseInner
   */
  'emailBlocked'?: BlockInfo;
  /**
   * The date the customer joined the business
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'joined'?: string | null;
  /**
   * The customers stripe ID
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'stripe'?: string | null;
  /**
   * The customers stripe ID in the dev environment
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'stripeDev'?: string | null;
  /**
   * The ID of the customer
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListCustomersResponseInnerAllOf
 */
export interface ListCustomersResponseInnerAllOf {
  /**
   * The ID of the customer
   * @type {string}
   * @memberof ListCustomersResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListFilesResponse
 */
export interface ListFilesResponse {
  /**
   *
   * @type {string}
   * @memberof ListFilesResponse
   */
  'object': string;
  /**
   *
   * @type {Array<Scout9File>}
   * @memberof ListFilesResponse
   */
  'data': Array<Scout9File>;
}
/**
 *
 * @export
 * @interface ListQuery
 */
export interface ListQuery {
  /**
   *
   * @type {ListQueryId}
   * @memberof ListQuery
   */
  'id'?: ListQueryId;
  /**
   *
   * @type {Array<ListQueryOperationsInner>}
   * @memberof ListQuery
   */
  'operations'?: Array<ListQueryOperationsInner>;
}
/**
 * @type ListQueryId
 * @export
 */
export type ListQueryId = Array<string> | string;

/**
 *
 * @export
 * @interface ListQueryOperationsInner
 */
export interface ListQueryOperationsInner {
  /**
   * The field path to filter on
   * @type {string}
   * @memberof ListQueryOperationsInner
   */
  'fieldPath': string;
  /**
   *
   * @type {Operator}
   * @memberof ListQueryOperationsInner
   */
  'operator': Operator;
  /**
   *
   * @type {AnyValue}
   * @memberof ListQueryOperationsInner
   */
  'value': AnyValue;
}


/**
 *
 * @export
 * @interface ListWorkflowsResponseInner
 */
export interface ListWorkflowsResponseInner {
  /**
   * The name of the workflow
   * @type {string}
   * @memberof ListWorkflowsResponseInner
   */
  'name': string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof ListWorkflowsResponseInner
   */
  'initiators': ContextDetectionParams;
  /**
   * The fields of the workflow
   * @type {Array<ConversationContextField>}
   * @memberof ListWorkflowsResponseInner
   */
  'fields': Array<ConversationContextField>;
  /**
   * About this conversation - used as initial context
   * @type {string}
   * @memberof ListWorkflowsResponseInner
   */
  'context': string;
  /**
   * The webhook to call when a workflow is created
   * @type {string}
   * @memberof ListWorkflowsResponseInner
   */
  'onCreated'?: string;
  /**
   * The webhook to call when a workflow is updated
   * @type {string}
   * @memberof ListWorkflowsResponseInner
   */
  'onUpdated'?: string;
  /**
   * The webhook to call when a workflow is deleted
   * @type {string}
   * @memberof ListWorkflowsResponseInner
   */
  'onDeleted'?: string;
  /**
   * The webhook to call when a workflow has an error
   * @type {string}
   * @memberof ListWorkflowsResponseInner
   */
  'onError'?: string;
  /**
   * The ID of the workflow
   * @type {string}
   * @memberof ListWorkflowsResponseInner
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListWorkflowsResponseInnerAllOf
 */
export interface ListWorkflowsResponseInnerAllOf {
  /**
   * The ID of the workflow
   * @type {string}
   * @memberof ListWorkflowsResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface Message
 */
export interface Message {
  /**
   * The role of the message (customer, agent, or business)
   * @type {string}
   * @memberof Message
   */
  'role': MessageRoleEnum;
  /**
   * The content of the message
   * @type {string}
   * @memberof Message
   */
  'content': string;
  /**
   * The name of the sender
   * @type {string}
   * @memberof Message
   */
  'name'?: string;
  /**
   * The time the message was sent
   * @type {string}
   * @memberof Message
   */
  'time': string;
}

export const MessageRoleEnum = {
  Customer: 'customer',
  Agent: 'agent',
  Context: 'context'
} as const;

export type MessageRoleEnum = typeof MessageRoleEnum[keyof typeof MessageRoleEnum];

/**
 *
 * @export
 * @interface MessageAllOf
 */
export interface MessageAllOf {
  /**
   * The time the message was sent
   * @type {string}
   * @memberof MessageAllOf
   */
  'time': string;
}
/**
 *
 * @export
 * @interface MessageBase
 */
export interface MessageBase {
  /**
   * The role of the message (customer, agent, or business)
   * @type {string}
   * @memberof MessageBase
   */
  'role': MessageBaseRoleEnum;
  /**
   * The content of the message
   * @type {string}
   * @memberof MessageBase
   */
  'content': string;
  /**
   * The name of the sender
   * @type {string}
   * @memberof MessageBase
   */
  'name'?: string;
}

export const MessageBaseRoleEnum = {
  Customer: 'customer',
  Agent: 'agent',
  Context: 'context'
} as const;

export type MessageBaseRoleEnum = typeof MessageBaseRoleEnum[keyof typeof MessageBaseRoleEnum];

/**
 *
 * @export
 * @interface MessageCreateRequest
 */
export interface MessageCreateRequest {
  /**
   * Conversation ID this belonds to
   * @type {string}
   * @memberof MessageCreateRequest
   */
  'convo': string;
  /**
   * The message content to send to a user
   * @type {string}
   * @memberof MessageCreateRequest
   */
  'message': string;
  /**
   * The message content to send to a user in HTML format (only available in email)
   * @type {string}
   * @memberof MessageCreateRequest
   */
  'messageHtml'?: string;
  /**
   * Overrides the role of the user sending the message
   * @type {string}
   * @memberof MessageCreateRequest
   */
  'role'?: MessageCreateRequestRoleEnum;
}

export const MessageCreateRequestRoleEnum = {
  Agent: 'agent',
  Customer: 'customer',
  Context: 'context'
} as const;

export type MessageCreateRequestRoleEnum = typeof MessageCreateRequestRoleEnum[keyof typeof MessageCreateRequestRoleEnum];

/**
 *
 * @export
 * @interface MessageCreateResponse
 */
export interface MessageCreateResponse {
  /**
   *
   * @type {boolean}
   * @memberof MessageCreateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof MessageCreateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof MessageCreateResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface MessageGetResponseInner
 */
export interface MessageGetResponseInner {
  /**
   * The role of the message (customer, agent, or business)
   * @type {string}
   * @memberof MessageGetResponseInner
   */
  'role': MessageGetResponseInnerRoleEnum;
  /**
   * The content of the message
   * @type {string}
   * @memberof MessageGetResponseInner
   */
  'content': string;
  /**
   * The name of the sender
   * @type {string}
   * @memberof MessageGetResponseInner
   */
  'name'?: string;
  /**
   * The time the message was sent
   * @type {string}
   * @memberof MessageGetResponseInner
   */
  'time': string;
  /**
   * The ID of the message to get
   * @type {string}
   * @memberof MessageGetResponseInner
   */
  '$id': string;
}

export const MessageGetResponseInnerRoleEnum = {
  Customer: 'customer',
  Agent: 'agent',
  Context: 'context'
} as const;

export type MessageGetResponseInnerRoleEnum = typeof MessageGetResponseInnerRoleEnum[keyof typeof MessageGetResponseInnerRoleEnum];

/**
 *
 * @export
 * @interface MessageGetResponseInnerAllOf
 */
export interface MessageGetResponseInnerAllOf {
  /**
   * The ID of the message to get
   * @type {string}
   * @memberof MessageGetResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  'type': string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  'message': string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  'param': string | null;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  'code': string | null;
}
/**
 *
 * @export
 * @interface OperationBulkResponse
 */
export interface OperationBulkResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof OperationBulkResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof OperationBulkResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface OperationDocResponse
 */
export interface OperationDocResponse {
  /**
   *
   * @type {boolean}
   * @memberof OperationDocResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof OperationDocResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof OperationDocResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface OperationDocResponseAllOf
 */
export interface OperationDocResponseAllOf {
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof OperationDocResponseAllOf
   */
  'id': string;
}
/**
 *
 * @export
 * @interface OperationResponse
 */
export interface OperationResponse {
  /**
   *
   * @type {boolean}
   * @memberof OperationResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof OperationResponse
   */
  'error'?: Error;
}
/**
 * The operator of the condition or query
 * @export
 * @enum {string}
 */

export const Operator = {
  Eq: 'eq',
  Equal: 'equal',
  Ne: 'ne',
  NotEquals: 'not-equals',
  Gt: 'gt',
  GreaterThan: 'greater-than',
  Gte: 'gte',
  GreaterThanEquals: 'greater-than-equals',
  Lt: 'lt',
  LessThan: 'less-than',
  Lte: 'lte',
  LessThanEquals: 'less-than-equals',
  ArrayContains: 'array-contains',
  In: 'in',
  ArrayContainsAny: 'array-contains-any',
  NotIn: 'not-in'
} as const;

export type Operator = typeof Operator[keyof typeof Operator];


/**
 *
 * @export
 * @interface ScheduleCreateRequest
 */
export interface ScheduleCreateRequest {
  /**
   * Default agent assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduleCreateRequest
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduleCreateRequest
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduleCreateRequest
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof ScheduleCreateRequest
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ScheduleCreateRequest
   */
  'environment': ConversationEnvironment;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduleCreateRequest
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduleCreateRequest
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduleCreateRequest
   */
  'initialMessageHtml'?: string | null;
  /**
   * Group this conversation is in
   * @type {string}
   * @memberof ScheduleCreateRequest
   */
  '$group'?: string;
  /**
   *
   * @type {ConversationUpdateRequestBaseWorkflow}
   * @memberof ScheduleCreateRequest
   */
  '$workflow'?: ConversationUpdateRequestBaseWorkflow;
}


/**
 *
 * @export
 * @interface ScheduleCreateResponse
 */
export interface ScheduleCreateResponse {
  /**
   *
   * @type {boolean}
   * @memberof ScheduleCreateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ScheduleCreateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ScheduleCreateResponse
   */
  'id': string;
  /**
   * ISO Time the initial message has been sent
   * @type {string}
   * @memberof ScheduleCreateResponse
   */
  'sent'?: string;
}
/**
 *
 * @export
 * @interface ScheduleCreateResponseAllOf
 */
export interface ScheduleCreateResponseAllOf {
  /**
   * ISO Time the initial message has been sent
   * @type {string}
   * @memberof ScheduleCreateResponseAllOf
   */
  'sent'?: string;
}
/**
 *
 * @export
 * @interface ScheduleGetResponse
 */
export interface ScheduleGetResponse {
  /**
   * Default agent assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduleGetResponse
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduleGetResponse
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ScheduleGetResponse
   */
  'environment': ConversationEnvironment;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  'initialMessageHtml'?: string | null;
  /**
   * Group this conversation is in
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  '$group'?: string;
  /**
   * The ID of the workflow used for this conversation
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  '$workflow': string;
  /**
   * The client web url of the conversation
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  'clientWebUrl'?: string;
  /**
   * The agent web url of the conversation (requires phone two-factor authentication)
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  'agentWebUrl'?: string;
  /**
   * The agent test web url of the conversation, used for testing the conversation without notifying the customer
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  'agentTestWebUrl'?: string;
}


/**
 *
 * @export
 * @interface ScheduleGroupCreateRequest
 */
export interface ScheduleGroupCreateRequest {
  /**
   *
   * @type {ConversationUpdateRequestBaseWorkflow}
   * @memberof ScheduleGroupCreateRequest
   */
  '$workflow'?: ConversationUpdateRequestBaseWorkflow;
  /**
   * Default agent assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduleGroupCreateRequest
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduleGroupCreateRequest
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduleGroupCreateRequest
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduleGroupCreateRequest
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduleGroupCreateRequest
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduleGroupCreateRequest
   */
  'initialMessageHtml'?: string | null;
  /**
   * The delay in miliseconds between each customer, defaults to 15000 (15 seconds)
   * @type {number}
   * @memberof ScheduleGroupCreateRequest
   */
  'delay'?: number;
  /**
   *
   * @type {ScheduleGroupCreateRequestAllOfCGroup}
   * @memberof ScheduleGroupCreateRequest
   */
  '$cGroup': ScheduleGroupCreateRequestAllOfCGroup;
}
/**
 *
 * @export
 * @interface ScheduleGroupCreateRequestAllOf
 */
export interface ScheduleGroupCreateRequestAllOf {
  /**
   *
   * @type {ScheduleGroupCreateRequestAllOfCGroup}
   * @memberof ScheduleGroupCreateRequestAllOf
   */
  '$cGroup': ScheduleGroupCreateRequestAllOfCGroup;
}
/**
 * @type ScheduleGroupCreateRequestAllOfCGroup
 * @export
 */
export type ScheduleGroupCreateRequestAllOfCGroup = CustomerGroup | string;

/**
 *
 * @export
 * @interface ScheduleGroupCreateResponse
 */
export interface ScheduleGroupCreateResponse {
  /**
   *
   * @type {boolean}
   * @memberof ScheduleGroupCreateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ScheduleGroupCreateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ScheduleGroupCreateResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface ScheduleGroupGetResponse
 */
export interface ScheduleGroupGetResponse {
  /**
   * Default agent assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduleGroupGetResponse
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduleGroupGetResponse
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  'initialMessageHtml'?: string | null;
  /**
   * The delay in miliseconds between each customer, defaults to 15000 (15 seconds)
   * @type {number}
   * @memberof ScheduleGroupGetResponse
   */
  'delay'?: number;
  /**
   * The ID of the workflow used for this conversation
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  '$workflow': string;
  /**
   * The ID of the scheduled conversation group
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  '$id': string;
  /**
   * ISO Time the initial message has been sent
   * @type {boolean}
   * @memberof ScheduleGroupGetResponse
   */
  'sent'?: boolean;
  /**
   * The ID of the group the customers belong to
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  '$cGroup'?: string;
}
/**
 *
 * @export
 * @interface ScheduleGroupGetResponseAllOf
 */
export interface ScheduleGroupGetResponseAllOf {
  /**
   * The ID of the scheduled conversation group
   * @type {string}
   * @memberof ScheduleGroupGetResponseAllOf
   */
  '$id': string;
  /**
   * ISO Time the initial message has been sent
   * @type {boolean}
   * @memberof ScheduleGroupGetResponseAllOf
   */
  'sent'?: boolean;
  /**
   * The ID of the group the customers belong to
   * @type {string}
   * @memberof ScheduleGroupGetResponseAllOf
   */
  '$cGroup'?: string;
}
/**
 *
 * @export
 * @interface ScheduleGroupRemoveResponse
 */
export interface ScheduleGroupRemoveResponse {
  /**
   *
   * @type {boolean}
   * @memberof ScheduleGroupRemoveResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ScheduleGroupRemoveResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ScheduleGroupRemoveResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface ScheduleGroupUpdateRequest
 */
export interface ScheduleGroupUpdateRequest {
  /**
   * Default agent assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduleGroupUpdateRequest
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduleGroupUpdateRequest
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduleGroupUpdateRequest
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduleGroupUpdateRequest
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduleGroupUpdateRequest
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduleGroupUpdateRequest
   */
  'initialMessageHtml'?: string | null;
  /**
   * The delay in miliseconds between each customer, defaults to 15000 (15 seconds)
   * @type {number}
   * @memberof ScheduleGroupUpdateRequest
   */
  'delay'?: number;
  /**
   *
   * @type {ConversationUpdateRequestBaseWorkflow}
   * @memberof ScheduleGroupUpdateRequest
   */
  '$workflow'?: ConversationUpdateRequestBaseWorkflow;
  /**
   *
   * @type {ScheduleGroupCreateRequestAllOfCGroup}
   * @memberof ScheduleGroupUpdateRequest
   */
  '$cGroup'?: ScheduleGroupCreateRequestAllOfCGroup;
  /**
   * The ID of the scheduled conversation group to update
   * @type {string}
   * @memberof ScheduleGroupUpdateRequest
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ScheduleGroupUpdateRequestAllOf
 */
export interface ScheduleGroupUpdateRequestAllOf {
  /**
   *
   * @type {ScheduleGroupCreateRequestAllOfCGroup}
   * @memberof ScheduleGroupUpdateRequestAllOf
   */
  '$cGroup'?: ScheduleGroupCreateRequestAllOfCGroup;
  /**
   * The ID of the scheduled conversation group to update
   * @type {string}
   * @memberof ScheduleGroupUpdateRequestAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ScheduleGroupUpdateResponse
 */
export interface ScheduleGroupUpdateResponse {
  /**
   *
   * @type {boolean}
   * @memberof ScheduleGroupUpdateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ScheduleGroupUpdateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ScheduleGroupUpdateResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface ScheduleRemoveResponse
 */
export interface ScheduleRemoveResponse {
  /**
   *
   * @type {boolean}
   * @memberof ScheduleRemoveResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ScheduleRemoveResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ScheduleRemoveResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface ScheduleUpdateRequest
 */
export interface ScheduleUpdateRequest {
  /**
   * Default agent assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduleUpdateRequest
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduleUpdateRequest
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ScheduleUpdateRequest
   */
  'environment': ConversationEnvironment;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  'initialMessageHtml'?: string | null;
  /**
   * Group this conversation is in
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  '$group'?: string;
  /**
   *
   * @type {ConversationUpdateRequestBaseWorkflow}
   * @memberof ScheduleUpdateRequest
   */
  '$workflow'?: ConversationUpdateRequestBaseWorkflow;
  /**
   * The ID of the scheduled conversation to update
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  '$id'?: string;
}


/**
 *
 * @export
 * @interface ScheduleUpdateRequestAllOf
 */
export interface ScheduleUpdateRequestAllOf {
  /**
   * The ID of the scheduled conversation to update
   * @type {string}
   * @memberof ScheduleUpdateRequestAllOf
   */
  '$id'?: string;
}
/**
 *
 * @export
 * @interface ScheduleUpdateResponse
 */
export interface ScheduleUpdateResponse {
  /**
   *
   * @type {boolean}
   * @memberof ScheduleUpdateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ScheduleUpdateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ScheduleUpdateResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface ScheduledConversation
 */
export interface ScheduledConversation {
  /**
   * Default agent assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduledConversation
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduledConversation
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduledConversation
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof ScheduledConversation
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ScheduledConversation
   */
  'environment': ConversationEnvironment;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduledConversation
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduledConversation
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduledConversation
   */
  'initialMessageHtml'?: string | null;
  /**
   * Group this conversation is in
   * @type {string}
   * @memberof ScheduledConversation
   */
  '$group'?: string;
}


/**
 *
 * @export
 * @interface ScheduledConversationAllOf
 */
export interface ScheduledConversationAllOf {
  /**
   * Group this conversation is in
   * @type {string}
   * @memberof ScheduledConversationAllOf
   */
  '$group'?: string;
}
/**
 *
 * @export
 * @interface ScheduledConversationGroup
 */
export interface ScheduledConversationGroup {
  /**
   * Default agent assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduledConversationGroup
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduledConversationGroup
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduledConversationGroup
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduledConversationGroup
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduledConversationGroup
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduledConversationGroup
   */
  'initialMessageHtml'?: string | null;
  /**
   * The delay in miliseconds between each customer, defaults to 15000 (15 seconds)
   * @type {number}
   * @memberof ScheduledConversationGroup
   */
  'delay'?: number;
}
/**
 *
 * @export
 * @interface ScheduledConversationGroupAllOf
 */
export interface ScheduledConversationGroupAllOf {
  /**
   * The delay in miliseconds between each customer, defaults to 15000 (15 seconds)
   * @type {number}
   * @memberof ScheduledConversationGroupAllOf
   */
  'delay'?: number;
}
/**
 * The `File` object represents a document that has been uploaded to Scout9.
 * @export
 * @interface Scout9File
 */
export interface Scout9File {
  /**
   * The file identifier, which can be referenced in the API endpoints.
   * @type {string}
   * @memberof Scout9File
   */
  'id': string;
  /**
   * The object type, which is always \"file\".
   * @type {string}
   * @memberof Scout9File
   */
  'object': string;
  /**
   * The size of the file in bytes.
   * @type {number}
   * @memberof Scout9File
   */
  'bytes': number;
  /**
   * The unix timestamp for when the file was created.
   * @type {number}
   * @memberof Scout9File
   */
  'created_at': number;
  /**
   * The name of the file.
   * @type {string}
   * @memberof Scout9File
   */
  'filename': string;
  /**
   * The intended purpose of the file. Currently, only \"fine-tune\" is supported.
   * @type {string}
   * @memberof Scout9File
   */
  'purpose': string;
  /**
   * The current status of the file, which can be either `uploaded`, `processed`, `pending`, `error`, `deleting` or `deleted`.
   * @type {string}
   * @memberof Scout9File
   */
  'status'?: string;
  /**
   * Additional details about the status of the file. If the file is in the `error` state, this will include a message describing the error.
   * @type {string}
   * @memberof Scout9File
   */
  'status_details'?: string | null;
}
/**
 *
 * @export
 * @interface UpdateAgentRequest
 */
export interface UpdateAgentRequest {
  /**
   * The ID of the agent to update
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  '$id': string;
  /**
   * Sample conversations that help build out your agent to mimic your responses
   * @type {Array<CreateAgentRequestAllOfConversationsInner>}
   * @memberof UpdateAgentRequest
   */
  'conversations'?: Array<CreateAgentRequestAllOfConversationsInner>;
  /**
   * Sample audio files that help build out your agent to mimic your voice
   * @type {Array<string>}
   * @memberof UpdateAgentRequest
   */
  'audio'?: Array<string>;
  /**
   * Agent first name
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'firstName'?: string;
  /**
   * Agent last name
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'lastName'?: string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof UpdateAgentRequest
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'title'?: string;
  /**
   * Context of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'context'?: string;
  /**
   * Locations ids the agent is included in
   * @type {Array<string>}
   * @memberof UpdateAgentRequest
   */
  'includedLocations'?: Array<string>;
  /**
   * AI Model
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'model'?: UpdateAgentRequestModelEnum;
  /**
   * Locations id the agent is excluded from
   * @type {Array<string>}
   * @memberof UpdateAgentRequest
   */
  'excludedLocations'?: Array<string>;
}

export const UpdateAgentRequestModelEnum = {
  Scout9: 'Scout9',
  Bard: 'bard',
  Null: 'null'
} as const;

export type UpdateAgentRequestModelEnum = typeof UpdateAgentRequestModelEnum[keyof typeof UpdateAgentRequestModelEnum];

/**
 *
 * @export
 * @interface UpdateAgentRequestAllOf
 */
export interface UpdateAgentRequestAllOf {
  /**
   * The ID of the agent to update
   * @type {string}
   * @memberof UpdateAgentRequestAllOf
   */
  '$id': string;
  /**
   * Sample conversations that help build out your agent to mimic your responses
   * @type {Array<CreateAgentRequestAllOfConversationsInner>}
   * @memberof UpdateAgentRequestAllOf
   */
  'conversations'?: Array<CreateAgentRequestAllOfConversationsInner>;
  /**
   * Sample audio files that help build out your agent to mimic your voice
   * @type {Array<string>}
   * @memberof UpdateAgentRequestAllOf
   */
  'audio'?: Array<string>;
}
/**
 *
 * @export
 * @interface UpdateAgentResponse
 */
export interface UpdateAgentResponse {
  /**
   *
   * @type {boolean}
   * @memberof UpdateAgentResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof UpdateAgentResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof UpdateAgentResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface UpdateAgentsRequest
 */
export interface UpdateAgentsRequest {
  /**
   *
   * @type {Array<UpdateAgentsRequestAgentsInner>}
   * @memberof UpdateAgentsRequest
   */
  'agents'?: Array<UpdateAgentsRequestAgentsInner>;
}
/**
 *
 * @export
 * @interface UpdateAgentsRequestAgentsInner
 */
export interface UpdateAgentsRequestAgentsInner {
  /**
   * Agent first name
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'firstName': string;
  /**
   * Agent last name
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'lastName': string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'title'?: string;
  /**
   * Context of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'context'?: string;
  /**
   * Locations ids the agent is included in
   * @type {Array<string>}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'includedLocations'?: Array<string>;
  /**
   * AI Model
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'model'?: UpdateAgentsRequestAgentsInnerModelEnum;
  /**
   * Locations id the agent is excluded from
   * @type {Array<string>}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'excludedLocations'?: Array<string>;
  /**
   * The ID of the agent
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  '$id': string;
}

export const UpdateAgentsRequestAgentsInnerModelEnum = {
  Scout9: 'Scout9',
  Bard: 'bard',
  Null: 'null'
} as const;

export type UpdateAgentsRequestAgentsInnerModelEnum = typeof UpdateAgentsRequestAgentsInnerModelEnum[keyof typeof UpdateAgentsRequestAgentsInnerModelEnum];

/**
 *
 * @export
 * @interface UpdateAgentsRequestAgentsInnerAllOf
 */
export interface UpdateAgentsRequestAgentsInnerAllOf {
  /**
   * The ID of the agent
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateAgentsResponse
 */
export interface UpdateAgentsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof UpdateAgentsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof UpdateAgentsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface UpdateContextRequest
 */
export interface UpdateContextRequest {
  /**
   * The name of the context
   * @type {string}
   * @memberof UpdateContextRequest
   */
  'name': string;
  /**
   * Whether or not the context is modifiable
   * @type {boolean}
   * @memberof UpdateContextRequest
   */
  'modifiable': boolean;
  /**
   * The description of the context
   * @type {string}
   * @memberof UpdateContextRequest
   */
  'description'?: string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof UpdateContextRequest
   */
  'detection'?: ContextDetectionParams;
  /**
   * The ID column of the context
   * @type {string}
   * @memberof UpdateContextRequest
   */
  'idColumn': string;
  /**
   * The columns of the context
   * @type {Array<string>}
   * @memberof UpdateContextRequest
   */
  'columns': Array<string>;
  /**
   * The required columns of the context
   * @type {Array<string>}
   * @memberof UpdateContextRequest
   */
  'requiredColumns'?: Array<string>;
  /**
   * The ID of the context to update
   * @type {string}
   * @memberof UpdateContextRequest
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateContextRequestAllOf
 */
export interface UpdateContextRequestAllOf {
  /**
   * The ID of the context to update
   * @type {string}
   * @memberof UpdateContextRequestAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateContextResponse
 */
export interface UpdateContextResponse {
  /**
   *
   * @type {boolean}
   * @memberof UpdateContextResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof UpdateContextResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof UpdateContextResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface UpdateContextsRequest
 */
export interface UpdateContextsRequest {
  /**
   *
   * @type {Array<ListContextsResponseInner>}
   * @memberof UpdateContextsRequest
   */
  'contexts'?: Array<ListContextsResponseInner>;
}
/**
 *
 * @export
 * @interface UpdateContextsResponse
 */
export interface UpdateContextsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof UpdateContextsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof UpdateContextsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerGroupRequest
 */
export interface UpdateCustomerGroupRequest {
  /**
   * The name of the customer group
   * @type {string}
   * @memberof UpdateCustomerGroupRequest
   */
  'name': string;
  /**
   * The description of the customer group
   * @type {string}
   * @memberof UpdateCustomerGroupRequest
   */
  'description'?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof UpdateCustomerGroupRequest
   */
  'metadata'?: { [key: string]: any; };
  /**
   *
   * @type {Array<CustomerGroupRecord>}
   * @memberof UpdateCustomerGroupRequest
   */
  'customers': Array<CustomerGroupRecord>;
  /**
   * The ID of the CustomerGroup
   * @type {string}
   * @memberof UpdateCustomerGroupRequest
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerGroupRequestAllOf
 */
export interface UpdateCustomerGroupRequestAllOf {
  /**
   * The ID of the CustomerGroup
   * @type {string}
   * @memberof UpdateCustomerGroupRequestAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerGroupResponse
 */
export interface UpdateCustomerGroupResponse {
  /**
   *
   * @type {boolean}
   * @memberof UpdateCustomerGroupResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof UpdateCustomerGroupResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof UpdateCustomerGroupResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerGroupsRequest
 */
export interface UpdateCustomerGroupsRequest {
  /**
   *
   * @type {Array<ListCustomerGroupsResponseInner>}
   * @memberof UpdateCustomerGroupsRequest
   */
  'CustomerGroups'?: Array<ListCustomerGroupsResponseInner>;
}
/**
 *
 * @export
 * @interface UpdateCustomerGroupsResponse
 */
export interface UpdateCustomerGroupsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof UpdateCustomerGroupsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof UpdateCustomerGroupsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerRequest
 */
export interface UpdateCustomerRequest {
  /**
   * The customers first name
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'firstName'?: string;
  /**
   * The customers last name
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'lastName'?: string;
  /**
   * The customers full name
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'name': string;
  /**
   * The customers email address
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'email'?: string | null;
  /**
   * The customers phone number
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'phone'?: string | null;
  /**
   * The customers profile image
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'img'?: string | null;
  /**
   * The customers neighborhood
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'neighborhood'?: string | null;
  /**
   * The customers city
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'city'?: string | null;
  /**
   * The customers 2-letter country code
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'country'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'line1'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'line2'?: string | null;
  /**
   * The customers postal code
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'postal_code'?: string | null;
  /**
   * The customers state, county, province, or region
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'state'?: string | null;
  /**
   * The customers town (only used in Japan)
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'town'?: string | null;
  /**
   *
   * @type {BlockInfo}
   * @memberof UpdateCustomerRequest
   */
  'blocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof UpdateCustomerRequest
   */
  'phoneBlocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof UpdateCustomerRequest
   */
  'emailBlocked'?: BlockInfo;
  /**
   * The date the customer joined the business
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'joined'?: string | null;
  /**
   * The customers stripe ID
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'stripe'?: string | null;
  /**
   * The customers stripe ID in the dev environment
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'stripeDev'?: string | null;
  /**
   * The ID of the customer
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerRequestAllOf
 */
export interface UpdateCustomerRequestAllOf {
  /**
   * The ID of the customer
   * @type {string}
   * @memberof UpdateCustomerRequestAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerResponse
 */
export interface UpdateCustomerResponse {
  /**
   *
   * @type {boolean}
   * @memberof UpdateCustomerResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof UpdateCustomerResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof UpdateCustomerResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface UpdateCustomersRequest
 */
export interface UpdateCustomersRequest {
  /**
   *
   * @type {Array<ListCustomersResponseInner>}
   * @memberof UpdateCustomersRequest
   */
  'customers'?: Array<ListCustomersResponseInner>;
}
/**
 *
 * @export
 * @interface UpdateCustomersResponse
 */
export interface UpdateCustomersResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof UpdateCustomersResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof UpdateCustomersResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface UpdateWorkflowRequest
 */
export interface UpdateWorkflowRequest {
  /**
   * The name of the workflow
   * @type {string}
   * @memberof UpdateWorkflowRequest
   */
  'name': string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof UpdateWorkflowRequest
   */
  'initiators': ContextDetectionParams;
  /**
   * The fields of the workflow
   * @type {Array<ConversationContextField>}
   * @memberof UpdateWorkflowRequest
   */
  'fields': Array<ConversationContextField>;
  /**
   * About this conversation - used as initial context
   * @type {string}
   * @memberof UpdateWorkflowRequest
   */
  'context': string;
  /**
   * The webhook to call when a workflow is created
   * @type {string}
   * @memberof UpdateWorkflowRequest
   */
  'onCreated'?: string;
  /**
   * The webhook to call when a workflow is updated
   * @type {string}
   * @memberof UpdateWorkflowRequest
   */
  'onUpdated'?: string;
  /**
   * The webhook to call when a workflow is deleted
   * @type {string}
   * @memberof UpdateWorkflowRequest
   */
  'onDeleted'?: string;
  /**
   * The webhook to call when a workflow has an error
   * @type {string}
   * @memberof UpdateWorkflowRequest
   */
  'onError'?: string;
  /**
   * The ID of the workflow to update
   * @type {string}
   * @memberof UpdateWorkflowRequest
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateWorkflowRequestAllOf
 */
export interface UpdateWorkflowRequestAllOf {
  /**
   * The ID of the workflow to update
   * @type {string}
   * @memberof UpdateWorkflowRequestAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateWorkflowResponse
 */
export interface UpdateWorkflowResponse {
  /**
   *
   * @type {boolean}
   * @memberof UpdateWorkflowResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof UpdateWorkflowResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof UpdateWorkflowResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface UpdateWorkflowsRequest
 */
export interface UpdateWorkflowsRequest {
  /**
   *
   * @type {Array<ListWorkflowsResponseInner>}
   * @memberof UpdateWorkflowsRequest
   */
  'workflows'?: Array<ListWorkflowsResponseInner>;
}
/**
 *
 * @export
 * @interface UpdateWorkflowsResponse
 */
export interface UpdateWorkflowsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof UpdateWorkflowsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof UpdateWorkflowsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface Workflow
 */
export interface Workflow {
  /**
   * The name of the workflow
   * @type {string}
   * @memberof Workflow
   */
  'name': string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof Workflow
   */
  'initiators': ContextDetectionParams;
  /**
   * The fields of the workflow
   * @type {Array<ConversationContextField>}
   * @memberof Workflow
   */
  'fields': Array<ConversationContextField>;
  /**
   * About this conversation - used as initial context
   * @type {string}
   * @memberof Workflow
   */
  'context': string;
  /**
   * The webhook to call when a workflow is created
   * @type {string}
   * @memberof Workflow
   */
  'onCreated'?: string;
  /**
   * The webhook to call when a workflow is updated
   * @type {string}
   * @memberof Workflow
   */
  'onUpdated'?: string;
  /**
   * The webhook to call when a workflow is deleted
   * @type {string}
   * @memberof Workflow
   */
  'onDeleted'?: string;
  /**
   * The webhook to call when a workflow has an error
   * @type {string}
   * @memberof Workflow
   */
  'onError'?: string;
}

/**
 * Scout9Api - axios parameter creator
 * @export
 */
export const Scout9ApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agent: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('agent', 'id', id)
      const localVarPath = `/v1-agent`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('agentDelete', 'id', id)
      const localVarPath = `/v1-agent`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Registers a new agent
     * @param {CreateAgentRequest} createAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentRegister: async (createAgentRequest: CreateAgentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createAgentRequest' is not null or undefined
      assertParamExists('agentRegister', 'createAgentRequest', createAgentRequest)
      const localVarPath = `/v1-agent`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createAgentRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a agent
     * @param {UpdateAgentRequest} updateAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentUpdate: async (updateAgentRequest: UpdateAgentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateAgentRequest' is not null or undefined
      assertParamExists('agentUpdate', 'updateAgentRequest', updateAgentRequest)
      const localVarPath = `/v1-agent`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateAgentRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all or specific set of agents
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agents: async (q?: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-agents`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates new agents
     * @param {CreateAgentsRequest} createAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentsCreate: async (createAgentsRequest: CreateAgentsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createAgentsRequest' is not null or undefined
      assertParamExists('agentsCreate', 'createAgentsRequest', createAgentsRequest)
      const localVarPath = `/v1-agents`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createAgentsRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes multiple agents
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentsDelete: async (id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-agents`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates multiple agents
     * @param {UpdateAgentsRequest} updateAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentsUpdate: async (updateAgentsRequest: UpdateAgentsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateAgentsRequest' is not null or undefined
      assertParamExists('agentsUpdate', 'updateAgentsRequest', updateAgentsRequest)
      const localVarPath = `/v1-agents`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateAgentsRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a context
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    context: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('context', 'id', id)
      const localVarPath = `/v1-context`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a new context
     * @param {CreateContextRequest} createContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextCreate: async (createContextRequest: CreateContextRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createContextRequest' is not null or undefined
      assertParamExists('contextCreate', 'createContextRequest', createContextRequest)
      const localVarPath = `/v1-context`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createContextRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('contextDelete', 'id', id)
      const localVarPath = `/v1-context`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a context
     * @param {UpdateContextRequest} updateContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextUpdate: async (updateContextRequest: UpdateContextRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateContextRequest' is not null or undefined
      assertParamExists('contextUpdate', 'updateContextRequest', updateContextRequest)
      const localVarPath = `/v1-context`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateContextRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all or specific set of contexts
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contexts: async (q?: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-contexts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates new contexts
     * @param {CreateContextsRequest} createContextsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextsCreate: async (createContextsRequest: CreateContextsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createContextsRequest' is not null or undefined
      assertParamExists('contextsCreate', 'createContextsRequest', createContextsRequest)
      const localVarPath = `/v1-contexts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createContextsRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes multiple contexts
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextsDelete: async (id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-contexts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates multiple contexts
     * @param {UpdateContextRequest} updateContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextsUpdate: async (updateContextRequest: UpdateContextRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateContextRequest' is not null or undefined
      assertParamExists('contextsUpdate', 'updateContextRequest', updateContextRequest)
      const localVarPath = `/v1-contexts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateContextRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a conversation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversation: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('conversation', 'id', id)
      const localVarPath = `/v1-conversation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a new conversation
     * @param {ConversationCreateRequest} conversationCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationCreate: async (conversationCreateRequest: ConversationCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'conversationCreateRequest' is not null or undefined
      assertParamExists('conversationCreate', 'conversationCreateRequest', conversationCreateRequest)
      const localVarPath = `/v1-conversation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(conversationCreateRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('conversationDelete', 'id', id)
      const localVarPath = `/v1-conversation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a conversation
     * @param {ConversationUpdateRequest} conversationUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationUpdate: async (conversationUpdateRequest: ConversationUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'conversationUpdateRequest' is not null or undefined
      assertParamExists('conversationUpdate', 'conversationUpdateRequest', conversationUpdateRequest)
      const localVarPath = `/v1-conversation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(conversationUpdateRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a customer
     * @param {string} idOrEmailOrPhone id of customer or their registered phone or registered email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customer: async (idOrEmailOrPhone: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'idOrEmailOrPhone' is not null or undefined
      assertParamExists('customer', 'idOrEmailOrPhone', idOrEmailOrPhone)
      const localVarPath = `/v1-customer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (idOrEmailOrPhone !== undefined) {
        localVarQueryParameter['idOrEmailOrPhone'] = idOrEmailOrPhone;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates a new customer
     * @param {CreateCustomerRequest} createCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerCreate: async (createCustomerRequest: CreateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createCustomerRequest' is not null or undefined
      assertParamExists('customerCreate', 'createCustomerRequest', createCustomerRequest)
      const localVarPath = `/v1-customer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createCustomerRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a customer
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('customerDelete', 'id', id)
      const localVarPath = `/v1-customer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('customerGroup', 'id', id)
      const localVarPath = `/v1-customerGroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates a new customer group
     * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupCreate: async (createCustomerGroupRequest: CreateCustomerGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createCustomerGroupRequest' is not null or undefined
      assertParamExists('customerGroupCreate', 'createCustomerGroupRequest', createCustomerGroupRequest)
      const localVarPath = `/v1-customerGroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createCustomerGroupRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('customerGroupDelete', 'id', id)
      const localVarPath = `/v1-customerGroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates a customer group
     * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupUpdate: async (updateCustomerGroupRequest: UpdateCustomerGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateCustomerGroupRequest' is not null or undefined
      assertParamExists('customerGroupUpdate', 'updateCustomerGroupRequest', updateCustomerGroupRequest)
      const localVarPath = `/v1-customerGroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerGroupRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all or specific set of customer groups
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroups: async (q?: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-customerGroups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates new customer groups
     * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupsCreate: async (createCustomerGroupsRequest: CreateCustomerGroupsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createCustomerGroupsRequest' is not null or undefined
      assertParamExists('customerGroupsCreate', 'createCustomerGroupsRequest', createCustomerGroupsRequest)
      const localVarPath = `/v1-customerGroups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createCustomerGroupsRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes multiple customer groups
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupsDelete: async (id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-customerGroups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates multiple customer groups
     * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupsUpdate: async (updateCustomerGroupsRequest: UpdateCustomerGroupsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateCustomerGroupsRequest' is not null or undefined
      assertParamExists('customerGroupsUpdate', 'updateCustomerGroupsRequest', updateCustomerGroupsRequest)
      const localVarPath = `/v1-customerGroups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerGroupsRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates a customer
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerUpdate: async (updateCustomerRequest: UpdateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateCustomerRequest' is not null or undefined
      assertParamExists('customerUpdate', 'updateCustomerRequest', updateCustomerRequest)
      const localVarPath = `/v1-customer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all or specific set of customers
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customers: async (q?: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-customers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates new customers
     * @param {CreateCustomersRequest} createCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCreate: async (createCustomersRequest: CreateCustomersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createCustomersRequest' is not null or undefined
      assertParamExists('customersCreate', 'createCustomersRequest', createCustomersRequest)
      const localVarPath = `/v1-customers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createCustomersRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes multiple customers
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersDelete: async (id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-customers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates multiple customers
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersUpdate: async (updateCustomerRequest: UpdateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateCustomerRequest' is not null or undefined
      assertParamExists('customersUpdate', 'updateCustomerRequest', updateCustomerRequest)
      const localVarPath = `/v1-customers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns information about a specific file.
     * @param {string} fileId The ID of the file to use for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    file: async (fileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists('file', 'fileId', fileId)
      const localVarPath = `/files/{file_id}`
        .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
     * @param {File} file
     * @param {string} [purpose] The intended purpose of the uploaded documents.  This allows us to validate the format of the uploaded file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileCreate: async (file: File | Buffer | Blob, purpose?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists('fileCreate', 'file', file)
      const localVarPath = `/v1-utils-files`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


      if (file !== undefined) {
        localVarFormParams.append('file', file as any);
      }

      if (purpose !== undefined) {
        localVarFormParams.append('purpose', purpose as any);
      }


      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Delete a file.
     * @param {string} fileId The ID of the file to use for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileDelete: async (fileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists('fileDelete', 'fileId', fileId)
      const localVarPath = `/files/{file_id}`
        .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns the contents of the specified file
     * @param {string} fileId The ID of the file to use for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileDownload: async (fileId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'fileId' is not null or undefined
      assertParamExists('fileDownload', 'fileId', fileId)
      const localVarPath = `/files/{file_id}/content`
        .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns a list of files that belong to the user\'s organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    files: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-utils-files`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
     * @summary Generate a message from conversation
     * @param {GenerateRequest} generateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generate: async (generateRequest: GenerateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'generateRequest' is not null or undefined
      assertParamExists('generate', 'generateRequest', generateRequest)
      const localVarPath = `/v1-generate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(generateRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
     * @summary Create and send message
     * @param {MessageCreateRequest} messageCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    message: async (messageCreateRequest: MessageCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'messageCreateRequest' is not null or undefined
      assertParamExists('message', 'messageCreateRequest', messageCreateRequest)
      const localVarPath = `/v1-messages`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(messageCreateRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all messages from a conversation
     * @param {string} id id of entity to query
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    messages: async (id: string, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('messages', 'id', id)
      const localVarPath = `/v1-messages`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the results of a bulk API operation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operation: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('operation', 'id', id)
      const localVarPath = `/v1-utils-operation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all or specific set of bulk API operations
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operations: async (q?: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-utils-operations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates a new scheduled conversation
     * @param {ScheduleCreateRequest} scheduleCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleConversation: async (scheduleCreateRequest: ScheduleCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'scheduleCreateRequest' is not null or undefined
      assertParamExists('scheduleConversation', 'scheduleCreateRequest', scheduleCreateRequest)
      const localVarPath = `/v1-schedule`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(scheduleCreateRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('scheduleDelete', 'id', id)
      const localVarPath = `/v1-schedule`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates a new schedule group
     * @param {ScheduleGroupCreateRequest} scheduleGroupCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleGroupCreate: async (scheduleGroupCreateRequest: ScheduleGroupCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'scheduleGroupCreateRequest' is not null or undefined
      assertParamExists('scheduleGroupCreate', 'scheduleGroupCreateRequest', scheduleGroupCreateRequest)
      const localVarPath = `/v1-scheduleGroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(scheduleGroupCreateRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes and cancels a schedule group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleGroupDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('scheduleGroupDelete', 'id', id)
      const localVarPath = `/v1-scheduleGroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a schedule group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleGroupRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('scheduleGroupRetrieve', 'id', id)
      const localVarPath = `/v1-scheduleGroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates a schedule group
     * @param {ScheduleGroupUpdateRequest} scheduleGroupUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleGroupUpdate: async (scheduleGroupUpdateRequest: ScheduleGroupUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'scheduleGroupUpdateRequest' is not null or undefined
      assertParamExists('scheduleGroupUpdate', 'scheduleGroupUpdateRequest', scheduleGroupUpdateRequest)
      const localVarPath = `/v1-scheduleGroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(scheduleGroupUpdateRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleRetrieve: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('scheduleRetrieve', 'id', id)
      const localVarPath = `/v1-schedule`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates a schedule
     * @param {ScheduleUpdateRequest} scheduleUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleUpdate: async (scheduleUpdateRequest: ScheduleUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'scheduleUpdateRequest' is not null or undefined
      assertParamExists('scheduleUpdate', 'scheduleUpdateRequest', scheduleUpdateRequest)
      const localVarPath = `/v1-schedule`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(scheduleUpdateRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a workflow
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflow: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('workflow', 'id', id)
      const localVarPath = `/v1-workflow`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a new workflow
     * @param {CreateWorkflowRequest} createWorkflowRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowCreate: async (createWorkflowRequest: CreateWorkflowRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createWorkflowRequest' is not null or undefined
      assertParamExists('workflowCreate', 'createWorkflowRequest', createWorkflowRequest)
      const localVarPath = `/v1-workflow`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createWorkflowRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a workflow
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('workflowDelete', 'id', id)
      const localVarPath = `/v1-workflow`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a workflow
     * @param {UpdateWorkflowRequest} updateWorkflowRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowUpdate: async (updateWorkflowRequest: UpdateWorkflowRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateWorkflowRequest' is not null or undefined
      assertParamExists('workflowUpdate', 'updateWorkflowRequest', updateWorkflowRequest)
      const localVarPath = `/v1-workflow`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateWorkflowRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all or specific set of workflows
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflows: async (q?: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-workflows`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates new workflows
     * @param {CreateWorkflowsRequest} createWorkflowsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsCreate: async (createWorkflowsRequest: CreateWorkflowsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createWorkflowsRequest' is not null or undefined
      assertParamExists('workflowsCreate', 'createWorkflowsRequest', createWorkflowsRequest)
      const localVarPath = `/v1-workflows`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createWorkflowsRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes multiple workflows
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsDelete: async (id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-workflows`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates multiple workflows
     * @param {UpdateWorkflowRequest} updateWorkflowRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsUpdate: async (updateWorkflowRequest: UpdateWorkflowRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateWorkflowRequest' is not null or undefined
      assertParamExists('workflowsUpdate', 'updateWorkflowRequest', updateWorkflowRequest)
      const localVarPath = `/v1-workflows`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateWorkflowRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  }
};

/**
 * Scout9Api - functional programming interface
 * @export
 */
export const Scout9ApiFp = function(configuration?: Configuration) {
  const localVarAxiosParamCreator = Scout9ApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Gets a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agent(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAgentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agent(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAgentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agentDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Registers a new agent
     * @param {CreateAgentRequest} createAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentRegister(createAgentRequest: CreateAgentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAgentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agentRegister(createAgentRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update a agent
     * @param {UpdateAgentRequest} updateAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentUpdate(updateAgentRequest: UpdateAgentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAgentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agentUpdate(updateAgentRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets all or specific set of agents
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agents(q?: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListAgentsResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agents(q, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates new agents
     * @param {CreateAgentsRequest} createAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentsCreate(createAgentsRequest: CreateAgentsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAgentsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agentsCreate(createAgentsRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes multiple agents
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentsDelete(id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAgentsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agentsDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates multiple agents
     * @param {UpdateAgentsRequest} updateAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentsUpdate(updateAgentsRequest: UpdateAgentsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAgentsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agentsUpdate(updateAgentsRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a context
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async context(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContextResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.context(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Create a new context
     * @param {CreateContextRequest} createContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contextCreate(createContextRequest: CreateContextRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateContextResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contextCreate(createContextRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contextDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteContextResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contextDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update a context
     * @param {UpdateContextRequest} updateContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contextUpdate(updateContextRequest: UpdateContextRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateContextResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contextUpdate(updateContextRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets all or specific set of contexts
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contexts(q?: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListContextsResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contexts(q, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates new contexts
     * @param {CreateContextsRequest} createContextsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contextsCreate(createContextsRequest: CreateContextsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateContextsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contextsCreate(createContextsRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes multiple contexts
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contextsDelete(id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteContextsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contextsDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates multiple contexts
     * @param {UpdateContextRequest} updateContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contextsUpdate(updateContextRequest: UpdateContextRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateContextsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contextsUpdate(updateContextRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a conversation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async conversation(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationGetResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.conversation(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Create a new conversation
     * @param {ConversationCreateRequest} conversationCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async conversationCreate(conversationCreateRequest: ConversationCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationCreateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.conversationCreate(conversationCreateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async conversationDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationRemoveResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.conversationDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update a conversation
     * @param {ConversationUpdateRequest} conversationUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async conversationUpdate(conversationUpdateRequest: ConversationUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationUpdateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.conversationUpdate(conversationUpdateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a customer
     * @param {string} idOrEmailOrPhone id of customer or their registered phone or registered email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customer(idOrEmailOrPhone: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomerResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customer(idOrEmailOrPhone, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates a new customer
     * @param {CreateCustomerRequest} createCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerCreate(createCustomerRequest: CreateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomerResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerCreate(createCustomerRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes a customer
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCustomerResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomerGroupResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroup(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates a new customer group
     * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroupCreate(createCustomerGroupRequest: CreateCustomerGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomerGroupResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupCreate(createCustomerGroupRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroupDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCustomerGroupResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates a customer group
     * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroupUpdate(updateCustomerGroupRequest: UpdateCustomerGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCustomerGroupResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupUpdate(updateCustomerGroupRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets all or specific set of customer groups
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroups(q?: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListCustomerGroupsResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroups(q, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates new customer groups
     * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroupsCreate(createCustomerGroupsRequest: CreateCustomerGroupsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomerGroupsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupsCreate(createCustomerGroupsRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes multiple customer groups
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroupsDelete(id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCustomerGroupsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupsDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates multiple customer groups
     * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroupsUpdate(updateCustomerGroupsRequest: UpdateCustomerGroupsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCustomerGroupsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupsUpdate(updateCustomerGroupsRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates a customer
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerUpdate(updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCustomerResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerUpdate(updateCustomerRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets all or specific set of customers
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customers(q?: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListCustomersResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customers(q, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates new customers
     * @param {CreateCustomersRequest} createCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customersCreate(createCustomersRequest: CreateCustomersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomersResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customersCreate(createCustomersRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes multiple customers
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customersDelete(id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCustomersResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customersDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates multiple customers
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customersUpdate(updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCustomersResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customersUpdate(updateCustomerRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Returns information about a specific file.
     * @param {string} fileId The ID of the file to use for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async file(fileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scout9File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.file(fileId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
     * @param {File} file
     * @param {string} [purpose] The intended purpose of the uploaded documents.  This allows us to validate the format of the uploaded file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fileCreate(file: File | Buffer | Blob, purpose?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scout9File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.fileCreate(file, purpose, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Delete a file.
     * @param {string} fileId The ID of the file to use for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fileDelete(fileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteFileResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.fileDelete(fileId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Returns the contents of the specified file
     * @param {string} fileId The ID of the file to use for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fileDownload(fileId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.fileDownload(fileId, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Returns a list of files that belong to the user\'s organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async files(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListFilesResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.files(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
     * @summary Generate a message from conversation
     * @param {GenerateRequest} generateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generate(generateRequest: GenerateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generate(generateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
     * @summary Create and send message
     * @param {MessageCreateRequest} messageCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async message(messageCreateRequest: MessageCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageCreateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.message(messageCreateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get all messages from a conversation
     * @param {string} id id of entity to query
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async messages(id: string, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageGetResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.messages(id, q, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get the results of a bulk API operation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async operation(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApiOperationResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.operation(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets all or specific set of bulk API operations
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async operations(q?: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListApiOperationsResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.operations(q, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates a new scheduled conversation
     * @param {ScheduleCreateRequest} scheduleCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scheduleConversation(scheduleCreateRequest: ScheduleCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleCreateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleConversation(scheduleCreateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scheduleDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleRemoveResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates a new schedule group
     * @param {ScheduleGroupCreateRequest} scheduleGroupCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scheduleGroupCreate(scheduleGroupCreateRequest: ScheduleGroupCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleGroupCreateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleGroupCreate(scheduleGroupCreateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes and cancels a schedule group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scheduleGroupDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleGroupRemoveResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleGroupDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a schedule group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scheduleGroupRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleGroupGetResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleGroupRetrieve(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates a schedule group
     * @param {ScheduleGroupUpdateRequest} scheduleGroupUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scheduleGroupUpdate(scheduleGroupUpdateRequest: ScheduleGroupUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleGroupUpdateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleGroupUpdate(scheduleGroupUpdateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scheduleRetrieve(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleCreateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleRetrieve(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates a schedule
     * @param {ScheduleUpdateRequest} scheduleUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async scheduleUpdate(scheduleUpdateRequest: ScheduleUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleUpdateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleUpdate(scheduleUpdateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a workflow
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflow(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWorkflowResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflow(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Create a new workflow
     * @param {CreateWorkflowRequest} createWorkflowRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflowCreate(createWorkflowRequest: CreateWorkflowRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWorkflowResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflowCreate(createWorkflowRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes a workflow
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflowDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteWorkflowResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflowDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update a workflow
     * @param {UpdateWorkflowRequest} updateWorkflowRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflowUpdate(updateWorkflowRequest: UpdateWorkflowRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateWorkflowResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflowUpdate(updateWorkflowRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets all or specific set of workflows
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflows(q?: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListWorkflowsResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflows(q, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates new workflows
     * @param {CreateWorkflowsRequest} createWorkflowsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflowsCreate(createWorkflowsRequest: CreateWorkflowsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWorkflowsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsCreate(createWorkflowsRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes multiple workflows
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflowsDelete(id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteWorkflowsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates multiple workflows
     * @param {UpdateWorkflowRequest} updateWorkflowRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async workflowsUpdate(updateWorkflowRequest: UpdateWorkflowRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateWorkflowsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsUpdate(updateWorkflowRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  }
};

/**
 * Scout9Api - factory interface
 * @export
 */
export const Scout9ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = Scout9ApiFp(configuration)
  return {
    /**
     *
     * @summary Gets a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agent(id: string, options?: any): AxiosPromise<GetAgentResponse> {
      return localVarFp.agent(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentDelete(id: string, options?: any): AxiosPromise<DeleteAgentResponse> {
      return localVarFp.agentDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Registers a new agent
     * @param {CreateAgentRequest} createAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentRegister(createAgentRequest: CreateAgentRequest, options?: any): AxiosPromise<CreateAgentResponse> {
      return localVarFp.agentRegister(createAgentRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a agent
     * @param {UpdateAgentRequest} updateAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentUpdate(updateAgentRequest: UpdateAgentRequest, options?: any): AxiosPromise<UpdateAgentResponse> {
      return localVarFp.agentUpdate(updateAgentRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all or specific set of agents
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agents(q?: string, id?: Array<string>, options?: any): AxiosPromise<Array<ListAgentsResponseInner>> {
      return localVarFp.agents(q, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates new agents
     * @param {CreateAgentsRequest} createAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentsCreate(createAgentsRequest: CreateAgentsRequest, options?: any): AxiosPromise<CreateAgentsResponse> {
      return localVarFp.agentsCreate(createAgentsRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes multiple agents
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentsDelete(id?: Array<string>, options?: any): AxiosPromise<DeleteAgentsResponse> {
      return localVarFp.agentsDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates multiple agents
     * @param {UpdateAgentsRequest} updateAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentsUpdate(updateAgentsRequest: UpdateAgentsRequest, options?: any): AxiosPromise<UpdateAgentsResponse> {
      return localVarFp.agentsUpdate(updateAgentsRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a context
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    context(id: string, options?: any): AxiosPromise<GetContextResponse> {
      return localVarFp.context(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a new context
     * @param {CreateContextRequest} createContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextCreate(createContextRequest: CreateContextRequest, options?: any): AxiosPromise<CreateContextResponse> {
      return localVarFp.contextCreate(createContextRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextDelete(id: string, options?: any): AxiosPromise<DeleteContextResponse> {
      return localVarFp.contextDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a context
     * @param {UpdateContextRequest} updateContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextUpdate(updateContextRequest: UpdateContextRequest, options?: any): AxiosPromise<UpdateContextResponse> {
      return localVarFp.contextUpdate(updateContextRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all or specific set of contexts
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contexts(q?: string, id?: Array<string>, options?: any): AxiosPromise<Array<ListContextsResponseInner>> {
      return localVarFp.contexts(q, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates new contexts
     * @param {CreateContextsRequest} createContextsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextsCreate(createContextsRequest: CreateContextsRequest, options?: any): AxiosPromise<CreateContextsResponse> {
      return localVarFp.contextsCreate(createContextsRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes multiple contexts
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextsDelete(id?: Array<string>, options?: any): AxiosPromise<DeleteContextsResponse> {
      return localVarFp.contextsDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates multiple contexts
     * @param {UpdateContextRequest} updateContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextsUpdate(updateContextRequest: UpdateContextRequest, options?: any): AxiosPromise<UpdateContextsResponse> {
      return localVarFp.contextsUpdate(updateContextRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a conversation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversation(id: string, options?: any): AxiosPromise<ConversationGetResponse> {
      return localVarFp.conversation(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a new conversation
     * @param {ConversationCreateRequest} conversationCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationCreate(conversationCreateRequest: ConversationCreateRequest, options?: any): AxiosPromise<ConversationCreateResponse> {
      return localVarFp.conversationCreate(conversationCreateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationDelete(id: string, options?: any): AxiosPromise<ConversationRemoveResponse> {
      return localVarFp.conversationDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a conversation
     * @param {ConversationUpdateRequest} conversationUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationUpdate(conversationUpdateRequest: ConversationUpdateRequest, options?: any): AxiosPromise<ConversationUpdateResponse> {
      return localVarFp.conversationUpdate(conversationUpdateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a customer
     * @param {string} idOrEmailOrPhone id of customer or their registered phone or registered email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customer(idOrEmailOrPhone: string, options?: any): AxiosPromise<GetCustomerResponse> {
      return localVarFp.customer(idOrEmailOrPhone, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates a new customer
     * @param {CreateCustomerRequest} createCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerCreate(createCustomerRequest: CreateCustomerRequest, options?: any): AxiosPromise<CreateCustomerResponse> {
      return localVarFp.customerCreate(createCustomerRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes a customer
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerDelete(id: string, options?: any): AxiosPromise<DeleteCustomerResponse> {
      return localVarFp.customerDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroup(id: string, options?: any): AxiosPromise<GetCustomerGroupResponse> {
      return localVarFp.customerGroup(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates a new customer group
     * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupCreate(createCustomerGroupRequest: CreateCustomerGroupRequest, options?: any): AxiosPromise<CreateCustomerGroupResponse> {
      return localVarFp.customerGroupCreate(createCustomerGroupRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupDelete(id: string, options?: any): AxiosPromise<DeleteCustomerGroupResponse> {
      return localVarFp.customerGroupDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates a customer group
     * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupUpdate(updateCustomerGroupRequest: UpdateCustomerGroupRequest, options?: any): AxiosPromise<UpdateCustomerGroupResponse> {
      return localVarFp.customerGroupUpdate(updateCustomerGroupRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all or specific set of customer groups
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroups(q?: string, id?: Array<string>, options?: any): AxiosPromise<Array<ListCustomerGroupsResponseInner>> {
      return localVarFp.customerGroups(q, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates new customer groups
     * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupsCreate(createCustomerGroupsRequest: CreateCustomerGroupsRequest, options?: any): AxiosPromise<CreateCustomerGroupsResponse> {
      return localVarFp.customerGroupsCreate(createCustomerGroupsRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes multiple customer groups
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupsDelete(id?: Array<string>, options?: any): AxiosPromise<DeleteCustomerGroupsResponse> {
      return localVarFp.customerGroupsDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates multiple customer groups
     * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupsUpdate(updateCustomerGroupsRequest: UpdateCustomerGroupsRequest, options?: any): AxiosPromise<UpdateCustomerGroupsResponse> {
      return localVarFp.customerGroupsUpdate(updateCustomerGroupsRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates a customer
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerUpdate(updateCustomerRequest: UpdateCustomerRequest, options?: any): AxiosPromise<UpdateCustomerResponse> {
      return localVarFp.customerUpdate(updateCustomerRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all or specific set of customers
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customers(q?: string, id?: Array<string>, options?: any): AxiosPromise<Array<ListCustomersResponseInner>> {
      return localVarFp.customers(q, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates new customers
     * @param {CreateCustomersRequest} createCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCreate(createCustomersRequest: CreateCustomersRequest, options?: any): AxiosPromise<CreateCustomersResponse> {
      return localVarFp.customersCreate(createCustomersRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes multiple customers
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersDelete(id?: Array<string>, options?: any): AxiosPromise<DeleteCustomersResponse> {
      return localVarFp.customersDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates multiple customers
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersUpdate(updateCustomerRequest: UpdateCustomerRequest, options?: any): AxiosPromise<UpdateCustomersResponse> {
      return localVarFp.customersUpdate(updateCustomerRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns information about a specific file.
     * @param {string} fileId The ID of the file to use for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    file(fileId: string, options?: any): AxiosPromise<Scout9File> {
      return localVarFp.file(fileId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
     * @param {File} file
     * @param {string} [purpose] The intended purpose of the uploaded documents.  This allows us to validate the format of the uploaded file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileCreate(file: File | Buffer | Blob, purpose?: string, options?: any): AxiosPromise<Scout9File> {
      return localVarFp.fileCreate(file, purpose, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Delete a file.
     * @param {string} fileId The ID of the file to use for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileDelete(fileId: string, options?: any): AxiosPromise<DeleteFileResponse> {
      return localVarFp.fileDelete(fileId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns the contents of the specified file
     * @param {string} fileId The ID of the file to use for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileDownload(fileId: string, options?: any): AxiosPromise<string> {
      return localVarFp.fileDownload(fileId, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns a list of files that belong to the user\'s organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    files(options?: any): AxiosPromise<ListFilesResponse> {
      return localVarFp.files(options).then((request) => request(axios, basePath));
    },
    /**
     * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
     * @summary Generate a message from conversation
     * @param {GenerateRequest} generateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generate(generateRequest: GenerateRequest, options?: any): AxiosPromise<GenerateResponse> {
      return localVarFp.generate(generateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
     * @summary Create and send message
     * @param {MessageCreateRequest} messageCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    message(messageCreateRequest: MessageCreateRequest, options?: any): AxiosPromise<MessageCreateResponse> {
      return localVarFp.message(messageCreateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all messages from a conversation
     * @param {string} id id of entity to query
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    messages(id: string, q?: string, options?: any): AxiosPromise<Array<MessageGetResponseInner>> {
      return localVarFp.messages(id, q, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the results of a bulk API operation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operation(id: string, options?: any): AxiosPromise<GetApiOperationResponse> {
      return localVarFp.operation(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all or specific set of bulk API operations
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operations(q?: string, id?: Array<string>, options?: any): AxiosPromise<Array<ListApiOperationsResponseInner>> {
      return localVarFp.operations(q, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates a new scheduled conversation
     * @param {ScheduleCreateRequest} scheduleCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleConversation(scheduleCreateRequest: ScheduleCreateRequest, options?: any): AxiosPromise<ScheduleCreateResponse> {
      return localVarFp.scheduleConversation(scheduleCreateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleDelete(id: string, options?: any): AxiosPromise<ScheduleRemoveResponse> {
      return localVarFp.scheduleDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates a new schedule group
     * @param {ScheduleGroupCreateRequest} scheduleGroupCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleGroupCreate(scheduleGroupCreateRequest: ScheduleGroupCreateRequest, options?: any): AxiosPromise<ScheduleGroupCreateResponse> {
      return localVarFp.scheduleGroupCreate(scheduleGroupCreateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes and cancels a schedule group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleGroupDelete(id: string, options?: any): AxiosPromise<ScheduleGroupRemoveResponse> {
      return localVarFp.scheduleGroupDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a schedule group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleGroupRetrieve(id: string, options?: any): AxiosPromise<ScheduleGroupGetResponse> {
      return localVarFp.scheduleGroupRetrieve(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates a schedule group
     * @param {ScheduleGroupUpdateRequest} scheduleGroupUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleGroupUpdate(scheduleGroupUpdateRequest: ScheduleGroupUpdateRequest, options?: any): AxiosPromise<ScheduleGroupUpdateResponse> {
      return localVarFp.scheduleGroupUpdate(scheduleGroupUpdateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleRetrieve(id: string, options?: any): AxiosPromise<ScheduleCreateResponse> {
      return localVarFp.scheduleRetrieve(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates a schedule
     * @param {ScheduleUpdateRequest} scheduleUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    scheduleUpdate(scheduleUpdateRequest: ScheduleUpdateRequest, options?: any): AxiosPromise<ScheduleUpdateResponse> {
      return localVarFp.scheduleUpdate(scheduleUpdateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a workflow
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflow(id: string, options?: any): AxiosPromise<GetWorkflowResponse> {
      return localVarFp.workflow(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a new workflow
     * @param {CreateWorkflowRequest} createWorkflowRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowCreate(createWorkflowRequest: CreateWorkflowRequest, options?: any): AxiosPromise<CreateWorkflowResponse> {
      return localVarFp.workflowCreate(createWorkflowRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes a workflow
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowDelete(id: string, options?: any): AxiosPromise<DeleteWorkflowResponse> {
      return localVarFp.workflowDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a workflow
     * @param {UpdateWorkflowRequest} updateWorkflowRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowUpdate(updateWorkflowRequest: UpdateWorkflowRequest, options?: any): AxiosPromise<UpdateWorkflowResponse> {
      return localVarFp.workflowUpdate(updateWorkflowRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all or specific set of workflows
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflows(q?: string, id?: Array<string>, options?: any): AxiosPromise<Array<ListWorkflowsResponseInner>> {
      return localVarFp.workflows(q, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates new workflows
     * @param {CreateWorkflowsRequest} createWorkflowsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsCreate(createWorkflowsRequest: CreateWorkflowsRequest, options?: any): AxiosPromise<CreateWorkflowsResponse> {
      return localVarFp.workflowsCreate(createWorkflowsRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes multiple workflows
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsDelete(id?: Array<string>, options?: any): AxiosPromise<DeleteWorkflowsResponse> {
      return localVarFp.workflowsDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates multiple workflows
     * @param {UpdateWorkflowRequest} updateWorkflowRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    workflowsUpdate(updateWorkflowRequest: UpdateWorkflowRequest, options?: any): AxiosPromise<UpdateWorkflowsResponse> {
      return localVarFp.workflowsUpdate(updateWorkflowRequest, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * Scout9Api - object-oriented interface
 * @export
 * @class Scout9Api
 * @extends {BaseAPI}
 */
export class Scout9Api extends BaseAPI {
  /**
   *
   * @summary Gets a agent
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agent(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agent(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes a agent
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agentDelete(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agentDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Registers a new agent
   * @param {CreateAgentRequest} createAgentRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agentRegister(createAgentRequest: CreateAgentRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agentRegister(createAgentRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a agent
   * @param {UpdateAgentRequest} updateAgentRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agentUpdate(updateAgentRequest: UpdateAgentRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agentUpdate(updateAgentRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets all or specific set of agents
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agents(q?: string, id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agents(q, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates new agents
   * @param {CreateAgentsRequest} createAgentsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agentsCreate(createAgentsRequest: CreateAgentsRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agentsCreate(createAgentsRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes multiple agents
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agentsDelete(id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agentsDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates multiple agents
   * @param {UpdateAgentsRequest} updateAgentsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agentsUpdate(updateAgentsRequest: UpdateAgentsRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agentsUpdate(updateAgentsRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a context
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public context(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).context(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a new context
   * @param {CreateContextRequest} createContextRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contextCreate(createContextRequest: CreateContextRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contextCreate(createContextRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes a schedule
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contextDelete(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contextDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a context
   * @param {UpdateContextRequest} updateContextRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contextUpdate(updateContextRequest: UpdateContextRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contextUpdate(updateContextRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets all or specific set of contexts
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contexts(q?: string, id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contexts(q, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates new contexts
   * @param {CreateContextsRequest} createContextsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contextsCreate(createContextsRequest: CreateContextsRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contextsCreate(createContextsRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes multiple contexts
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contextsDelete(id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contextsDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates multiple contexts
   * @param {UpdateContextRequest} updateContextRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contextsUpdate(updateContextRequest: UpdateContextRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contextsUpdate(updateContextRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a conversation
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public conversation(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).conversation(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a new conversation
   * @param {ConversationCreateRequest} conversationCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public conversationCreate(conversationCreateRequest: ConversationCreateRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).conversationCreate(conversationCreateRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes a schedule
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public conversationDelete(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).conversationDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a conversation
   * @param {ConversationUpdateRequest} conversationUpdateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public conversationUpdate(conversationUpdateRequest: ConversationUpdateRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).conversationUpdate(conversationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a customer
   * @param {string} idOrEmailOrPhone id of customer or their registered phone or registered email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customer(idOrEmailOrPhone: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customer(idOrEmailOrPhone, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates a new customer
   * @param {CreateCustomerRequest} createCustomerRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerCreate(createCustomerRequest: CreateCustomerRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerCreate(createCustomerRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes a customer
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerDelete(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a customer group
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroup(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroup(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates a new customer group
   * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroupCreate(createCustomerGroupRequest: CreateCustomerGroupRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroupCreate(createCustomerGroupRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes a customer group
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroupDelete(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroupDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates a customer group
   * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroupUpdate(updateCustomerGroupRequest: UpdateCustomerGroupRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroupUpdate(updateCustomerGroupRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets all or specific set of customer groups
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroups(q?: string, id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroups(q, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates new customer groups
   * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroupsCreate(createCustomerGroupsRequest: CreateCustomerGroupsRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroupsCreate(createCustomerGroupsRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes multiple customer groups
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroupsDelete(id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroupsDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates multiple customer groups
   * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroupsUpdate(updateCustomerGroupsRequest: UpdateCustomerGroupsRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroupsUpdate(updateCustomerGroupsRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates a customer
   * @param {UpdateCustomerRequest} updateCustomerRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerUpdate(updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerUpdate(updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets all or specific set of customers
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customers(q?: string, id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customers(q, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates new customers
   * @param {CreateCustomersRequest} createCustomersRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customersCreate(createCustomersRequest: CreateCustomersRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customersCreate(createCustomersRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes multiple customers
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customersDelete(id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customersDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates multiple customers
   * @param {UpdateCustomerRequest} updateCustomerRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customersUpdate(updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customersUpdate(updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Returns information about a specific file.
   * @param {string} fileId The ID of the file to use for this request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public file(fileId: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).file(fileId, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
   * @param {File} file
   * @param {string} [purpose] The intended purpose of the uploaded documents.  This allows us to validate the format of the uploaded file.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public fileCreate(file: File | Buffer | Blob, purpose?: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).fileCreate(file, purpose, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Delete a file.
   * @param {string} fileId The ID of the file to use for this request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public fileDelete(fileId: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).fileDelete(fileId, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Returns the contents of the specified file
   * @param {string} fileId The ID of the file to use for this request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public fileDownload(fileId: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).fileDownload(fileId, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Returns a list of files that belong to the user\'s organization.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public files(options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).files(options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
   * @summary Generate a message from conversation
   * @param {GenerateRequest} generateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public generate(generateRequest: GenerateRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).generate(generateRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
   * @summary Create and send message
   * @param {MessageCreateRequest} messageCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public message(messageCreateRequest: MessageCreateRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).message(messageCreateRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all messages from a conversation
   * @param {string} id id of entity to query
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public messages(id: string, q?: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).messages(id, q, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the results of a bulk API operation
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public operation(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).operation(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets all or specific set of bulk API operations
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public operations(q?: string, id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).operations(q, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates a new scheduled conversation
   * @param {ScheduleCreateRequest} scheduleCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public scheduleConversation(scheduleCreateRequest: ScheduleCreateRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).scheduleConversation(scheduleCreateRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes a schedule
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public scheduleDelete(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).scheduleDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates a new schedule group
   * @param {ScheduleGroupCreateRequest} scheduleGroupCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public scheduleGroupCreate(scheduleGroupCreateRequest: ScheduleGroupCreateRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).scheduleGroupCreate(scheduleGroupCreateRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes and cancels a schedule group
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public scheduleGroupDelete(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).scheduleGroupDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a schedule group
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public scheduleGroupRetrieve(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).scheduleGroupRetrieve(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates a schedule group
   * @param {ScheduleGroupUpdateRequest} scheduleGroupUpdateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public scheduleGroupUpdate(scheduleGroupUpdateRequest: ScheduleGroupUpdateRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).scheduleGroupUpdate(scheduleGroupUpdateRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a schedule
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public scheduleRetrieve(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).scheduleRetrieve(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates a schedule
   * @param {ScheduleUpdateRequest} scheduleUpdateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public scheduleUpdate(scheduleUpdateRequest: ScheduleUpdateRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).scheduleUpdate(scheduleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a workflow
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public workflow(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).workflow(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a new workflow
   * @param {CreateWorkflowRequest} createWorkflowRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public workflowCreate(createWorkflowRequest: CreateWorkflowRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).workflowCreate(createWorkflowRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes a workflow
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public workflowDelete(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).workflowDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a workflow
   * @param {UpdateWorkflowRequest} updateWorkflowRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public workflowUpdate(updateWorkflowRequest: UpdateWorkflowRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).workflowUpdate(updateWorkflowRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets all or specific set of workflows
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public workflows(q?: string, id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).workflows(q, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates new workflows
   * @param {CreateWorkflowsRequest} createWorkflowsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public workflowsCreate(createWorkflowsRequest: CreateWorkflowsRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).workflowsCreate(createWorkflowsRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes multiple workflows
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public workflowsDelete(id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).workflowsDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates multiple workflows
   * @param {UpdateWorkflowRequest} updateWorkflowRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public workflowsUpdate(updateWorkflowRequest: UpdateWorkflowRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).workflowsUpdate(updateWorkflowRequest, options).then((request) => request(this.axios, this.basePath));
  }
}


