/* tslint:disable */
/* eslint-disable */
/**
 * Scout9 API
 * APIs for managing Scout9 users and conversations
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Agent
 */
export interface Agent {
    /**
     * Agent first name
     * @type {string}
     * @memberof Agent
     */
    'firstName': string;
    /**
     * Agent last name
     * @type {string}
     * @memberof Agent
     */
    'lastName': string;
    /**
     * Agent is inactive
     * @type {boolean}
     * @memberof Agent
     */
    'inactive'?: boolean;
    /**
     * Programmable phone number
     * @type {string}
     * @memberof Agent
     */
    'programmablePhoneNumber'?: string;
    /**
     * Programmable phone number SID
     * @type {string}
     * @memberof Agent
     */
    'programmablePhoneNumberSid'?: string;
    /**
     * Email address from Scout9 gmail subdomain
     * @type {string}
     * @memberof Agent
     */
    'programmableEmail'?: string;
    /**
     * Forward email
     * @type {string}
     * @memberof Agent
     */
    'forwardEmail'?: string;
    /**
     * Forward phone
     * @type {string}
     * @memberof Agent
     */
    'forwardPhone': string;
    /**
     * Title of the agent, defaults to \"Agent\"
     * @type {string}
     * @memberof Agent
     */
    'title'?: string;
    /**
     * Context of the agent, defaults to \"Agent\"
     * @type {string}
     * @memberof Agent
     */
    'context'?: string;
    /**
     * Locations ids the agent is included in
     * @type {Array<string>}
     * @memberof Agent
     */
    'includedLocations'?: Array<string>;
    /**
     * Locations id the agent is excluded from
     * @type {Array<string>}
     * @memberof Agent
     */
    'excludedLocations'?: Array<string>;
    /**
     * Transcript of the agent
     * @type {string}
     * @memberof Agent
     */
    'transcript'?: string;
}
/**
 * @type AnyValue
 * @export
 */
export type AnyValue = boolean | number | object | string;

/**
 *
 * @export
 * @interface BlockInfo
 */
export interface BlockInfo {
    /**
     *
     * @type {string}
     * @memberof BlockInfo
     */
    'message'?: string;
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof BlockInfo
     */
    'time'?: string;
}
/**
 *
 * @export
 * @interface Context
 */
export interface Context {
    /**
     * The ID of the context
     * @type {string}
     * @memberof Context
     */
    '$id': string;
    /**
     * The name of the context
     * @type {string}
     * @memberof Context
     */
    'name': string;
    /**
     * Whether or not the context is modifiable
     * @type {boolean}
     * @memberof Context
     */
    'modifiable': boolean;
    /**
     * The description of the context
     * @type {string}
     * @memberof Context
     */
    'description'?: string;
    /**
     *
     * @type {ContextDetectionParams}
     * @memberof Context
     */
    'detection'?: ContextDetectionParams;
    /**
     * The ID column of the context
     * @type {string}
     * @memberof Context
     */
    'idColumn': string;
    /**
     * The columns of the context
     * @type {Array<string>}
     * @memberof Context
     */
    'columns': Array<string>;
    /**
     * The required columns of the context
     * @type {Array<string>}
     * @memberof Context
     */
    'requiredColumns'?: Array<string>;
}
/**
 *
 * @export
 * @interface ContextDetectionDocument
 */
export interface ContextDetectionDocument {
    /**
     * The languages the entity is available in
     * @type {Array<string>}
     * @memberof ContextDetectionDocument
     */
    'languages'?: Array<string>;
    /**
     *
     * @type {string}
     * @memberof ContextDetectionDocument
     */
    'text': string;
    /**
     *
     * @type {string}
     * @memberof ContextDetectionDocument
     */
    'id': string;
}
/**
 *
 * @export
 * @interface ContextDetectionEntity
 */
export interface ContextDetectionEntity {
    /**
     * The utterance ID of the entity
     * @type {string}
     * @memberof ContextDetectionEntity
     */
    'utteranceId': string;
    /**
     * The classification of the given text
     * @type {string}
     * @memberof ContextDetectionEntity
     */
    'option': string;
    /**
     * The languages the entity is available in
     * @type {Array<string>}
     * @memberof ContextDetectionEntity
     */
    'languages'?: Array<string>;
    /**
     *
     * @type {Array<string>}
     * @memberof ContextDetectionEntity
     */
    'text': Array<string>;
}
/**
 *
 * @export
 * @interface ContextDetectionParams
 */
export interface ContextDetectionParams {
    /**
     *
     * @type {Array<ContextDetectionEntity>}
     * @memberof ContextDetectionParams
     */
    'entities': Array<ContextDetectionEntity>;
    /**
     *
     * @type {Array<ContextDetectionDocument>}
     * @memberof ContextDetectionParams
     */
    'documents': Array<ContextDetectionDocument>;
    /**
     *
     * @type {Array<ContextDetectionTest>}
     * @memberof ContextDetectionParams
     */
    'test'?: Array<ContextDetectionTest>;
}
/**
 *
 * @export
 * @interface ContextDetectionTest
 */
export interface ContextDetectionTest {
    /**
     *
     * @type {string}
     * @memberof ContextDetectionTest
     */
    'language'?: string;
    /**
     *
     * @type {string}
     * @memberof ContextDetectionTest
     */
    'text': string;
    /**
     *
     * @type {string}
     * @memberof ContextDetectionTest
     */
    'targetUtteranceId': string;
    /**
     *
     * @type {string}
     * @memberof ContextDetectionTest
     */
    'targetOption': string;
}
/**
 *
 * @export
 * @interface Conversation
 */
export interface Conversation {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof Conversation
     */
    '$customer': string;
    /**
     * Business this conversation is with
     * @type {string}
     * @memberof Conversation
     */
    '$business': string;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof Conversation
     */
    '$agent': string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof Conversation
     */
    '$thread': string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof Conversation
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof Conversation
     */
    'environment'?: string;
}
/**
 *
 * @export
 * @interface ConversationContextField
 */
export interface ConversationContextField {
    /**
     * The ID of the context
     * @type {string}
     * @memberof ConversationContextField
     */
    'id': string;
    /**
     * The time the context was created
     * @type {string}
     * @memberof ConversationContextField
     */
    'time'?: string;
    /**
     * The context of the conversation
     * @type {string}
     * @memberof ConversationContextField
     */
    'context': string;
    /**
     * The note of the conversation
     * @type {string}
     * @memberof ConversationContextField
     */
    'note'?: string;
    /**
     * The metadata of the conversation
     * @type {object}
     * @memberof ConversationContextField
     */
    'metadata'?: object;
    /**
     * The conditions of the conversation
     * @type {Array<ConversationContextGroup>}
     * @memberof ConversationContextField
     */
    'conditions'?: Array<ConversationContextGroup>;
    /**
     * The triggers of the conversation
     * @type {Array<string>}
     * @memberof ConversationContextField
     */
    'triggers'?: Array<string>;
}
/**
 *
 * @export
 * @interface ConversationContextFieldCondition
 */
export interface ConversationContextFieldCondition {
    /**
     * The key of the condition
     * @type {string}
     * @memberof ConversationContextFieldCondition
     */
    'key': string;
    /**
     * The operator of the condition
     * @type {string}
     * @memberof ConversationContextFieldCondition
     */
    'operator': string;
    /**
     * The regex of the condition
     * @type {string}
     * @memberof ConversationContextFieldCondition
     */
    'regex'?: string;
    /**
     *
     * @type {AnyValue}
     * @memberof ConversationContextFieldCondition
     */
    'value': AnyValue;
}
/**
 *
 * @export
 * @interface ConversationContextGroup
 */
export interface ConversationContextGroup {
    /**
     * The conditions of the conversation
     * @type {Array<ConversationContextFieldCondition>}
     * @memberof ConversationContextGroup
     */
    'conditions': Array<ConversationContextFieldCondition>;
}
/**
 *
 * @export
 * @interface ConversationCreateRequest
 */
export interface ConversationCreateRequest {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ConversationCreateRequest
     */
    '$customer': string;
    /**
     *
     * @type {any}
     * @memberof ConversationCreateRequest
     */
    '$business': any | null;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ConversationCreateRequest
     */
    '$agent': string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ConversationCreateRequest
     */
    '$thread': string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ConversationCreateRequest
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ConversationCreateRequest
     */
    'environment'?: string;
}
/**
 *
 * @export
 * @interface ConversationCreateRequestAllOf
 */
export interface ConversationCreateRequestAllOf {
    /**
     *
     * @type {any}
     * @memberof ConversationCreateRequestAllOf
     */
    '$business'?: any | null;
}
/**
 *
 * @export
 * @interface ConversationCreateResponse
 */
export interface ConversationCreateResponse {
    /**
     *
     * @type {boolean}
     * @memberof ConversationCreateResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof ConversationCreateResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ConversationGetResponse
 */
export interface ConversationGetResponse {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ConversationGetResponse
     */
    '$customer': string;
    /**
     * Business this conversation is with
     * @type {string}
     * @memberof ConversationGetResponse
     */
    '$business': string;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ConversationGetResponse
     */
    '$agent': string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ConversationGetResponse
     */
    '$thread': string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ConversationGetResponse
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ConversationGetResponse
     */
    'environment'?: string;
}
/**
 *
 * @export
 * @interface ConversationRemoveResponse
 */
export interface ConversationRemoveResponse {
    /**
     *
     * @type {boolean}
     * @memberof ConversationRemoveResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof ConversationRemoveResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ConversationUpdateRequest
 */
export interface ConversationUpdateRequest {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ConversationUpdateRequest
     */
    '$customer': string;
    /**
     * Business this conversation is with
     * @type {string}
     * @memberof ConversationUpdateRequest
     */
    '$business': string;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ConversationUpdateRequest
     */
    '$agent': string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ConversationUpdateRequest
     */
    '$thread': string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ConversationUpdateRequest
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ConversationUpdateRequest
     */
    'environment'?: string;
    /**
     * The ID of the conversation to update
     * @type {string}
     * @memberof ConversationUpdateRequest
     */
    'id'?: string;
}
/**
 *
 * @export
 * @interface ConversationUpdateRequestAllOf
 */
export interface ConversationUpdateRequestAllOf {
    /**
     * The ID of the conversation to update
     * @type {string}
     * @memberof ConversationUpdateRequestAllOf
     */
    'id'?: string;
}
/**
 *
 * @export
 * @interface ConversationUpdateResponse
 */
export interface ConversationUpdateResponse {
    /**
     *
     * @type {boolean}
     * @memberof ConversationUpdateResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof ConversationUpdateResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface CreateAgentRequest
 */
export interface CreateAgentRequest {
    /**
     * Agent first name
     * @type {string}
     * @memberof CreateAgentRequest
     */
    'firstName': string;
    /**
     * Agent last name
     * @type {string}
     * @memberof CreateAgentRequest
     */
    'lastName': string;
    /**
     * Agent is inactive
     * @type {boolean}
     * @memberof CreateAgentRequest
     */
    'inactive'?: boolean;
    /**
     * Programmable phone number
     * @type {string}
     * @memberof CreateAgentRequest
     */
    'programmablePhoneNumber'?: string;
    /**
     * Programmable phone number SID
     * @type {string}
     * @memberof CreateAgentRequest
     */
    'programmablePhoneNumberSid'?: string;
    /**
     * Email address from Scout9 gmail subdomain
     * @type {string}
     * @memberof CreateAgentRequest
     */
    'programmableEmail'?: string;
    /**
     * Forward email
     * @type {string}
     * @memberof CreateAgentRequest
     */
    'forwardEmail'?: string;
    /**
     * Forward phone
     * @type {string}
     * @memberof CreateAgentRequest
     */
    'forwardPhone': string;
    /**
     * Title of the agent, defaults to \"Agent\"
     * @type {string}
     * @memberof CreateAgentRequest
     */
    'title'?: string;
    /**
     * Context of the agent, defaults to \"Agent\"
     * @type {string}
     * @memberof CreateAgentRequest
     */
    'context'?: string;
    /**
     * Locations ids the agent is included in
     * @type {Array<string>}
     * @memberof CreateAgentRequest
     */
    'includedLocations'?: Array<string>;
    /**
     * Locations id the agent is excluded from
     * @type {Array<string>}
     * @memberof CreateAgentRequest
     */
    'excludedLocations'?: Array<string>;
    /**
     * Transcript of the agent
     * @type {string}
     * @memberof CreateAgentRequest
     */
    'transcript'?: string;
}
/**
 *
 * @export
 * @interface CreateAgentResponse
 */
export interface CreateAgentResponse {
    /**
     *
     * @type {boolean}
     * @memberof CreateAgentResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof CreateAgentResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface CreateAgentsRequest
 */
export interface CreateAgentsRequest {
    /**
     *
     * @type {Array<CreateAgentsRequestCustomersInner>}
     * @memberof CreateAgentsRequest
     */
    'customers'?: Array<CreateAgentsRequestCustomersInner>;
}
/**
 *
 * @export
 * @interface CreateAgentsRequestCustomersInner
 */
export interface CreateAgentsRequestCustomersInner {
    /**
     * Agent first name
     * @type {string}
     * @memberof CreateAgentsRequestCustomersInner
     */
    'firstName': string;
    /**
     * Agent last name
     * @type {string}
     * @memberof CreateAgentsRequestCustomersInner
     */
    'lastName': string;
    /**
     * Agent is inactive
     * @type {boolean}
     * @memberof CreateAgentsRequestCustomersInner
     */
    'inactive'?: boolean;
    /**
     * Programmable phone number
     * @type {string}
     * @memberof CreateAgentsRequestCustomersInner
     */
    'programmablePhoneNumber'?: string;
    /**
     * Programmable phone number SID
     * @type {string}
     * @memberof CreateAgentsRequestCustomersInner
     */
    'programmablePhoneNumberSid'?: string;
    /**
     * Email address from Scout9 gmail subdomain
     * @type {string}
     * @memberof CreateAgentsRequestCustomersInner
     */
    'programmableEmail'?: string;
    /**
     * Forward email
     * @type {string}
     * @memberof CreateAgentsRequestCustomersInner
     */
    'forwardEmail'?: string;
    /**
     * Forward phone
     * @type {string}
     * @memberof CreateAgentsRequestCustomersInner
     */
    'forwardPhone': string;
    /**
     * Title of the agent, defaults to \"Agent\"
     * @type {string}
     * @memberof CreateAgentsRequestCustomersInner
     */
    'title'?: string;
    /**
     * Context of the agent, defaults to \"Agent\"
     * @type {string}
     * @memberof CreateAgentsRequestCustomersInner
     */
    'context'?: string;
    /**
     * Locations ids the agent is included in
     * @type {Array<string>}
     * @memberof CreateAgentsRequestCustomersInner
     */
    'includedLocations'?: Array<string>;
    /**
     * Locations id the agent is excluded from
     * @type {Array<string>}
     * @memberof CreateAgentsRequestCustomersInner
     */
    'excludedLocations'?: Array<string>;
    /**
     * Transcript of the agent
     * @type {string}
     * @memberof CreateAgentsRequestCustomersInner
     */
    'transcript'?: string;
}
/**
 *
 * @export
 * @interface CreateAgentsResponse
 */
export interface CreateAgentsResponse {
    /**
     *
     * @type {boolean}
     * @memberof CreateAgentsResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof CreateAgentsResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface CreateContextRequest
 */
export interface CreateContextRequest {
    /**
     * The ID of the context
     * @type {string}
     * @memberof CreateContextRequest
     */
    '$id': string;
    /**
     * The name of the context
     * @type {string}
     * @memberof CreateContextRequest
     */
    'name': string;
    /**
     * Whether or not the context is modifiable
     * @type {boolean}
     * @memberof CreateContextRequest
     */
    'modifiable': boolean;
    /**
     * The description of the context
     * @type {string}
     * @memberof CreateContextRequest
     */
    'description'?: string;
    /**
     *
     * @type {ContextDetectionParams}
     * @memberof CreateContextRequest
     */
    'detection'?: ContextDetectionParams;
    /**
     * The ID column of the context
     * @type {string}
     * @memberof CreateContextRequest
     */
    'idColumn': string;
    /**
     * The columns of the context
     * @type {Array<string>}
     * @memberof CreateContextRequest
     */
    'columns': Array<string>;
    /**
     * The required columns of the context
     * @type {Array<string>}
     * @memberof CreateContextRequest
     */
    'requiredColumns'?: Array<string>;
}
/**
 *
 * @export
 * @interface CreateContextResponse
 */
export interface CreateContextResponse {
    /**
     *
     * @type {boolean}
     * @memberof CreateContextResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof CreateContextResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface CreateContextsRequest
 */
export interface CreateContextsRequest {
    /**
     *
     * @type {Array<CreateContextsRequestCustomersInner>}
     * @memberof CreateContextsRequest
     */
    'customers'?: Array<CreateContextsRequestCustomersInner>;
}
/**
 *
 * @export
 * @interface CreateContextsRequestCustomersInner
 */
export interface CreateContextsRequestCustomersInner {
    /**
     * The ID of the context
     * @type {string}
     * @memberof CreateContextsRequestCustomersInner
     */
    '$id': string;
    /**
     * The name of the context
     * @type {string}
     * @memberof CreateContextsRequestCustomersInner
     */
    'name': string;
    /**
     * Whether or not the context is modifiable
     * @type {boolean}
     * @memberof CreateContextsRequestCustomersInner
     */
    'modifiable': boolean;
    /**
     * The description of the context
     * @type {string}
     * @memberof CreateContextsRequestCustomersInner
     */
    'description'?: string;
    /**
     *
     * @type {ContextDetectionParams}
     * @memberof CreateContextsRequestCustomersInner
     */
    'detection'?: ContextDetectionParams;
    /**
     * The ID column of the context
     * @type {string}
     * @memberof CreateContextsRequestCustomersInner
     */
    'idColumn': string;
    /**
     * The columns of the context
     * @type {Array<string>}
     * @memberof CreateContextsRequestCustomersInner
     */
    'columns': Array<string>;
    /**
     * The required columns of the context
     * @type {Array<string>}
     * @memberof CreateContextsRequestCustomersInner
     */
    'requiredColumns'?: Array<string>;
}
/**
 *
 * @export
 * @interface CreateContextsResponse
 */
export interface CreateContextsResponse {
    /**
     *
     * @type {boolean}
     * @memberof CreateContextsResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof CreateContextsResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface CreateCustomerRequest
 */
export interface CreateCustomerRequest {
    /**
     * The customers first name
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'firstName': string;
    /**
     * The customers last name
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'lastName': string;
    /**
     * The customers full name
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'name'?: string;
    /**
     * The customers email address
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'email'?: string | null;
    /**
     * The customers phone number
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'phone'?: string | null;
    /**
     * The customers profile image
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'img'?: string | null;
    /**
     * The customers neighborhood
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'neighborhood'?: string | null;
    /**
     * The customers city
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'city'?: string | null;
    /**
     * The customers 2-letter country code
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'country'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'line1'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'line2'?: string | null;
    /**
     * The customers postal code
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'postal_code'?: string | null;
    /**
     * The customers state, county, province, or region
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'state'?: string | null;
    /**
     * The customers town (only used in Japan)
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'town'?: string | null;
    /**
     *
     * @type {BlockInfo}
     * @memberof CreateCustomerRequest
     */
    'blocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof CreateCustomerRequest
     */
    'phoneBlocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof CreateCustomerRequest
     */
    'emailBlocked'?: BlockInfo;
    /**
     * The date the customer joined the business
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'joined'?: string | null;
    /**
     * The customers stripe ID
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'stripe'?: string | null;
    /**
     * The customers stripe ID in the dev environment
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'stripeDev'?: string | null;
}
/**
 *
 * @export
 * @interface CreateCustomerResponse
 */
export interface CreateCustomerResponse {
    /**
     *
     * @type {boolean}
     * @memberof CreateCustomerResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof CreateCustomerResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface CreateCustomersRequest
 */
export interface CreateCustomersRequest {
    /**
     *
     * @type {Array<CreateCustomersRequestCustomersInner>}
     * @memberof CreateCustomersRequest
     */
    'customers'?: Array<CreateCustomersRequestCustomersInner>;
}
/**
 *
 * @export
 * @interface CreateCustomersRequestCustomersInner
 */
export interface CreateCustomersRequestCustomersInner {
    /**
     * The customers first name
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'firstName': string;
    /**
     * The customers last name
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'lastName': string;
    /**
     * The customers full name
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'name'?: string;
    /**
     * The customers email address
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'email'?: string | null;
    /**
     * The customers phone number
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'phone'?: string | null;
    /**
     * The customers profile image
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'img'?: string | null;
    /**
     * The customers neighborhood
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'neighborhood'?: string | null;
    /**
     * The customers city
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'city'?: string | null;
    /**
     * The customers 2-letter country code
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'country'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'line1'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'line2'?: string | null;
    /**
     * The customers postal code
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'postal_code'?: string | null;
    /**
     * The customers state, county, province, or region
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'state'?: string | null;
    /**
     * The customers town (only used in Japan)
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'town'?: string | null;
    /**
     *
     * @type {BlockInfo}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'blocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'phoneBlocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'emailBlocked'?: BlockInfo;
    /**
     * The date the customer joined the business
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'joined'?: string | null;
    /**
     * The customers stripe ID
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'stripe'?: string | null;
    /**
     * The customers stripe ID in the dev environment
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'stripeDev'?: string | null;
}
/**
 *
 * @export
 * @interface CreateCustomersResponse
 */
export interface CreateCustomersResponse {
    /**
     *
     * @type {boolean}
     * @memberof CreateCustomersResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof CreateCustomersResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface CreateWorkflowRequest
 */
export interface CreateWorkflowRequest {
    /**
     * The name of the workflow
     * @type {string}
     * @memberof CreateWorkflowRequest
     */
    'name': string;
    /**
     *
     * @type {ContextDetectionParams}
     * @memberof CreateWorkflowRequest
     */
    'initiators': ContextDetectionParams;
    /**
     * The fields of the workflow
     * @type {Array<ConversationContextField>}
     * @memberof CreateWorkflowRequest
     */
    'fields': Array<ConversationContextField>;
    /**
     * About this conversation - used as initial context
     * @type {string}
     * @memberof CreateWorkflowRequest
     */
    'context': string;
    /**
     * The webhook to call when a workflow is created
     * @type {string}
     * @memberof CreateWorkflowRequest
     */
    'onCreated'?: string;
    /**
     * The webhook to call when a workflow is updated
     * @type {string}
     * @memberof CreateWorkflowRequest
     */
    'onUpdated'?: string;
    /**
     * The webhook to call when a workflow is deleted
     * @type {string}
     * @memberof CreateWorkflowRequest
     */
    'onDeleted'?: string;
    /**
     * The webhook to call when a workflow has an error
     * @type {string}
     * @memberof CreateWorkflowRequest
     */
    'onError'?: string;
}
/**
 *
 * @export
 * @interface CreateWorkflowResponse
 */
export interface CreateWorkflowResponse {
    /**
     *
     * @type {boolean}
     * @memberof CreateWorkflowResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof CreateWorkflowResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface CreateWorkflowsRequest
 */
export interface CreateWorkflowsRequest {
    /**
     *
     * @type {Array<CreateWorkflowsRequestCustomersInner>}
     * @memberof CreateWorkflowsRequest
     */
    'customers'?: Array<CreateWorkflowsRequestCustomersInner>;
}
/**
 *
 * @export
 * @interface CreateWorkflowsRequestCustomersInner
 */
export interface CreateWorkflowsRequestCustomersInner {
    /**
     * The name of the workflow
     * @type {string}
     * @memberof CreateWorkflowsRequestCustomersInner
     */
    'name': string;
    /**
     *
     * @type {ContextDetectionParams}
     * @memberof CreateWorkflowsRequestCustomersInner
     */
    'initiators': ContextDetectionParams;
    /**
     * The fields of the workflow
     * @type {Array<ConversationContextField>}
     * @memberof CreateWorkflowsRequestCustomersInner
     */
    'fields': Array<ConversationContextField>;
    /**
     * About this conversation - used as initial context
     * @type {string}
     * @memberof CreateWorkflowsRequestCustomersInner
     */
    'context': string;
    /**
     * The webhook to call when a workflow is created
     * @type {string}
     * @memberof CreateWorkflowsRequestCustomersInner
     */
    'onCreated'?: string;
    /**
     * The webhook to call when a workflow is updated
     * @type {string}
     * @memberof CreateWorkflowsRequestCustomersInner
     */
    'onUpdated'?: string;
    /**
     * The webhook to call when a workflow is deleted
     * @type {string}
     * @memberof CreateWorkflowsRequestCustomersInner
     */
    'onDeleted'?: string;
    /**
     * The webhook to call when a workflow has an error
     * @type {string}
     * @memberof CreateWorkflowsRequestCustomersInner
     */
    'onError'?: string;
}
/**
 *
 * @export
 * @interface CreateWorkflowsResponse
 */
export interface CreateWorkflowsResponse {
    /**
     *
     * @type {boolean}
     * @memberof CreateWorkflowsResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof CreateWorkflowsResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * The customers first name
     * @type {string}
     * @memberof Customer
     */
    'firstName'?: string;
    /**
     * The customers last name
     * @type {string}
     * @memberof Customer
     */
    'lastName'?: string;
    /**
     * The customers full name
     * @type {string}
     * @memberof Customer
     */
    'name'?: string;
    /**
     * The customers email address
     * @type {string}
     * @memberof Customer
     */
    'email'?: string | null;
    /**
     * The customers phone number
     * @type {string}
     * @memberof Customer
     */
    'phone'?: string | null;
    /**
     * The customers profile image
     * @type {string}
     * @memberof Customer
     */
    'img'?: string | null;
    /**
     * The customers neighborhood
     * @type {string}
     * @memberof Customer
     */
    'neighborhood'?: string | null;
    /**
     * The customers city
     * @type {string}
     * @memberof Customer
     */
    'city'?: string | null;
    /**
     * The customers 2-letter country code
     * @type {string}
     * @memberof Customer
     */
    'country'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof Customer
     */
    'line1'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof Customer
     */
    'line2'?: string | null;
    /**
     * The customers postal code
     * @type {string}
     * @memberof Customer
     */
    'postal_code'?: string | null;
    /**
     * The customers state, county, province, or region
     * @type {string}
     * @memberof Customer
     */
    'state'?: string | null;
    /**
     * The customers town (only used in Japan)
     * @type {string}
     * @memberof Customer
     */
    'town'?: string | null;
    /**
     *
     * @type {BlockInfo}
     * @memberof Customer
     */
    'blocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof Customer
     */
    'phoneBlocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof Customer
     */
    'emailBlocked'?: BlockInfo;
    /**
     * The date the customer joined the business
     * @type {string}
     * @memberof Customer
     */
    'joined'?: string | null;
    /**
     * The customers stripe ID
     * @type {string}
     * @memberof Customer
     */
    'stripe'?: string | null;
    /**
     * The customers stripe ID in the dev environment
     * @type {string}
     * @memberof Customer
     */
    'stripeDev'?: string | null;
}
/**
 *
 * @export
 * @interface DeleteAgentResponse
 */
export interface DeleteAgentResponse {
    /**
     *
     * @type {boolean}
     * @memberof DeleteAgentResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof DeleteAgentResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface DeleteAgentsResponse
 */
export interface DeleteAgentsResponse {
    /**
     *
     * @type {boolean}
     * @memberof DeleteAgentsResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof DeleteAgentsResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface DeleteContextResponse
 */
export interface DeleteContextResponse {
    /**
     *
     * @type {boolean}
     * @memberof DeleteContextResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof DeleteContextResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface DeleteContextsResponse
 */
export interface DeleteContextsResponse {
    /**
     *
     * @type {boolean}
     * @memberof DeleteContextsResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof DeleteContextsResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface DeleteCustomerResponse
 */
export interface DeleteCustomerResponse {
    /**
     *
     * @type {boolean}
     * @memberof DeleteCustomerResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof DeleteCustomerResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface DeleteCustomersResponse
 */
export interface DeleteCustomersResponse {
    /**
     *
     * @type {boolean}
     * @memberof DeleteCustomersResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof DeleteCustomersResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface DeleteWorkflowResponse
 */
export interface DeleteWorkflowResponse {
    /**
     *
     * @type {boolean}
     * @memberof DeleteWorkflowResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof DeleteWorkflowResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface DeleteWorkflowsResponse
 */
export interface DeleteWorkflowsResponse {
    /**
     *
     * @type {boolean}
     * @memberof DeleteWorkflowsResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof DeleteWorkflowsResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     *
     * @type {Error}
     * @memberof ErrorResponse
     */
    'error': Error;
}
/**
 *
 * @export
 * @interface GenerateRequest
 */
export interface GenerateRequest {
    /**
     * Conversation ID to generate message from
     * @type {string}
     * @memberof GenerateRequest
     */
    'convo'?: string;
}
/**
 *
 * @export
 * @interface GenerateResponse
 */
export interface GenerateResponse {
    /**
     * The role of the message (customer, agent, or business)
     * @type {string}
     * @memberof GenerateResponse
     */
    'role'?: string;
    /**
     * The content of the message
     * @type {string}
     * @memberof GenerateResponse
     */
    'content'?: string;
    /**
     * The name of the sender
     * @type {string}
     * @memberof GenerateResponse
     */
    'name'?: string;
    /**
     * The time the message was sent
     * @type {string}
     * @memberof GenerateResponse
     */
    'time'?: string;
}
/**
 *
 * @export
 * @interface GetAgentResponse
 */
export interface GetAgentResponse {
    /**
     * Agent first name
     * @type {string}
     * @memberof GetAgentResponse
     */
    'firstName': string;
    /**
     * Agent last name
     * @type {string}
     * @memberof GetAgentResponse
     */
    'lastName': string;
    /**
     * Agent is inactive
     * @type {boolean}
     * @memberof GetAgentResponse
     */
    'inactive'?: boolean;
    /**
     * Programmable phone number
     * @type {string}
     * @memberof GetAgentResponse
     */
    'programmablePhoneNumber'?: string;
    /**
     * Programmable phone number SID
     * @type {string}
     * @memberof GetAgentResponse
     */
    'programmablePhoneNumberSid'?: string;
    /**
     * Email address from Scout9 gmail subdomain
     * @type {string}
     * @memberof GetAgentResponse
     */
    'programmableEmail'?: string;
    /**
     * Forward email
     * @type {string}
     * @memberof GetAgentResponse
     */
    'forwardEmail'?: string;
    /**
     * Forward phone
     * @type {string}
     * @memberof GetAgentResponse
     */
    'forwardPhone': string;
    /**
     * Title of the agent, defaults to \"Agent\"
     * @type {string}
     * @memberof GetAgentResponse
     */
    'title'?: string;
    /**
     * Context of the agent, defaults to \"Agent\"
     * @type {string}
     * @memberof GetAgentResponse
     */
    'context'?: string;
    /**
     * Locations ids the agent is included in
     * @type {Array<string>}
     * @memberof GetAgentResponse
     */
    'includedLocations'?: Array<string>;
    /**
     * Locations id the agent is excluded from
     * @type {Array<string>}
     * @memberof GetAgentResponse
     */
    'excludedLocations'?: Array<string>;
    /**
     * Transcript of the agent
     * @type {string}
     * @memberof GetAgentResponse
     */
    'transcript'?: string;
}
/**
 *
 * @export
 * @interface GetContextResponse
 */
export interface GetContextResponse {
    /**
     * The ID of the context
     * @type {string}
     * @memberof GetContextResponse
     */
    '$id': string;
    /**
     * The name of the context
     * @type {string}
     * @memberof GetContextResponse
     */
    'name': string;
    /**
     * Whether or not the context is modifiable
     * @type {boolean}
     * @memberof GetContextResponse
     */
    'modifiable': boolean;
    /**
     * The description of the context
     * @type {string}
     * @memberof GetContextResponse
     */
    'description'?: string;
    /**
     *
     * @type {ContextDetectionParams}
     * @memberof GetContextResponse
     */
    'detection'?: ContextDetectionParams;
    /**
     * The ID column of the context
     * @type {string}
     * @memberof GetContextResponse
     */
    'idColumn': string;
    /**
     * The columns of the context
     * @type {Array<string>}
     * @memberof GetContextResponse
     */
    'columns': Array<string>;
    /**
     * The required columns of the context
     * @type {Array<string>}
     * @memberof GetContextResponse
     */
    'requiredColumns'?: Array<string>;
}
/**
 *
 * @export
 * @interface GetCustomerResponse
 */
export interface GetCustomerResponse {
    /**
     * The customers first name
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'firstName': string;
    /**
     * The customers last name
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'lastName': string;
    /**
     * The customers full name
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'name'?: string;
    /**
     * The customers email address
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'email'?: string | null;
    /**
     * The customers phone number
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'phone'?: string | null;
    /**
     * The customers profile image
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'img'?: string | null;
    /**
     * The customers neighborhood
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'neighborhood'?: string | null;
    /**
     * The customers city
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'city'?: string | null;
    /**
     * The customers 2-letter country code
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'country'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'line1'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'line2'?: string | null;
    /**
     * The customers postal code
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'postal_code'?: string | null;
    /**
     * The customers state, county, province, or region
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'state'?: string | null;
    /**
     * The customers town (only used in Japan)
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'town'?: string | null;
    /**
     *
     * @type {BlockInfo}
     * @memberof GetCustomerResponse
     */
    'blocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof GetCustomerResponse
     */
    'phoneBlocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof GetCustomerResponse
     */
    'emailBlocked'?: BlockInfo;
    /**
     * The date the customer joined the business
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'joined'?: string | null;
    /**
     * The customers stripe ID
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'stripe'?: string | null;
    /**
     * The customers stripe ID in the dev environment
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'stripeDev'?: string | null;
}
/**
 *
 * @export
 * @interface GetWorkflowResponse
 */
export interface GetWorkflowResponse {
    /**
     * The name of the workflow
     * @type {string}
     * @memberof GetWorkflowResponse
     */
    'name': string;
    /**
     *
     * @type {ContextDetectionParams}
     * @memberof GetWorkflowResponse
     */
    'initiators': ContextDetectionParams;
    /**
     * The fields of the workflow
     * @type {Array<ConversationContextField>}
     * @memberof GetWorkflowResponse
     */
    'fields': Array<ConversationContextField>;
    /**
     * About this conversation - used as initial context
     * @type {string}
     * @memberof GetWorkflowResponse
     */
    'context': string;
    /**
     * The webhook to call when a workflow is created
     * @type {string}
     * @memberof GetWorkflowResponse
     */
    'onCreated'?: string;
    /**
     * The webhook to call when a workflow is updated
     * @type {string}
     * @memberof GetWorkflowResponse
     */
    'onUpdated'?: string;
    /**
     * The webhook to call when a workflow is deleted
     * @type {string}
     * @memberof GetWorkflowResponse
     */
    'onDeleted'?: string;
    /**
     * The webhook to call when a workflow has an error
     * @type {string}
     * @memberof GetWorkflowResponse
     */
    'onError'?: string;
}
/**
 *
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * The role of the message (customer, agent, or business)
     * @type {string}
     * @memberof Message
     */
    'role'?: string;
    /**
     * The content of the message
     * @type {string}
     * @memberof Message
     */
    'content'?: string;
    /**
     * The name of the sender
     * @type {string}
     * @memberof Message
     */
    'name'?: string;
    /**
     * The time the message was sent
     * @type {string}
     * @memberof Message
     */
    'time'?: string;
}
/**
 *
 * @export
 * @interface MessageCreateRequest
 */
export interface MessageCreateRequest {
    /**
     * Conveersation ID this belonds to
     * @type {string}
     * @memberof MessageCreateRequest
     */
    'convo'?: string;
    /**
     *
     * @type {MessageGetResponseInner}
     * @memberof MessageCreateRequest
     */
    'message'?: MessageGetResponseInner;
}
/**
 *
 * @export
 * @interface MessageCreateResponse
 */
export interface MessageCreateResponse {
    /**
     *
     * @type {boolean}
     * @memberof MessageCreateResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof MessageCreateResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface MessageGetResponseInner
 */
export interface MessageGetResponseInner {
    /**
     * The role of the message (customer, agent, or business)
     * @type {string}
     * @memberof MessageGetResponseInner
     */
    'role'?: string;
    /**
     * The content of the message
     * @type {string}
     * @memberof MessageGetResponseInner
     */
    'content'?: string;
    /**
     * The name of the sender
     * @type {string}
     * @memberof MessageGetResponseInner
     */
    'name'?: string;
    /**
     * The time the message was sent
     * @type {string}
     * @memberof MessageGetResponseInner
     */
    'time'?: string;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    'type': string;
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    'param': string | null;
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    'code': string | null;
}
/**
 *
 * @export
 * @interface OperationResponse
 */
export interface OperationResponse {
    /**
     *
     * @type {boolean}
     * @memberof OperationResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof OperationResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ScheduleCreateRequest
 */
export interface ScheduleCreateRequest {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    '$customer': string;
    /**
     *
     * @type {any}
     * @memberof ScheduleCreateRequest
     */
    '$business': any | null;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    '$agent': string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    '$thread': string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ScheduleCreateRequest
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    'environment'?: string;
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    'scheduled'?: string;
    /**
     * The initial message to send to the customer
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    'initialMessage'?: string;
    /**
     * The initial message to send to the customer in HTML
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    'initialMessageHtml'?: string | null;
    /**
     * Whether the initial message has been sent
     * @type {boolean}
     * @memberof ScheduleCreateRequest
     */
    'sent'?: boolean;
    /**
     * Group this conversation is in
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    '$group'?: string;
}
/**
 *
 * @export
 * @interface ScheduleCreateResponse
 */
export interface ScheduleCreateResponse {
    /**
     *
     * @type {boolean}
     * @memberof ScheduleCreateResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof ScheduleCreateResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ScheduleGetResponse
 */
export interface ScheduleGetResponse {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ScheduleGetResponse
     */
    '$customer': string;
    /**
     * Business this conversation is with
     * @type {string}
     * @memberof ScheduleGetResponse
     */
    '$business': string;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ScheduleGetResponse
     */
    '$agent': string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ScheduleGetResponse
     */
    '$thread': string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ScheduleGetResponse
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ScheduleGetResponse
     */
    'environment'?: string;
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof ScheduleGetResponse
     */
    'scheduled'?: string;
    /**
     * The initial message to send to the customer
     * @type {string}
     * @memberof ScheduleGetResponse
     */
    'initialMessage'?: string;
    /**
     * The initial message to send to the customer in HTML
     * @type {string}
     * @memberof ScheduleGetResponse
     */
    'initialMessageHtml'?: string | null;
    /**
     * Whether the initial message has been sent
     * @type {boolean}
     * @memberof ScheduleGetResponse
     */
    'sent'?: boolean;
    /**
     * Group this conversation is in
     * @type {string}
     * @memberof ScheduleGetResponse
     */
    '$group'?: string;
}
/**
 *
 * @export
 * @interface ScheduleGroupCreateRequest
 */
export interface ScheduleGroupCreateRequest {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ScheduleGroupCreateRequest
     */
    '$customer': string;
    /**
     *
     * @type {any}
     * @memberof ScheduleGroupCreateRequest
     */
    '$business': any | null;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ScheduleGroupCreateRequest
     */
    '$agent': string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ScheduleGroupCreateRequest
     */
    '$thread': string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ScheduleGroupCreateRequest
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ScheduleGroupCreateRequest
     */
    'environment'?: string;
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof ScheduleGroupCreateRequest
     */
    'scheduled'?: string;
    /**
     * The initial message to send to the customer
     * @type {string}
     * @memberof ScheduleGroupCreateRequest
     */
    'initialMessage'?: string;
    /**
     * The initial message to send to the customer in HTML
     * @type {string}
     * @memberof ScheduleGroupCreateRequest
     */
    'initialMessageHtml'?: string | null;
    /**
     * Whether the initial message has been sent
     * @type {boolean}
     * @memberof ScheduleGroupCreateRequest
     */
    'sent'?: boolean;
    /**
     * Group this conversation is in
     * @type {string}
     * @memberof ScheduleGroupCreateRequest
     */
    '$group'?: string;
    /**
     * The delay in miliseconds between each conversation
     * @type {number}
     * @memberof ScheduleGroupCreateRequest
     */
    'delay'?: number;
    /**
     * Customers in this group
     * @type {Array<ScheduledConversationGroupAllOfCustomers>}
     * @memberof ScheduleGroupCreateRequest
     */
    'customers'?: Array<ScheduledConversationGroupAllOfCustomers>;
}
/**
 *
 * @export
 * @interface ScheduleGroupCreateResponse
 */
export interface ScheduleGroupCreateResponse {
    /**
     *
     * @type {boolean}
     * @memberof ScheduleGroupCreateResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof ScheduleGroupCreateResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ScheduleGroupGetResponse
 */
export interface ScheduleGroupGetResponse {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ScheduleGroupGetResponse
     */
    '$customer': string;
    /**
     * Business this conversation is with
     * @type {string}
     * @memberof ScheduleGroupGetResponse
     */
    '$business': string;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ScheduleGroupGetResponse
     */
    '$agent': string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ScheduleGroupGetResponse
     */
    '$thread': string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ScheduleGroupGetResponse
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ScheduleGroupGetResponse
     */
    'environment'?: string;
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof ScheduleGroupGetResponse
     */
    'scheduled'?: string;
    /**
     * The initial message to send to the customer
     * @type {string}
     * @memberof ScheduleGroupGetResponse
     */
    'initialMessage'?: string;
    /**
     * The initial message to send to the customer in HTML
     * @type {string}
     * @memberof ScheduleGroupGetResponse
     */
    'initialMessageHtml'?: string | null;
    /**
     * Whether the initial message has been sent
     * @type {boolean}
     * @memberof ScheduleGroupGetResponse
     */
    'sent'?: boolean;
    /**
     * Group this conversation is in
     * @type {string}
     * @memberof ScheduleGroupGetResponse
     */
    '$group'?: string;
    /**
     * The delay in miliseconds between each conversation
     * @type {number}
     * @memberof ScheduleGroupGetResponse
     */
    'delay'?: number;
    /**
     * Customers in this group
     * @type {Array<ScheduledConversationGroupAllOfCustomers>}
     * @memberof ScheduleGroupGetResponse
     */
    'customers'?: Array<ScheduledConversationGroupAllOfCustomers>;
}
/**
 *
 * @export
 * @interface ScheduleGroupRemoveResponse
 */
export interface ScheduleGroupRemoveResponse {
    /**
     *
     * @type {boolean}
     * @memberof ScheduleGroupRemoveResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof ScheduleGroupRemoveResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ScheduleGroupUpdateRequest
 */
export interface ScheduleGroupUpdateRequest {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    '$customer': string;
    /**
     * Business this conversation is with
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    '$business': string;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    '$agent': string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    '$thread': string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ScheduleGroupUpdateRequest
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    'environment'?: string;
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    'scheduled'?: string;
    /**
     * The initial message to send to the customer
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    'initialMessage'?: string;
    /**
     * The initial message to send to the customer in HTML
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    'initialMessageHtml'?: string | null;
    /**
     * Whether the initial message has been sent
     * @type {boolean}
     * @memberof ScheduleGroupUpdateRequest
     */
    'sent'?: boolean;
    /**
     * Group this conversation is in
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    '$group'?: string;
    /**
     * The delay in miliseconds between each conversation
     * @type {number}
     * @memberof ScheduleGroupUpdateRequest
     */
    'delay'?: number;
    /**
     * Customers in this group
     * @type {Array<ScheduledConversationGroupAllOfCustomers>}
     * @memberof ScheduleGroupUpdateRequest
     */
    'customers'?: Array<ScheduledConversationGroupAllOfCustomers>;
    /**
     * The ID of the scheduled conversation group to update
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    'id'?: string;
}
/**
 *
 * @export
 * @interface ScheduleGroupUpdateRequestAllOf
 */
export interface ScheduleGroupUpdateRequestAllOf {
    /**
     * The ID of the scheduled conversation group to update
     * @type {string}
     * @memberof ScheduleGroupUpdateRequestAllOf
     */
    'id'?: string;
}
/**
 *
 * @export
 * @interface ScheduleGroupUpdateResponse
 */
export interface ScheduleGroupUpdateResponse {
    /**
     *
     * @type {boolean}
     * @memberof ScheduleGroupUpdateResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof ScheduleGroupUpdateResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ScheduleRemoveResponse
 */
export interface ScheduleRemoveResponse {
    /**
     *
     * @type {boolean}
     * @memberof ScheduleRemoveResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof ScheduleRemoveResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ScheduleUpdateRequest
 */
export interface ScheduleUpdateRequest {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    '$customer': string;
    /**
     * Business this conversation is with
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    '$business': string;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    '$agent': string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    '$thread': string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ScheduleUpdateRequest
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'environment'?: string;
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'scheduled'?: string;
    /**
     * The initial message to send to the customer
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'initialMessage'?: string;
    /**
     * The initial message to send to the customer in HTML
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'initialMessageHtml'?: string | null;
    /**
     * Whether the initial message has been sent
     * @type {boolean}
     * @memberof ScheduleUpdateRequest
     */
    'sent'?: boolean;
    /**
     * Group this conversation is in
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    '$group'?: string;
    /**
     * The ID of the scheduled conversation to update
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'id'?: string;
}
/**
 *
 * @export
 * @interface ScheduleUpdateRequestAllOf
 */
export interface ScheduleUpdateRequestAllOf {
    /**
     * The ID of the scheduled conversation to update
     * @type {string}
     * @memberof ScheduleUpdateRequestAllOf
     */
    'id'?: string;
}
/**
 *
 * @export
 * @interface ScheduleUpdateResponse
 */
export interface ScheduleUpdateResponse {
    /**
     *
     * @type {boolean}
     * @memberof ScheduleUpdateResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof ScheduleUpdateResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ScheduledConversation
 */
export interface ScheduledConversation {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ScheduledConversation
     */
    '$customer': string;
    /**
     * Business this conversation is with
     * @type {string}
     * @memberof ScheduledConversation
     */
    '$business': string;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ScheduledConversation
     */
    '$agent': string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ScheduledConversation
     */
    '$thread': string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ScheduledConversation
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ScheduledConversation
     */
    'environment'?: string;
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof ScheduledConversation
     */
    'scheduled'?: string;
    /**
     * The initial message to send to the customer
     * @type {string}
     * @memberof ScheduledConversation
     */
    'initialMessage'?: string;
    /**
     * The initial message to send to the customer in HTML
     * @type {string}
     * @memberof ScheduledConversation
     */
    'initialMessageHtml'?: string | null;
    /**
     * Whether the initial message has been sent
     * @type {boolean}
     * @memberof ScheduledConversation
     */
    'sent'?: boolean;
    /**
     * Group this conversation is in
     * @type {string}
     * @memberof ScheduledConversation
     */
    '$group'?: string;
}
/**
 *
 * @export
 * @interface ScheduledConversationAllOf
 */
export interface ScheduledConversationAllOf {
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof ScheduledConversationAllOf
     */
    'scheduled'?: string;
    /**
     * The initial message to send to the customer
     * @type {string}
     * @memberof ScheduledConversationAllOf
     */
    'initialMessage'?: string;
    /**
     * The initial message to send to the customer in HTML
     * @type {string}
     * @memberof ScheduledConversationAllOf
     */
    'initialMessageHtml'?: string | null;
    /**
     * Whether the initial message has been sent
     * @type {boolean}
     * @memberof ScheduledConversationAllOf
     */
    'sent'?: boolean;
    /**
     * Group this conversation is in
     * @type {string}
     * @memberof ScheduledConversationAllOf
     */
    '$group'?: string;
}
/**
 *
 * @export
 * @interface ScheduledConversationGroup
 */
export interface ScheduledConversationGroup {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ScheduledConversationGroup
     */
    '$customer': string;
    /**
     * Business this conversation is with
     * @type {string}
     * @memberof ScheduledConversationGroup
     */
    '$business': string;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ScheduledConversationGroup
     */
    '$agent': string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ScheduledConversationGroup
     */
    '$thread': string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ScheduledConversationGroup
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ScheduledConversationGroup
     */
    'environment'?: string;
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof ScheduledConversationGroup
     */
    'scheduled'?: string;
    /**
     * The initial message to send to the customer
     * @type {string}
     * @memberof ScheduledConversationGroup
     */
    'initialMessage'?: string;
    /**
     * The initial message to send to the customer in HTML
     * @type {string}
     * @memberof ScheduledConversationGroup
     */
    'initialMessageHtml'?: string | null;
    /**
     * Whether the initial message has been sent
     * @type {boolean}
     * @memberof ScheduledConversationGroup
     */
    'sent'?: boolean;
    /**
     * Group this conversation is in
     * @type {string}
     * @memberof ScheduledConversationGroup
     */
    '$group'?: string;
    /**
     * The delay in miliseconds between each conversation
     * @type {number}
     * @memberof ScheduledConversationGroup
     */
    'delay'?: number;
    /**
     * Customers in this group
     * @type {Array<ScheduledConversationGroupAllOfCustomers>}
     * @memberof ScheduledConversationGroup
     */
    'customers'?: Array<ScheduledConversationGroupAllOfCustomers>;
}
/**
 *
 * @export
 * @interface ScheduledConversationGroupAllOf
 */
export interface ScheduledConversationGroupAllOf {
    /**
     * The delay in miliseconds between each conversation
     * @type {number}
     * @memberof ScheduledConversationGroupAllOf
     */
    'delay'?: number;
    /**
     * Customers in this group
     * @type {Array<ScheduledConversationGroupAllOfCustomers>}
     * @memberof ScheduledConversationGroupAllOf
     */
    'customers'?: Array<ScheduledConversationGroupAllOfCustomers>;
}
/**
 *
 * @export
 * @interface ScheduledConversationGroupAllOfCustomers
 */
export interface ScheduledConversationGroupAllOfCustomers {
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ScheduledConversationGroupAllOfCustomers
     */
    'environment'?: string;
    /**
     * Customer ID
     * @type {string}
     * @memberof ScheduledConversationGroupAllOfCustomers
     */
    'id'?: string;
}
/**
 *
 * @export
 * @interface UpdateAgentRequest
 */
export interface UpdateAgentRequest {
    /**
     * Agent first name
     * @type {string}
     * @memberof UpdateAgentRequest
     */
    'firstName': string;
    /**
     * Agent last name
     * @type {string}
     * @memberof UpdateAgentRequest
     */
    'lastName': string;
    /**
     * Agent is inactive
     * @type {boolean}
     * @memberof UpdateAgentRequest
     */
    'inactive'?: boolean;
    /**
     * Programmable phone number
     * @type {string}
     * @memberof UpdateAgentRequest
     */
    'programmablePhoneNumber'?: string;
    /**
     * Programmable phone number SID
     * @type {string}
     * @memberof UpdateAgentRequest
     */
    'programmablePhoneNumberSid'?: string;
    /**
     * Email address from Scout9 gmail subdomain
     * @type {string}
     * @memberof UpdateAgentRequest
     */
    'programmableEmail'?: string;
    /**
     * Forward email
     * @type {string}
     * @memberof UpdateAgentRequest
     */
    'forwardEmail'?: string;
    /**
     * Forward phone
     * @type {string}
     * @memberof UpdateAgentRequest
     */
    'forwardPhone': string;
    /**
     * Title of the agent, defaults to \"Agent\"
     * @type {string}
     * @memberof UpdateAgentRequest
     */
    'title'?: string;
    /**
     * Context of the agent, defaults to \"Agent\"
     * @type {string}
     * @memberof UpdateAgentRequest
     */
    'context'?: string;
    /**
     * Locations ids the agent is included in
     * @type {Array<string>}
     * @memberof UpdateAgentRequest
     */
    'includedLocations'?: Array<string>;
    /**
     * Locations id the agent is excluded from
     * @type {Array<string>}
     * @memberof UpdateAgentRequest
     */
    'excludedLocations'?: Array<string>;
    /**
     * Transcript of the agent
     * @type {string}
     * @memberof UpdateAgentRequest
     */
    'transcript'?: string;
}
/**
 *
 * @export
 * @interface UpdateAgentResponse
 */
export interface UpdateAgentResponse {
    /**
     *
     * @type {boolean}
     * @memberof UpdateAgentResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof UpdateAgentResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface UpdateAgentsRequest
 */
export interface UpdateAgentsRequest {
    /**
     *
     * @type {Array<Agent>}
     * @memberof UpdateAgentsRequest
     */
    'customers'?: Array<Agent>;
}
/**
 *
 * @export
 * @interface UpdateAgentsResponse
 */
export interface UpdateAgentsResponse {
    /**
     *
     * @type {boolean}
     * @memberof UpdateAgentsResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof UpdateAgentsResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface UpdateContextRequest
 */
export interface UpdateContextRequest {
    /**
     * The ID of the context
     * @type {string}
     * @memberof UpdateContextRequest
     */
    '$id': string;
    /**
     * The name of the context
     * @type {string}
     * @memberof UpdateContextRequest
     */
    'name': string;
    /**
     * Whether or not the context is modifiable
     * @type {boolean}
     * @memberof UpdateContextRequest
     */
    'modifiable': boolean;
    /**
     * The description of the context
     * @type {string}
     * @memberof UpdateContextRequest
     */
    'description'?: string;
    /**
     *
     * @type {ContextDetectionParams}
     * @memberof UpdateContextRequest
     */
    'detection'?: ContextDetectionParams;
    /**
     * The ID column of the context
     * @type {string}
     * @memberof UpdateContextRequest
     */
    'idColumn': string;
    /**
     * The columns of the context
     * @type {Array<string>}
     * @memberof UpdateContextRequest
     */
    'columns': Array<string>;
    /**
     * The required columns of the context
     * @type {Array<string>}
     * @memberof UpdateContextRequest
     */
    'requiredColumns'?: Array<string>;
}
/**
 *
 * @export
 * @interface UpdateContextResponse
 */
export interface UpdateContextResponse {
    /**
     *
     * @type {boolean}
     * @memberof UpdateContextResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof UpdateContextResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface UpdateContextsRequest
 */
export interface UpdateContextsRequest {
    /**
     *
     * @type {Array<Context>}
     * @memberof UpdateContextsRequest
     */
    'customers'?: Array<Context>;
}
/**
 *
 * @export
 * @interface UpdateContextsResponse
 */
export interface UpdateContextsResponse {
    /**
     *
     * @type {boolean}
     * @memberof UpdateContextsResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof UpdateContextsResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface UpdateCustomerRequest
 */
export interface UpdateCustomerRequest {
    /**
     * The customers first name
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'firstName'?: string;
    /**
     * The customers last name
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'lastName'?: string;
    /**
     * The customers full name
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'name'?: string;
    /**
     * The customers email address
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'email'?: string | null;
    /**
     * The customers phone number
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'phone'?: string | null;
    /**
     * The customers profile image
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'img'?: string | null;
    /**
     * The customers neighborhood
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'neighborhood'?: string | null;
    /**
     * The customers city
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'city'?: string | null;
    /**
     * The customers 2-letter country code
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'country'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'line1'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'line2'?: string | null;
    /**
     * The customers postal code
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'postal_code'?: string | null;
    /**
     * The customers state, county, province, or region
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'state'?: string | null;
    /**
     * The customers town (only used in Japan)
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'town'?: string | null;
    /**
     *
     * @type {BlockInfo}
     * @memberof UpdateCustomerRequest
     */
    'blocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof UpdateCustomerRequest
     */
    'phoneBlocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof UpdateCustomerRequest
     */
    'emailBlocked'?: BlockInfo;
    /**
     * The date the customer joined the business
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'joined'?: string | null;
    /**
     * The customers stripe ID
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'stripe'?: string | null;
    /**
     * The customers stripe ID in the dev environment
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'stripeDev'?: string | null;
}
/**
 *
 * @export
 * @interface UpdateCustomerResponse
 */
export interface UpdateCustomerResponse {
    /**
     *
     * @type {boolean}
     * @memberof UpdateCustomerResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof UpdateCustomerResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface UpdateCustomersRequest
 */
export interface UpdateCustomersRequest {
    /**
     *
     * @type {Array<Customer>}
     * @memberof UpdateCustomersRequest
     */
    'customers'?: Array<Customer>;
}
/**
 *
 * @export
 * @interface UpdateCustomersResponse
 */
export interface UpdateCustomersResponse {
    /**
     *
     * @type {boolean}
     * @memberof UpdateCustomersResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof UpdateCustomersResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface UpdateWorkflowRequest
 */
export interface UpdateWorkflowRequest {
    /**
     * The name of the workflow
     * @type {string}
     * @memberof UpdateWorkflowRequest
     */
    'name': string;
    /**
     *
     * @type {ContextDetectionParams}
     * @memberof UpdateWorkflowRequest
     */
    'initiators': ContextDetectionParams;
    /**
     * The fields of the workflow
     * @type {Array<ConversationContextField>}
     * @memberof UpdateWorkflowRequest
     */
    'fields': Array<ConversationContextField>;
    /**
     * About this conversation - used as initial context
     * @type {string}
     * @memberof UpdateWorkflowRequest
     */
    'context': string;
    /**
     * The webhook to call when a workflow is created
     * @type {string}
     * @memberof UpdateWorkflowRequest
     */
    'onCreated'?: string;
    /**
     * The webhook to call when a workflow is updated
     * @type {string}
     * @memberof UpdateWorkflowRequest
     */
    'onUpdated'?: string;
    /**
     * The webhook to call when a workflow is deleted
     * @type {string}
     * @memberof UpdateWorkflowRequest
     */
    'onDeleted'?: string;
    /**
     * The webhook to call when a workflow has an error
     * @type {string}
     * @memberof UpdateWorkflowRequest
     */
    'onError'?: string;
}
/**
 *
 * @export
 * @interface UpdateWorkflowResponse
 */
export interface UpdateWorkflowResponse {
    /**
     *
     * @type {boolean}
     * @memberof UpdateWorkflowResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof UpdateWorkflowResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface UpdateWorkflowsRequest
 */
export interface UpdateWorkflowsRequest {
    /**
     *
     * @type {Array<Workflow>}
     * @memberof UpdateWorkflowsRequest
     */
    'customers'?: Array<Workflow>;
}
/**
 *
 * @export
 * @interface UpdateWorkflowsResponse
 */
export interface UpdateWorkflowsResponse {
    /**
     *
     * @type {boolean}
     * @memberof UpdateWorkflowsResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof UpdateWorkflowsResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface Workflow
 */
export interface Workflow {
    /**
     * The name of the workflow
     * @type {string}
     * @memberof Workflow
     */
    'name': string;
    /**
     *
     * @type {ContextDetectionParams}
     * @memberof Workflow
     */
    'initiators': ContextDetectionParams;
    /**
     * The fields of the workflow
     * @type {Array<ConversationContextField>}
     * @memberof Workflow
     */
    'fields': Array<ConversationContextField>;
    /**
     * About this conversation - used as initial context
     * @type {string}
     * @memberof Workflow
     */
    'context': string;
    /**
     * The webhook to call when a workflow is created
     * @type {string}
     * @memberof Workflow
     */
    'onCreated'?: string;
    /**
     * The webhook to call when a workflow is updated
     * @type {string}
     * @memberof Workflow
     */
    'onUpdated'?: string;
    /**
     * The webhook to call when a workflow is deleted
     * @type {string}
     * @memberof Workflow
     */
    'onDeleted'?: string;
    /**
     * The webhook to call when a workflow has an error
     * @type {string}
     * @memberof Workflow
     */
    'onError'?: string;
}

/**
 * Scout9Api - axios parameter creator
 * @export
 */
export const Scout9ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a new agent
         * @param {CreateAgentRequest} createAgentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgent: async (createAgentRequest: CreateAgentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAgentRequest' is not null or undefined
            assertParamExists('createAgent', 'createAgentRequest', createAgentRequest)
            const localVarPath = `/v1/agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAgentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates new agents
         * @param {CreateAgentsRequest} createAgentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgents: async (createAgentsRequest: CreateAgentsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createAgentsRequest' is not null or undefined
            assertParamExists('createAgents', 'createAgentsRequest', createAgentsRequest)
            const localVarPath = `/v1/agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createAgentsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a new context
         * @param {CreateContextRequest} createContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContext: async (createContextRequest: CreateContextRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createContextRequest' is not null or undefined
            assertParamExists('createContext', 'createContextRequest', createContextRequest)
            const localVarPath = `/v1/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createContextRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates new contexts
         * @param {CreateContextsRequest} createContextsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContexts: async (createContextsRequest: CreateContextsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createContextsRequest' is not null or undefined
            assertParamExists('createContexts', 'createContextsRequest', createContextsRequest)
            const localVarPath = `/v1/contexts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createContextsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a new conversation
         * @param {ConversationCreateRequest} conversationCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversation: async (conversationCreateRequest: ConversationCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationCreateRequest' is not null or undefined
            assertParamExists('createConversation', 'conversationCreateRequest', conversationCreateRequest)
            const localVarPath = `/v1/conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conversationCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new customer
         * @param {CreateCustomerRequest} createCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (createCustomerRequest: CreateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCustomerRequest' is not null or undefined
            assertParamExists('createCustomer', 'createCustomerRequest', createCustomerRequest)
            const localVarPath = `/v1/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates new customers
         * @param {CreateCustomersRequest} createCustomersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomers: async (createCustomersRequest: CreateCustomersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCustomersRequest' is not null or undefined
            assertParamExists('createCustomers', 'createCustomersRequest', createCustomersRequest)
            const localVarPath = `/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create and send message
         * @param {MessageCreateRequest} messageCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessage: async (messageCreateRequest: MessageCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageCreateRequest' is not null or undefined
            assertParamExists('createMessage', 'messageCreateRequest', messageCreateRequest)
            const localVarPath = `/v1/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new scheduled conversation
         * @param {ScheduleCreateRequest} scheduleCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchedule: async (scheduleCreateRequest: ScheduleCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleCreateRequest' is not null or undefined
            assertParamExists('createSchedule', 'scheduleCreateRequest', scheduleCreateRequest)
            const localVarPath = `/v1/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new schedule group
         * @param {ScheduleGroupCreateRequest} scheduleGroupCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScheduleGroup: async (scheduleGroupCreateRequest: ScheduleGroupCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleGroupCreateRequest' is not null or undefined
            assertParamExists('createScheduleGroup', 'scheduleGroupCreateRequest', scheduleGroupCreateRequest)
            const localVarPath = `/v1/scheduleGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleGroupCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a new workflow
         * @param {CreateWorkflowRequest} createWorkflowRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow: async (createWorkflowRequest: CreateWorkflowRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWorkflowRequest' is not null or undefined
            assertParamExists('createWorkflow', 'createWorkflowRequest', createWorkflowRequest)
            const localVarPath = `/v1/workflow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkflowRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates new workflows
         * @param {CreateWorkflowsRequest} createWorkflowsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflows: async (createWorkflowsRequest: CreateWorkflowsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createWorkflowsRequest' is not null or undefined
            assertParamExists('createWorkflows', 'createWorkflowsRequest', createWorkflowsRequest)
            const localVarPath = `/v1/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createWorkflowsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a agent
         * @param {string} id Agent ID to delete agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgent: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAgent', 'id', id)
            const localVarPath = `/v1/agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes multiple agents
         * @param {string} id Agent IDs to delete multiple agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgents: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAgents', 'id', id)
            const localVarPath = `/v1/agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id Context ID to delete context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContext: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteContext', 'id', id)
            const localVarPath = `/v1/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes multiple contexts
         * @param {string} id Context IDs to delete multiple context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContexts: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteContexts', 'id', id)
            const localVarPath = `/v1/contexts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id Schedule ID to delete schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversation: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteConversation', 'id', id)
            const localVarPath = `/v1/conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a customer
         * @param {string} id Customer ID to delete customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCustomer', 'id', id)
            const localVarPath = `/v1/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes multiple customers
         * @param {string} id Customer IDs to delete multiple customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomers: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCustomers', 'id', id)
            const localVarPath = `/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id Schedule ID to delete schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchedule: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSchedule', 'id', id)
            const localVarPath = `/v1/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a schedule group
         * @param {string} id Schedule group ID to delete schedule group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduleGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteScheduleGroup', 'id', id)
            const localVarPath = `/v1/scheduleGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a workflow
         * @param {string} id workflow ID to delete workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWorkflow', 'id', id)
            const localVarPath = `/v1/workflow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes multiple workflows
         * @param {string} id Workflow IDs to delete multiple workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflows: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteWorkflows', 'id', id)
            const localVarPath = `/v1/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Generate a message from conversation
         * @param {GenerateRequest} generateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate: async (generateRequest: GenerateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateRequest' is not null or undefined
            assertParamExists('generate', 'generateRequest', generateRequest)
            const localVarPath = `/v1/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a agent
         * @param {string} id Agent ID to get agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgent: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAgent', 'id', id)
            const localVarPath = `/v1/agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all or specific set of agents
         * @param {string} [id] Optional get specific agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgents: async (id?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a context
         * @param {string} id Context ID to get context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContext: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getContext', 'id', id)
            const localVarPath = `/v1/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all or specific set of contexts
         * @param {string} [id] Optional get specific contexts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContexts: async (id?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/contexts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a conversation
         * @param {string} id Conversation ID to get conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getConversation', 'id', id)
            const localVarPath = `/v1/conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a customer
         * @param {string} id Customer ID to get customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCustomer', 'id', id)
            const localVarPath = `/v1/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all or specific set of customers
         * @param {string} [id] Optional get specific customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers: async (id?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all messages from a conversation
         * @param {string} id Conversation ID to get messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMessage', 'id', id)
            const localVarPath = `/v1/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a schedule
         * @param {string} id Schedule ID to get schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedule: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSchedule', 'id', id)
            const localVarPath = `/v1/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a schedule group
         * @param {string} id Schedule group ID to get schedule group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getScheduleGroup', 'id', id)
            const localVarPath = `/v1/scheduleGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a workflow
         * @param {string} id Workflow ID to get workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkflow', 'id', id)
            const localVarPath = `/v1/workflow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all or specific set of workflows
         * @param {string} [id] Optional get specific workflows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflows: async (id?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a agent
         * @param {UpdateAgentRequest} updateAgentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgent: async (updateAgentRequest: UpdateAgentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAgentRequest' is not null or undefined
            assertParamExists('updateAgent', 'updateAgentRequest', updateAgentRequest)
            const localVarPath = `/v1/agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAgentRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates multiple agents
         * @param {UpdateAgentsRequest} updateAgentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgents: async (updateAgentsRequest: UpdateAgentsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAgentsRequest' is not null or undefined
            assertParamExists('updateAgents', 'updateAgentsRequest', updateAgentsRequest)
            const localVarPath = `/v1/agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAgentsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a context
         * @param {UpdateContextRequest} updateContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContext: async (updateContextRequest: UpdateContextRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateContextRequest' is not null or undefined
            assertParamExists('updateContext', 'updateContextRequest', updateContextRequest)
            const localVarPath = `/v1/context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateContextRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates multiple contexts
         * @param {UpdateContextRequest} updateContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContexts: async (updateContextRequest: UpdateContextRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateContextRequest' is not null or undefined
            assertParamExists('updateContexts', 'updateContextRequest', updateContextRequest)
            const localVarPath = `/v1/contexts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateContextRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a conversation
         * @param {ConversationUpdateRequest} conversationUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversation: async (conversationUpdateRequest: ConversationUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationUpdateRequest' is not null or undefined
            assertParamExists('updateConversation', 'conversationUpdateRequest', conversationUpdateRequest)
            const localVarPath = `/v1/conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conversationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates a customer
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer: async (updateCustomerRequest: UpdateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateCustomerRequest' is not null or undefined
            assertParamExists('updateCustomer', 'updateCustomerRequest', updateCustomerRequest)
            const localVarPath = `/v1/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates multiple customers
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomers: async (updateCustomerRequest: UpdateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateCustomerRequest' is not null or undefined
            assertParamExists('updateCustomers', 'updateCustomerRequest', updateCustomerRequest)
            const localVarPath = `/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates a schedule
         * @param {ScheduleUpdateRequest} scheduleUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchedule: async (scheduleUpdateRequest: ScheduleUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleUpdateRequest' is not null or undefined
            assertParamExists('updateSchedule', 'scheduleUpdateRequest', scheduleUpdateRequest)
            const localVarPath = `/v1/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates a schedule group
         * @param {ScheduleGroupUpdateRequest} scheduleGroupUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduleGroup: async (scheduleGroupUpdateRequest: ScheduleGroupUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleGroupUpdateRequest' is not null or undefined
            assertParamExists('updateScheduleGroup', 'scheduleGroupUpdateRequest', scheduleGroupUpdateRequest)
            const localVarPath = `/v1/scheduleGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleGroupUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a workflow
         * @param {UpdateWorkflowRequest} updateWorkflowRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow: async (updateWorkflowRequest: UpdateWorkflowRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateWorkflowRequest' is not null or undefined
            assertParamExists('updateWorkflow', 'updateWorkflowRequest', updateWorkflowRequest)
            const localVarPath = `/v1/workflow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWorkflowRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates multiple workflows
         * @param {UpdateWorkflowRequest} updateWorkflowRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflows: async (updateWorkflowRequest: UpdateWorkflowRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateWorkflowRequest' is not null or undefined
            assertParamExists('updateWorkflows', 'updateWorkflowRequest', updateWorkflowRequest)
            const localVarPath = `/v1/workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateWorkflowRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Scout9Api - functional programming interface
 * @export
 */
export const Scout9ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Scout9ApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Create a new agent
         * @param {CreateAgentRequest} createAgentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAgent(createAgentRequest: CreateAgentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAgentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAgent(createAgentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates new agents
         * @param {CreateAgentsRequest} createAgentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAgents(createAgentsRequest: CreateAgentsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAgentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAgents(createAgentsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create a new context
         * @param {CreateContextRequest} createContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContext(createContextRequest: CreateContextRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateContextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContext(createContextRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates new contexts
         * @param {CreateContextsRequest} createContextsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createContexts(createContextsRequest: CreateContextsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateContextsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createContexts(createContextsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create a new conversation
         * @param {ConversationCreateRequest} conversationCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversation(conversationCreateRequest: ConversationCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConversation(conversationCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a new customer
         * @param {CreateCustomerRequest} createCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(createCustomerRequest: CreateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(createCustomerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates new customers
         * @param {CreateCustomersRequest} createCustomersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomers(createCustomersRequest: CreateCustomersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomers(createCustomersRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create and send message
         * @param {MessageCreateRequest} messageCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessage(messageCreateRequest: MessageCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessage(messageCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a new scheduled conversation
         * @param {ScheduleCreateRequest} scheduleCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSchedule(scheduleCreateRequest: ScheduleCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSchedule(scheduleCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a new schedule group
         * @param {ScheduleGroupCreateRequest} scheduleGroupCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScheduleGroup(scheduleGroupCreateRequest: ScheduleGroupCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleGroupCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScheduleGroup(scheduleGroupCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create a new workflow
         * @param {CreateWorkflowRequest} createWorkflowRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflow(createWorkflowRequest: CreateWorkflowRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWorkflowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflow(createWorkflowRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates new workflows
         * @param {CreateWorkflowsRequest} createWorkflowsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createWorkflows(createWorkflowsRequest: CreateWorkflowsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateWorkflowsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createWorkflows(createWorkflowsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a agent
         * @param {string} id Agent ID to delete agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAgent(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAgentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAgent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes multiple agents
         * @param {string} id Agent IDs to delete multiple agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAgents(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteAgentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAgents(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id Context ID to delete context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContext(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteContextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContext(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes multiple contexts
         * @param {string} id Context IDs to delete multiple context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteContexts(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteContextsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteContexts(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id Schedule ID to delete schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversation(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationRemoveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConversation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a customer
         * @param {string} id Customer ID to delete customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomer(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCustomerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes multiple customers
         * @param {string} id Customer IDs to delete multiple customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomers(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCustomersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomers(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id Schedule ID to delete schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSchedule(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleRemoveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSchedule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a schedule group
         * @param {string} id Schedule group ID to delete schedule group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScheduleGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleGroupRemoveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScheduleGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a workflow
         * @param {string} id workflow ID to delete workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflow(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteWorkflowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflow(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes multiple workflows
         * @param {string} id Workflow IDs to delete multiple workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkflows(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteWorkflowsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkflows(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Generate a message from conversation
         * @param {GenerateRequest} generateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generate(generateRequest: GenerateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generate(generateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a agent
         * @param {string} id Agent ID to get agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgent(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAgentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAgent(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets all or specific set of agents
         * @param {string} [id] Optional get specific agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgents(id?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Agent>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAgents(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a context
         * @param {string} id Context ID to get context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContext(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContext(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets all or specific set of contexts
         * @param {string} [id] Optional get specific contexts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getContexts(id?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Context>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getContexts(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a conversation
         * @param {string} id Conversation ID to get conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversation(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a customer
         * @param {string} id Customer ID to get customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomer(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomerRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets all or specific set of customers
         * @param {string} [id] Optional get specific customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomers(id?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Customer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomers(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all messages from a conversation
         * @param {string} id Conversation ID to get messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessage(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageGetResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a schedule
         * @param {string} id Schedule ID to get schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchedule(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchedule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a schedule group
         * @param {string} id Schedule group ID to get schedule group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScheduleGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleGroupGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduleGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a workflow
         * @param {string} id Workflow ID to get workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflow(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetWorkflowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflow(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets all or specific set of workflows
         * @param {string} [id] Optional get specific workflows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkflows(id?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Workflow>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkflows(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update a agent
         * @param {UpdateAgentRequest} updateAgentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAgent(updateAgentRequest: UpdateAgentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAgentResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAgent(updateAgentRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates multiple agents
         * @param {UpdateAgentsRequest} updateAgentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAgents(updateAgentsRequest: UpdateAgentsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAgentsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAgents(updateAgentsRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update a context
         * @param {UpdateContextRequest} updateContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContext(updateContextRequest: UpdateContextRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateContextResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContext(updateContextRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates multiple contexts
         * @param {UpdateContextRequest} updateContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateContexts(updateContextRequest: UpdateContextRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateContextsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateContexts(updateContextRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update a conversation
         * @param {ConversationUpdateRequest} conversationUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConversation(conversationUpdateRequest: ConversationUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConversation(conversationUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates a customer
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomer(updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCustomerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomer(updateCustomerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates multiple customers
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomers(updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCustomersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomers(updateCustomerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates a schedule
         * @param {ScheduleUpdateRequest} scheduleUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSchedule(scheduleUpdateRequest: ScheduleUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSchedule(scheduleUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates a schedule group
         * @param {ScheduleGroupUpdateRequest} scheduleGroupUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScheduleGroup(scheduleGroupUpdateRequest: ScheduleGroupUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleGroupUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScheduleGroup(scheduleGroupUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update a workflow
         * @param {UpdateWorkflowRequest} updateWorkflowRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkflow(updateWorkflowRequest: UpdateWorkflowRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateWorkflowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkflow(updateWorkflowRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates multiple workflows
         * @param {UpdateWorkflowRequest} updateWorkflowRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkflows(updateWorkflowRequest: UpdateWorkflowRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateWorkflowsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkflows(updateWorkflowRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Scout9Api - factory interface
 * @export
 */
export const Scout9ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Scout9ApiFp(configuration)
    return {
        /**
         *
         * @summary Create a new agent
         * @param {CreateAgentRequest} createAgentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgent(createAgentRequest: CreateAgentRequest, options?: any): AxiosPromise<CreateAgentResponse> {
            return localVarFp.createAgent(createAgentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates new agents
         * @param {CreateAgentsRequest} createAgentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAgents(createAgentsRequest: CreateAgentsRequest, options?: any): AxiosPromise<CreateAgentsResponse> {
            return localVarFp.createAgents(createAgentsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new context
         * @param {CreateContextRequest} createContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContext(createContextRequest: CreateContextRequest, options?: any): AxiosPromise<CreateContextResponse> {
            return localVarFp.createContext(createContextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates new contexts
         * @param {CreateContextsRequest} createContextsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createContexts(createContextsRequest: CreateContextsRequest, options?: any): AxiosPromise<CreateContextsResponse> {
            return localVarFp.createContexts(createContextsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new conversation
         * @param {ConversationCreateRequest} conversationCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversation(conversationCreateRequest: ConversationCreateRequest, options?: any): AxiosPromise<ConversationCreateResponse> {
            return localVarFp.createConversation(conversationCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a new customer
         * @param {CreateCustomerRequest} createCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(createCustomerRequest: CreateCustomerRequest, options?: any): AxiosPromise<CreateCustomerResponse> {
            return localVarFp.createCustomer(createCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates new customers
         * @param {CreateCustomersRequest} createCustomersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomers(createCustomersRequest: CreateCustomersRequest, options?: any): AxiosPromise<CreateCustomersResponse> {
            return localVarFp.createCustomers(createCustomersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create and send message
         * @param {MessageCreateRequest} messageCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessage(messageCreateRequest: MessageCreateRequest, options?: any): AxiosPromise<MessageCreateResponse> {
            return localVarFp.createMessage(messageCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a new scheduled conversation
         * @param {ScheduleCreateRequest} scheduleCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchedule(scheduleCreateRequest: ScheduleCreateRequest, options?: any): AxiosPromise<ScheduleCreateResponse> {
            return localVarFp.createSchedule(scheduleCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a new schedule group
         * @param {ScheduleGroupCreateRequest} scheduleGroupCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScheduleGroup(scheduleGroupCreateRequest: ScheduleGroupCreateRequest, options?: any): AxiosPromise<ScheduleGroupCreateResponse> {
            return localVarFp.createScheduleGroup(scheduleGroupCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new workflow
         * @param {CreateWorkflowRequest} createWorkflowRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflow(createWorkflowRequest: CreateWorkflowRequest, options?: any): AxiosPromise<CreateWorkflowResponse> {
            return localVarFp.createWorkflow(createWorkflowRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates new workflows
         * @param {CreateWorkflowsRequest} createWorkflowsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createWorkflows(createWorkflowsRequest: CreateWorkflowsRequest, options?: any): AxiosPromise<CreateWorkflowsResponse> {
            return localVarFp.createWorkflows(createWorkflowsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a agent
         * @param {string} id Agent ID to delete agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgent(id: string, options?: any): AxiosPromise<DeleteAgentResponse> {
            return localVarFp.deleteAgent(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes multiple agents
         * @param {string} id Agent IDs to delete multiple agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgents(id: string, options?: any): AxiosPromise<DeleteAgentsResponse> {
            return localVarFp.deleteAgents(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id Context ID to delete context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContext(id: string, options?: any): AxiosPromise<DeleteContextResponse> {
            return localVarFp.deleteContext(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes multiple contexts
         * @param {string} id Context IDs to delete multiple context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContexts(id: string, options?: any): AxiosPromise<DeleteContextsResponse> {
            return localVarFp.deleteContexts(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id Schedule ID to delete schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversation(id: string, options?: any): AxiosPromise<ConversationRemoveResponse> {
            return localVarFp.deleteConversation(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a customer
         * @param {string} id Customer ID to delete customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(id: string, options?: any): AxiosPromise<DeleteCustomerResponse> {
            return localVarFp.deleteCustomer(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes multiple customers
         * @param {string} id Customer IDs to delete multiple customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomers(id: string, options?: any): AxiosPromise<DeleteCustomersResponse> {
            return localVarFp.deleteCustomers(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id Schedule ID to delete schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchedule(id: string, options?: any): AxiosPromise<ScheduleRemoveResponse> {
            return localVarFp.deleteSchedule(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a schedule group
         * @param {string} id Schedule group ID to delete schedule group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduleGroup(id: string, options?: any): AxiosPromise<ScheduleGroupRemoveResponse> {
            return localVarFp.deleteScheduleGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a workflow
         * @param {string} id workflow ID to delete workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflow(id: string, options?: any): AxiosPromise<DeleteWorkflowResponse> {
            return localVarFp.deleteWorkflow(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes multiple workflows
         * @param {string} id Workflow IDs to delete multiple workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkflows(id: string, options?: any): AxiosPromise<DeleteWorkflowsResponse> {
            return localVarFp.deleteWorkflows(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Generate a message from conversation
         * @param {GenerateRequest} generateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate(generateRequest: GenerateRequest, options?: any): AxiosPromise<GenerateResponse> {
            return localVarFp.generate(generateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a agent
         * @param {string} id Agent ID to get agent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgent(id: string, options?: any): AxiosPromise<GetAgentResponse> {
            return localVarFp.getAgent(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all or specific set of agents
         * @param {string} [id] Optional get specific agents
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgents(id?: string, options?: any): AxiosPromise<Array<Agent>> {
            return localVarFp.getAgents(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a context
         * @param {string} id Context ID to get context
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContext(id: string, options?: any): AxiosPromise<GetContextResponse> {
            return localVarFp.getContext(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all or specific set of contexts
         * @param {string} [id] Optional get specific contexts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContexts(id?: string, options?: any): AxiosPromise<Array<Context>> {
            return localVarFp.getContexts(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a conversation
         * @param {string} id Conversation ID to get conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation(id: string, options?: any): AxiosPromise<ConversationGetResponse> {
            return localVarFp.getConversation(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a customer
         * @param {string} id Customer ID to get customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(id: string, options?: any): AxiosPromise<CreateCustomerRequest> {
            return localVarFp.getCustomer(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all or specific set of customers
         * @param {string} [id] Optional get specific customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(id?: string, options?: any): AxiosPromise<Array<Customer>> {
            return localVarFp.getCustomers(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all messages from a conversation
         * @param {string} id Conversation ID to get messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(id: string, options?: any): AxiosPromise<Array<MessageGetResponseInner>> {
            return localVarFp.getMessage(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a schedule
         * @param {string} id Schedule ID to get schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedule(id: string, options?: any): AxiosPromise<ScheduleCreateResponse> {
            return localVarFp.getSchedule(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a schedule group
         * @param {string} id Schedule group ID to get schedule group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleGroup(id: string, options?: any): AxiosPromise<ScheduleGroupGetResponse> {
            return localVarFp.getScheduleGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a workflow
         * @param {string} id Workflow ID to get workflow
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflow(id: string, options?: any): AxiosPromise<GetWorkflowResponse> {
            return localVarFp.getWorkflow(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all or specific set of workflows
         * @param {string} [id] Optional get specific workflows
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkflows(id?: string, options?: any): AxiosPromise<Array<Workflow>> {
            return localVarFp.getWorkflows(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a agent
         * @param {UpdateAgentRequest} updateAgentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgent(updateAgentRequest: UpdateAgentRequest, options?: any): AxiosPromise<UpdateAgentResponse> {
            return localVarFp.updateAgent(updateAgentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates multiple agents
         * @param {UpdateAgentsRequest} updateAgentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgents(updateAgentsRequest: UpdateAgentsRequest, options?: any): AxiosPromise<UpdateAgentsResponse> {
            return localVarFp.updateAgents(updateAgentsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a context
         * @param {UpdateContextRequest} updateContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContext(updateContextRequest: UpdateContextRequest, options?: any): AxiosPromise<UpdateContextResponse> {
            return localVarFp.updateContext(updateContextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates multiple contexts
         * @param {UpdateContextRequest} updateContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContexts(updateContextRequest: UpdateContextRequest, options?: any): AxiosPromise<UpdateContextsResponse> {
            return localVarFp.updateContexts(updateContextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a conversation
         * @param {ConversationUpdateRequest} conversationUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversation(conversationUpdateRequest: ConversationUpdateRequest, options?: any): AxiosPromise<ConversationUpdateResponse> {
            return localVarFp.updateConversation(conversationUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a customer
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(updateCustomerRequest: UpdateCustomerRequest, options?: any): AxiosPromise<UpdateCustomerResponse> {
            return localVarFp.updateCustomer(updateCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates multiple customers
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomers(updateCustomerRequest: UpdateCustomerRequest, options?: any): AxiosPromise<UpdateCustomersResponse> {
            return localVarFp.updateCustomers(updateCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a schedule
         * @param {ScheduleUpdateRequest} scheduleUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchedule(scheduleUpdateRequest: ScheduleUpdateRequest, options?: any): AxiosPromise<ScheduleUpdateResponse> {
            return localVarFp.updateSchedule(scheduleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a schedule group
         * @param {ScheduleGroupUpdateRequest} scheduleGroupUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduleGroup(scheduleGroupUpdateRequest: ScheduleGroupUpdateRequest, options?: any): AxiosPromise<ScheduleGroupUpdateResponse> {
            return localVarFp.updateScheduleGroup(scheduleGroupUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a workflow
         * @param {UpdateWorkflowRequest} updateWorkflowRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflow(updateWorkflowRequest: UpdateWorkflowRequest, options?: any): AxiosPromise<UpdateWorkflowResponse> {
            return localVarFp.updateWorkflow(updateWorkflowRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates multiple workflows
         * @param {UpdateWorkflowRequest} updateWorkflowRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkflows(updateWorkflowRequest: UpdateWorkflowRequest, options?: any): AxiosPromise<UpdateWorkflowsResponse> {
            return localVarFp.updateWorkflows(updateWorkflowRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Scout9Api - object-oriented interface
 * @export
 * @class Scout9Api
 * @extends {BaseAPI}
 */
export class Scout9Api extends BaseAPI {
    /**
     *
     * @summary Create a new agent
     * @param {CreateAgentRequest} createAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public createAgent(createAgentRequest: CreateAgentRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).createAgent(createAgentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Creates new agents
     * @param {CreateAgentsRequest} createAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public createAgents(createAgentsRequest: CreateAgentsRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).createAgents(createAgentsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create a new context
     * @param {CreateContextRequest} createContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public createContext(createContextRequest: CreateContextRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).createContext(createContextRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Creates new contexts
     * @param {CreateContextsRequest} createContextsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public createContexts(createContextsRequest: CreateContextsRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).createContexts(createContextsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create a new conversation
     * @param {ConversationCreateRequest} conversationCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public createConversation(conversationCreateRequest: ConversationCreateRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).createConversation(conversationCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Creates a new customer
     * @param {CreateCustomerRequest} createCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public createCustomer(createCustomerRequest: CreateCustomerRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).createCustomer(createCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Creates new customers
     * @param {CreateCustomersRequest} createCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public createCustomers(createCustomersRequest: CreateCustomersRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).createCustomers(createCustomersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create and send message
     * @param {MessageCreateRequest} messageCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public createMessage(messageCreateRequest: MessageCreateRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).createMessage(messageCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Creates a new scheduled conversation
     * @param {ScheduleCreateRequest} scheduleCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public createSchedule(scheduleCreateRequest: ScheduleCreateRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).createSchedule(scheduleCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Creates a new schedule group
     * @param {ScheduleGroupCreateRequest} scheduleGroupCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public createScheduleGroup(scheduleGroupCreateRequest: ScheduleGroupCreateRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).createScheduleGroup(scheduleGroupCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create a new workflow
     * @param {CreateWorkflowRequest} createWorkflowRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public createWorkflow(createWorkflowRequest: CreateWorkflowRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).createWorkflow(createWorkflowRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Creates new workflows
     * @param {CreateWorkflowsRequest} createWorkflowsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public createWorkflows(createWorkflowsRequest: CreateWorkflowsRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).createWorkflows(createWorkflowsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Deletes a agent
     * @param {string} id Agent ID to delete agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public deleteAgent(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).deleteAgent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Deletes multiple agents
     * @param {string} id Agent IDs to delete multiple agents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public deleteAgents(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).deleteAgents(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Deletes a schedule
     * @param {string} id Context ID to delete context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public deleteContext(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).deleteContext(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Deletes multiple contexts
     * @param {string} id Context IDs to delete multiple context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public deleteContexts(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).deleteContexts(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Deletes a schedule
     * @param {string} id Schedule ID to delete schedule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public deleteConversation(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).deleteConversation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Deletes a customer
     * @param {string} id Customer ID to delete customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public deleteCustomer(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).deleteCustomer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Deletes multiple customers
     * @param {string} id Customer IDs to delete multiple customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public deleteCustomers(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).deleteCustomers(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Deletes a schedule
     * @param {string} id Schedule ID to delete schedule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public deleteSchedule(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).deleteSchedule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Deletes a schedule group
     * @param {string} id Schedule group ID to delete schedule group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public deleteScheduleGroup(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).deleteScheduleGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Deletes a workflow
     * @param {string} id workflow ID to delete workflow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public deleteWorkflow(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).deleteWorkflow(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Deletes multiple workflows
     * @param {string} id Workflow IDs to delete multiple workflow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public deleteWorkflows(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).deleteWorkflows(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Generate a message from conversation
     * @param {GenerateRequest} generateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public generate(generateRequest: GenerateRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).generate(generateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Gets a agent
     * @param {string} id Agent ID to get agent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public getAgent(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).getAgent(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Gets all or specific set of agents
     * @param {string} [id] Optional get specific agents
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public getAgents(id?: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).getAgents(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Gets a context
     * @param {string} id Context ID to get context
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public getContext(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).getContext(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Gets all or specific set of contexts
     * @param {string} [id] Optional get specific contexts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public getContexts(id?: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).getContexts(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Gets a conversation
     * @param {string} id Conversation ID to get conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public getConversation(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).getConversation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Gets a customer
     * @param {string} id Customer ID to get customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public getCustomer(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).getCustomer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Gets all or specific set of customers
     * @param {string} [id] Optional get specific customers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public getCustomers(id?: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).getCustomers(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get all messages from a conversation
     * @param {string} id Conversation ID to get messages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public getMessage(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).getMessage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Gets a schedule
     * @param {string} id Schedule ID to get schedule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public getSchedule(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).getSchedule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Gets a schedule group
     * @param {string} id Schedule group ID to get schedule group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public getScheduleGroup(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).getScheduleGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Gets a workflow
     * @param {string} id Workflow ID to get workflow
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public getWorkflow(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).getWorkflow(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Gets all or specific set of workflows
     * @param {string} [id] Optional get specific workflows
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public getWorkflows(id?: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).getWorkflows(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update a agent
     * @param {UpdateAgentRequest} updateAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public updateAgent(updateAgentRequest: UpdateAgentRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).updateAgent(updateAgentRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Updates multiple agents
     * @param {UpdateAgentsRequest} updateAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public updateAgents(updateAgentsRequest: UpdateAgentsRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).updateAgents(updateAgentsRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update a context
     * @param {UpdateContextRequest} updateContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public updateContext(updateContextRequest: UpdateContextRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).updateContext(updateContextRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Updates multiple contexts
     * @param {UpdateContextRequest} updateContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public updateContexts(updateContextRequest: UpdateContextRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).updateContexts(updateContextRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update a conversation
     * @param {ConversationUpdateRequest} conversationUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public updateConversation(conversationUpdateRequest: ConversationUpdateRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).updateConversation(conversationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Updates a customer
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public updateCustomer(updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).updateCustomer(updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Updates multiple customers
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public updateCustomers(updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).updateCustomers(updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Updates a schedule
     * @param {ScheduleUpdateRequest} scheduleUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public updateSchedule(scheduleUpdateRequest: ScheduleUpdateRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).updateSchedule(scheduleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Updates a schedule group
     * @param {ScheduleGroupUpdateRequest} scheduleGroupUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public updateScheduleGroup(scheduleGroupUpdateRequest: ScheduleGroupUpdateRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).updateScheduleGroup(scheduleGroupUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update a workflow
     * @param {UpdateWorkflowRequest} updateWorkflowRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public updateWorkflow(updateWorkflowRequest: UpdateWorkflowRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).updateWorkflow(updateWorkflowRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Updates multiple workflows
     * @param {UpdateWorkflowRequest} updateWorkflowRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public updateWorkflows(updateWorkflowRequest: UpdateWorkflowRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).updateWorkflows(updateWorkflowRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


