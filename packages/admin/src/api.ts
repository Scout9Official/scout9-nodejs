/* tslint:disable */
/* eslint-disable */
/**
 * Scout9 API
 * Scout9 APIs for managing Scout9 users and conversations with your Scout9 agents
 *
 * The version of the OpenAPI document: 1.0.0-alpha.0.0.9
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Agent
 */
export interface Agent {
  /**
   * Agent first name
   * @type {string}
   * @memberof Agent
   */
  'firstName'?: string;
  /**
   * Agent last name
   * @type {string}
   * @memberof Agent
   */
  'lastName'?: string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof Agent
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof Agent
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof Agent
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof Agent
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof Agent
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof Agent
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof Agent
   */
  'title'?: string;
  /**
   *
   * @type {AgentContext}
   * @memberof Agent
   */
  'context'?: AgentContext;
}
/**
 * @type AgentContext
 * Context of the agent, defaults to \"Agent\"
 * @export
 */
export type AgentContext = Array<string> | string;

/**
 *
 * @export
 * @interface AgentDeleteResponse
 */
export interface AgentDeleteResponse {
  /**
   *
   * @type {boolean}
   * @memberof AgentDeleteResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof AgentDeleteResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof AgentDeleteResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface AgentFileManifest
 */
export interface AgentFileManifest {
  /**
   *
   * @type {AgentFileManifestImg}
   * @memberof AgentFileManifest
   */
  'img'?: AgentFileManifestImg;
  /**
   * Sample audio files that help build out your agent to mimic your voice
   * @type {Array<AgentFileManifestAudiosInner>}
   * @memberof AgentFileManifest
   */
  'audios'?: Array<AgentFileManifestAudiosInner>;
  /**
   * Sample conversations that help build out your agent to mimic your responses
   * @type {Array<AgentFileManifestTranscriptsInner>}
   * @memberof AgentFileManifest
   */
  'transcripts'?: Array<AgentFileManifestTranscriptsInner>;
}
/**
 * @type AgentFileManifestAudiosInner
 * @export
 */
export type AgentFileManifestAudiosInner = File | string;

/**
 * @type AgentFileManifestImg
 * @export
 */
export type AgentFileManifestImg = File | string;

/**
 * @type AgentFileManifestTranscriptsInner
 * @export
 */
export type AgentFileManifestTranscriptsInner = File | string;

/**
 *
 * @export
 * @interface AgentFiles
 */
export interface AgentFiles {
  /**
   * Profile image file id of the agent
   * @type {string}
   * @memberof AgentFiles
   */
  'img'?: string;
  /**
   * Transcript file ids of the agent
   * @type {Array<string>}
   * @memberof AgentFiles
   */
  'transcripts'?: Array<string>;
  /**
   * Audio file ids of the agent
   * @type {Array<string>}
   * @memberof AgentFiles
   */
  'audios'?: Array<string>;
}
/**
 *
 * @export
 * @interface AgentWithFiles
 */
export interface AgentWithFiles {
  /**
   * Transcript file ids of the agent
   * @type {Array<string>}
   * @memberof AgentWithFiles
   */
  'transcripts'?: Array<string>;
  /**
   * Audio file ids of the agent
   * @type {Array<string>}
   * @memberof AgentWithFiles
   */
  'audios'?: Array<string>;
}
/**
 *
 * @export
 * @interface AgentsDeleteResponse
 */
export interface AgentsDeleteResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof AgentsDeleteResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof AgentsDeleteResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface AndLogic
 */
export interface AndLogic {
  /**
   *
   * @type {Array<Logic>}
   * @memberof AndLogic
   */
  'and': Array<Logic>;
}
/**
 * @type AnyValue
 * @export
 */
export type AnyValue = boolean | number | object | string;

/**
 *
 * @export
 * @interface ApiOperation
 */
export interface ApiOperation {
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ApiOperation
   */
  'time': string;
  /**
   * The model that was created, updated, or deleted
   * @type {string}
   * @memberof ApiOperation
   */
  'model': string;
  /**
   * The method that was called
   * @type {string}
   * @memberof ApiOperation
   */
  'method': ApiOperationMethodEnum;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof ApiOperation
   */
  'results': { [key: string]: any; };
}

export const ApiOperationMethodEnum = {
  Get: 'get',
  Post: 'post',
  Put: 'put',
  Delete: 'delete',
  Patch: 'patch'
} as const;

export type ApiOperationMethodEnum = typeof ApiOperationMethodEnum[keyof typeof ApiOperationMethodEnum];

/**
 *
 * @export
 * @interface BlockInfo
 */
export interface BlockInfo {
  /**
   *
   * @type {string}
   * @memberof BlockInfo
   */
  'message'?: string;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof BlockInfo
   */
  'time'?: string;
}
/**
 * @type Condition
 * @export
 */
export type Condition = EqualityCondition | ExistsCondition | RegexCondition;

/**
 *
 * @export
 * @interface ConditionBase
 */
export interface ConditionBase {
  /**
   *
   * @type {string}
   * @memberof ConditionBase
   */
  'path': string;
  /**
   *
   * @type {Operator}
   * @memberof ConditionBase
   */
  'operator': Operator;
  /**
   *
   * @type {any}
   * @memberof ConditionBase
   */
  'value'?: any;
  /**
   *
   * @type {boolean}
   * @memberof ConditionBase
   */
  'external'?: boolean;
}
/**
 *
 * @export
 * @interface ConditionLogic
 */
export interface ConditionLogic {
  /**
   *
   * @type {Condition}
   * @memberof ConditionLogic
   */
  'condition': Condition;
}
/**
 *
 * @export
 * @interface Config200Response
 */
export interface Config200Response {
  /**
   *
   * @type {LlmConfig}
   * @memberof Config200Response
   */
  'llm': LlmConfig;
  /**
   *
   * @type {PmtConfig}
   * @memberof Config200Response
   */
  'pmt': PmtConfig;
  /**
   *
   * @type {Array<EntitiesBuildConfigInner>}
   * @memberof Config200Response
   */
  'entities': Array<EntitiesBuildConfigInner>;
}
/**
 *
 * @export
 * @interface Config200ResponseAllOf
 */
export interface Config200ResponseAllOf {
  /**
   *
   * @type {Array<EntitiesBuildConfigInner>}
   * @memberof Config200ResponseAllOf
   */
  'entities': Array<EntitiesBuildConfigInner>;
}
/**
 *
 * @export
 * @interface Context
 */
export interface Context {
  /**
   * The id of the context
   * @type {string}
   * @memberof Context
   */
  'entity': string;
  /**
   * The description of the context
   * @type {string}
   * @memberof Context
   */
  'description'?: string;
  /**
   *
   * @type {Array<ContextDefinitionsInner>}
   * @memberof Context
   */
  'definitions': Array<ContextDefinitionsInner>;
  /**
   *
   * @type {Array<ContextTrainingInner>}
   * @memberof Context
   */
  'training': Array<ContextTrainingInner>;
  /**
   *
   * @type {Array<string>}
   * @memberof Context
   */
  'entities'?: Array<string>;
}
/**
 *
 * @export
 * @interface ContextDefinitionsInner
 */
export interface ContextDefinitionsInner {
  /**
   * Utterance category assignment for this definition (if none provided, defaults to entity value)
   * @type {string}
   * @memberof ContextDefinitionsInner
   */
  'utterance'?: string;
  /**
   * Unique value assigned to this utterance category
   * @type {string}
   * @memberof ContextDefinitionsInner
   */
  'value': string;
  /**
   *
   * @type {Array<string>}
   * @memberof ContextDefinitionsInner
   */
  'text': Array<string>;
}
/**
 *
 * @export
 * @interface ContextDetectionDocument
 */
export interface ContextDetectionDocument {
  /**
   * The languages the entity is available in
   * @type {string}
   * @memberof ContextDetectionDocument
   */
  'language'?: string;
  /**
   *
   * @type {string}
   * @memberof ContextDetectionDocument
   */
  'text': string;
  /**
   *
   * @type {string}
   * @memberof ContextDetectionDocument
   */
  'intent'?: string;
}
/**
 *
 * @export
 * @interface ContextDetectionEntity
 */
export interface ContextDetectionEntity {
  /**
   * The utterance ID of the entity, if this is not provided then it will default to the context model id. If this is provided, the utterance of this entity wont be able to point to a context data record within the associated data table.
   * @type {string}
   * @memberof ContextDetectionEntity
   */
  'utteranceId'?: string;
  /**
   * The classification of the given text
   * @type {string}
   * @memberof ContextDetectionEntity
   */
  'option': string;
  /**
   * The languages the entity is available in
   * @type {Array<string>}
   * @memberof ContextDetectionEntity
   */
  'languages'?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ContextDetectionEntity
   */
  'text': Array<string>;
}
/**
 *
 * @export
 * @interface ContextDetectionTest
 */
export interface ContextDetectionTest {
  /**
   *
   * @type {string}
   * @memberof ContextDetectionTest
   */
  'language'?: string;
  /**
   *
   * @type {string}
   * @memberof ContextDetectionTest
   */
  'text': string;
  /**
   *
   * @type {ContextDetectionTestExpected}
   * @memberof ContextDetectionTest
   */
  'expected': ContextDetectionTestExpected;
}
/**
 * The expected result of the test
 * @export
 * @interface ContextDetectionTestExpected
 */
export interface ContextDetectionTestExpected {
  /**
   *
   * @type {string}
   * @memberof ContextDetectionTestExpected
   */
  'intent': string;
  /**
   *
   * @type {Array<ParsedContextEntity>}
   * @memberof ContextDetectionTestExpected
   */
  'entities': Array<ParsedContextEntity>;
}
/**
 *
 * @export
 * @interface ContextTrainingInner
 */
export interface ContextTrainingInner {
  /**
   * The assigned intent associated with the training text
   * @type {string}
   * @memberof ContextTrainingInner
   */
  'intent': string;
  /**
   * The parameterized text to train definition values on
   * @type {string}
   * @memberof ContextTrainingInner
   */
  'text': string;
}
/**
 *
 * @export
 * @interface Conversation
 */
export interface Conversation {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof Conversation
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof Conversation
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof Conversation
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * User for this conversation
   * @type {string}
   * @memberof Conversation
   */
  '$user': string;
  /**
   * Customer this conversation is with (use $user instead)
   * @type {string}
   * @memberof Conversation
   * @deprecated
   */
  '$customer'?: string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof Conversation
   */
  'environment': ConversationEnvironment;
  /**
   * Whether this conversation is a test or not
   * @type {boolean}
   * @memberof Conversation
   */
  'test'?: boolean;
}


/**
 *
 * @export
 * @interface ConversationAllOf
 */
export interface ConversationAllOf {
  /**
   * User for this conversation
   * @type {string}
   * @memberof ConversationAllOf
   */
  '$user': string;
  /**
   * Customer this conversation is with (use $user instead)
   * @type {string}
   * @memberof ConversationAllOf
   * @deprecated
   */
  '$customer'?: string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ConversationAllOf
   */
  'environment': ConversationEnvironment;
  /**
   * Whether this conversation is a test or not
   * @type {boolean}
   * @memberof ConversationAllOf
   */
  'test'?: boolean;
}


/**
 * Base props all conversation types will have
 * @export
 * @interface ConversationBase
 */
export interface ConversationBase {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ConversationBase
   */
  '$agent'?: string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ConversationBase
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ConversationBase
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
}
/**
 * Environment properties for the conversation
 * @export
 * @interface ConversationBaseEnvironmentProps
 */
export interface ConversationBaseEnvironmentProps {
  /**
   * HTML subject line
   * @type {string}
   * @memberof ConversationBaseEnvironmentProps
   */
  'subject'?: string;
  /**
   * Used to sync email messages with the conversation
   * @type {string}
   * @memberof ConversationBaseEnvironmentProps
   */
  'platformEmailThreadId'?: string;
}
/**
 *
 * @export
 * @interface ConversationContextField
 */
export interface ConversationContextField {
  /**
   * The ID of the context
   * @type {string}
   * @memberof ConversationContextField
   */
  'id': string;
  /**
   * The time the context was created
   * @type {string}
   * @memberof ConversationContextField
   */
  'time'?: string;
  /**
   * The context of the conversation
   * @type {string}
   * @memberof ConversationContextField
   */
  'context': string;
  /**
   * The note of the conversation
   * @type {string}
   * @memberof ConversationContextField
   */
  'note'?: string;
  /**
   * The metadata of the conversation
   * @type {object}
   * @memberof ConversationContextField
   */
  'metadata'?: object;
  /**
   *
   * @type {Logic}
   * @memberof ConversationContextField
   */
  'logic'?: Logic;
  /**
   * The conditions of the conversation
   * @type {Array<ConversationContextGroup>}
   * @memberof ConversationContextField
   * @deprecated
   */
  'conditions'?: Array<ConversationContextGroup>;
  /**
   * The triggers of the conversation
   * @type {Array<string>}
   * @memberof ConversationContextField
   */
  'triggers'?: Array<string>;
}
/**
 *
 * @export
 * @interface ConversationContextFieldCondition
 */
export interface ConversationContextFieldCondition {
  /**
   * The key of the condition
   * @type {string}
   * @memberof ConversationContextFieldCondition
   */
  'key': string;
  /**
   * The operator of the condition or query
   * @type {string}
   * @memberof ConversationContextFieldCondition
   */
  'operator': ConversationContextFieldConditionOperatorEnum;
  /**
   * The regex of the condition
   * @type {string}
   * @memberof ConversationContextFieldCondition
   */
  'regex'?: string;
  /**
   *
   * @type {AnyValue}
   * @memberof ConversationContextFieldCondition
   */
  'value': AnyValue;
}

export const ConversationContextFieldConditionOperatorEnum = {
  Eq: 'eq',
  Equal: 'equal',
  Ne: 'ne',
  NotEquals: 'not-equals',
  Gt: 'gt',
  GreaterThan: 'greater-than',
  Gte: 'gte',
  GreaterThanEquals: 'greater-than-equals',
  Lt: 'lt',
  LessThan: 'less-than',
  Lte: 'lte',
  LessThanEquals: 'less-than-equals',
  ArrayContains: 'array-contains',
  In: 'in',
  ArrayContainsAny: 'array-contains-any',
  NotIn: 'not-in',
  Exists: 'exists',
  NotExists: 'notExists',
  Contains: 'contains',
  NotContains: 'notContains',
  StartsWith: 'startsWith',
  EndsWith: 'endsWith'
} as const;

export type ConversationContextFieldConditionOperatorEnum = typeof ConversationContextFieldConditionOperatorEnum[keyof typeof ConversationContextFieldConditionOperatorEnum];

/**
 *
 * @export
 * @interface ConversationContextGroup
 */
export interface ConversationContextGroup {
  /**
   * The conditions of the conversation
   * @type {Array<ConversationContextFieldCondition>}
   * @memberof ConversationContextGroup
   */
  'conditions': Array<ConversationContextFieldCondition>;
}
/**
 *
 * @export
 * @interface ConversationContextUpdateRequest
 */
export interface ConversationContextUpdateRequest {
  /**
   * The conversation id
   * @type {string}
   * @memberof ConversationContextUpdateRequest
   */
  'convo': string;
  /**
   *
   * @type {{ [key: string]: ConversationContextValue; }}
   * @memberof ConversationContextUpdateRequest
   */
  'context': { [key: string]: ConversationContextValue; };
}
/**
 * @type ConversationContextValue
 * @export
 */
export type ConversationContextValue = Array<ConversationContextValueOneOfInner> | boolean | number | string;

/**
 * @type ConversationContextValueOneOfInner
 * @export
 */
export type ConversationContextValueOneOfInner = boolean | number | string;

/**
 *
 * @export
 * @interface ConversationCreateRequest
 */
export interface ConversationCreateRequest {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ConversationCreateRequest
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ConversationCreateRequest
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ConversationCreateRequest
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * User for this conversation
   * @type {string}
   * @memberof ConversationCreateRequest
   */
  '$user': string;
  /**
   * Customer this conversation is with (use $user instead)
   * @type {string}
   * @memberof ConversationCreateRequest
   * @deprecated
   */
  '$customer'?: string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ConversationCreateRequest
   */
  'environment': ConversationEnvironment;
  /**
   * Whether this conversation is a test or not
   * @type {boolean}
   * @memberof ConversationCreateRequest
   */
  'test'?: boolean;
  /**
   * Appends a prefix to the conversation id, if a conversation id is prefixed with test, or dev, it will mute text messages
   * @type {string}
   * @memberof ConversationCreateRequest
   */
  'idPrefix'?: string;
}


/**
 *
 * @export
 * @interface ConversationCreateRequestAllOf
 */
export interface ConversationCreateRequestAllOf {
  /**
   * Appends a prefix to the conversation id, if a conversation id is prefixed with test, or dev, it will mute text messages
   * @type {string}
   * @memberof ConversationCreateRequestAllOf
   */
  'idPrefix'?: string;
}
/**
 *
 * @export
 * @interface ConversationCreateResponse
 */
export interface ConversationCreateResponse {
  /**
   *
   * @type {boolean}
   * @memberof ConversationCreateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ConversationCreateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ConversationCreateResponse
   */
  'id': string;
  /**
   * The client web url of the conversation
   * @type {string}
   * @memberof ConversationCreateResponse
   */
  'clientWebUrl'?: string;
  /**
   * The agent web url of the conversation (requires phone two-factor authentication)
   * @type {string}
   * @memberof ConversationCreateResponse
   */
  'agentWebUrl'?: string;
  /**
   * The agent test web url of the conversation, used for testing the conversation without notifying the customer
   * @type {string}
   * @memberof ConversationCreateResponse
   */
  'agentTestWebUrl'?: string;
  /**
   * ISO 8601 date string of when the conversation was initiated
   * @type {string}
   * @memberof ConversationCreateResponse
   */
  'initiated': string;
}
/**
 *
 * @export
 * @interface ConversationCreateResponseAllOf
 */
export interface ConversationCreateResponseAllOf {
  /**
   * ISO 8601 date string of when the conversation was initiated
   * @type {string}
   * @memberof ConversationCreateResponseAllOf
   */
  'initiated': string;
}
/**
 * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
 * @export
 * @enum {string}
 */

export const ConversationEnvironment = {
  Phone: 'phone',
  Web: 'web',
  Email: 'email'
} as const;

export type ConversationEnvironment = typeof ConversationEnvironment[keyof typeof ConversationEnvironment];


/**
 *
 * @export
 * @interface ConversationGetResponse
 */
export interface ConversationGetResponse {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ConversationGetResponse
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ConversationGetResponse
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ConversationGetResponse
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * User for this conversation
   * @type {string}
   * @memberof ConversationGetResponse
   */
  '$user': string;
  /**
   * Customer this conversation is with (use $user instead)
   * @type {string}
   * @memberof ConversationGetResponse
   * @deprecated
   */
  '$customer'?: string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ConversationGetResponse
   */
  'environment': ConversationEnvironment;
  /**
   * Whether this conversation is a test or not
   * @type {boolean}
   * @memberof ConversationGetResponse
   */
  'test'?: boolean;
  /**
   * The client web url of the conversation
   * @type {string}
   * @memberof ConversationGetResponse
   */
  'clientWebUrl'?: string;
  /**
   * The agent web url of the conversation (requires phone two-factor authentication)
   * @type {string}
   * @memberof ConversationGetResponse
   */
  'agentWebUrl'?: string;
  /**
   * The agent test web url of the conversation, used for testing the conversation without notifying the customer
   * @type {string}
   * @memberof ConversationGetResponse
   */
  'agentTestWebUrl'?: string;
  /**
   * ISO 8601 date string of when the conversation was initiated
   * @type {string}
   * @memberof ConversationGetResponse
   */
  'initiated': string;
  /**
   * The ID of the conversation
   * @type {string}
   * @memberof ConversationGetResponse
   */
  '$id': string;
}


/**
 *
 * @export
 * @interface ConversationGetResponseAllOf
 */
export interface ConversationGetResponseAllOf {
  /**
   * ISO 8601 date string of when the conversation was initiated
   * @type {string}
   * @memberof ConversationGetResponseAllOf
   */
  'initiated': string;
  /**
   * The ID of the conversation
   * @type {string}
   * @memberof ConversationGetResponseAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ConversationRemoveResponse
 */
export interface ConversationRemoveResponse {
  /**
   *
   * @type {boolean}
   * @memberof ConversationRemoveResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ConversationRemoveResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ConversationRemoveResponse
   */
  'id': string;
}
/**
 * Base properties for all scheduled conversation types
 * @export
 * @interface ConversationScheduleParams
 */
export interface ConversationScheduleParams {
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ConversationScheduleParams
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ConversationScheduleParams
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ConversationScheduleParams
   */
  'initialMessageHtml'?: string | null;
}
/**
 *
 * @export
 * @interface ConversationUpdateRequest
 */
export interface ConversationUpdateRequest {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ConversationUpdateRequest
   */
  '$agent'?: string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ConversationUpdateRequest
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ConversationUpdateRequest
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * The ID of the conversation to update
   * @type {string}
   * @memberof ConversationUpdateRequest
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ConversationUpdateRequestAllOf
 */
export interface ConversationUpdateRequestAllOf {
  /**
   * The ID of the conversation to update
   * @type {string}
   * @memberof ConversationUpdateRequestAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ConversationUpdateResponse
 */
export interface ConversationUpdateResponse {
  /**
   *
   * @type {boolean}
   * @memberof ConversationUpdateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ConversationUpdateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ConversationUpdateResponse
   */
  'id': string;
}
/**
 * Conversation web urls
 * @export
 * @interface ConversationUrls
 */
export interface ConversationUrls {
  /**
   * The client web url of the conversation
   * @type {string}
   * @memberof ConversationUrls
   */
  'clientWebUrl'?: string;
  /**
   * The agent web url of the conversation (requires phone two-factor authentication)
   * @type {string}
   * @memberof ConversationUrls
   */
  'agentWebUrl'?: string;
  /**
   * The agent test web url of the conversation, used for testing the conversation without notifying the customer
   * @type {string}
   * @memberof ConversationUrls
   */
  'agentTestWebUrl'?: string;
}
/**
 *
 * @export
 * @interface ConversationWithId
 */
export interface ConversationWithId {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ConversationWithId
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ConversationWithId
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ConversationWithId
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * User for this conversation
   * @type {string}
   * @memberof ConversationWithId
   */
  '$user': string;
  /**
   * Customer this conversation is with (use $user instead)
   * @type {string}
   * @memberof ConversationWithId
   * @deprecated
   */
  '$customer'?: string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ConversationWithId
   */
  'environment': ConversationEnvironment;
  /**
   * Whether this conversation is a test or not
   * @type {boolean}
   * @memberof ConversationWithId
   */
  'test'?: boolean;
  /**
   * The ID of the conversation
   * @type {string}
   * @memberof ConversationWithId
   */
  '$id': string;
}


/**
 *
 * @export
 * @interface ConversationWithIdAllOf
 */
export interface ConversationWithIdAllOf {
  /**
   * The ID of the conversation
   * @type {string}
   * @memberof ConversationWithIdAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface CreateAgentRequest
 */
export interface CreateAgentRequest {
  /**
   * Agent first name
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'firstName'?: string;
  /**
   * Agent last name
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'lastName'?: string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof CreateAgentRequest
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'title'?: string;
  /**
   *
   * @type {AgentContext}
   * @memberof CreateAgentRequest
   */
  'context'?: AgentContext;
}
/**
 *
 * @export
 * @interface CreateAgentResponse
 */
export interface CreateAgentResponse {
  /**
   *
   * @type {boolean}
   * @memberof CreateAgentResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof CreateAgentResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof CreateAgentResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface CreateAgentsRequest
 */
export interface CreateAgentsRequest {
  /**
   *
   * @type {Array<CreateAgentsRequestAgentsInner>}
   * @memberof CreateAgentsRequest
   */
  'agents'?: Array<CreateAgentsRequestAgentsInner>;
}
/**
 *
 * @export
 * @interface CreateAgentsRequestAgentsInner
 */
export interface CreateAgentsRequestAgentsInner {
  /**
   * Agent first name
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'firstName': string;
  /**
   * Agent last name
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'lastName': string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'title'?: string;
  /**
   *
   * @type {AgentContext}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'context'?: AgentContext;
}
/**
 *
 * @export
 * @interface CreateAgentsResponse
 */
export interface CreateAgentsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof CreateAgentsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof CreateAgentsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface CreateCustomerGroupRequest
 */
export interface CreateCustomerGroupRequest {
  /**
   * The name of the customer group
   * @type {string}
   * @memberof CreateCustomerGroupRequest
   */
  'name': string;
  /**
   * The description of the customer group
   * @type {string}
   * @memberof CreateCustomerGroupRequest
   */
  'description'?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof CreateCustomerGroupRequest
   */
  'metadata'?: { [key: string]: any; };
  /**
   *
   * @type {Array<CustomerGroupRecord>}
   * @memberof CreateCustomerGroupRequest
   */
  'customers': Array<CustomerGroupRecord>;
}
/**
 *
 * @export
 * @interface CreateCustomerGroupResponse
 */
export interface CreateCustomerGroupResponse {
  /**
   *
   * @type {boolean}
   * @memberof CreateCustomerGroupResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof CreateCustomerGroupResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof CreateCustomerGroupResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface CreateCustomerGroupsRequest
 */
export interface CreateCustomerGroupsRequest {
  /**
   *
   * @type {Array<CustomerGroup>}
   * @memberof CreateCustomerGroupsRequest
   */
  'CustomerGroups': Array<CustomerGroup>;
}
/**
 *
 * @export
 * @interface CreateCustomerGroupsResponse
 */
export interface CreateCustomerGroupsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof CreateCustomerGroupsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof CreateCustomerGroupsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface CreateCustomersRequest
 */
export interface CreateCustomersRequest {
  /**
   *
   * @type {Array<Customer>}
   * @memberof CreateCustomersRequest
   */
  'customers': Array<Customer>;
}
/**
 *
 * @export
 * @interface CreateCustomersResponse
 */
export interface CreateCustomersResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof CreateCustomersResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof CreateCustomersResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface CreateFileRequestWithStringPurpose
 */
export interface CreateFileRequestWithStringPurpose {
  /**
   *
   * @type {File}
   * @memberof CreateFileRequestWithStringPurpose
   */
  'file': File;
  /**
   *
   * @type {string}
   * @memberof CreateFileRequestWithStringPurpose
   */
  'purpose': string;
  /**
   *
   * @type {string}
   * @memberof CreateFileRequestWithStringPurpose
   */
  'entity': string;
}
/**
 * Represents a customer for your business or organization
 * @export
 * @interface Customer
 */
export interface Customer {
  [key: string]: CustomerValue | any;

  /**
   * The customers first name
   * @type {string}
   * @memberof Customer
   */
  'firstName'?: string;
  /**
   * The customers last name
   * @type {string}
   * @memberof Customer
   */
  'lastName'?: string;
  /**
   * The customers full name
   * @type {string}
   * @memberof Customer
   */
  'name': string;
  /**
   * The customers email address
   * @type {string}
   * @memberof Customer
   */
  'email'?: string | null;
  /**
   * The customers phone number
   * @type {string}
   * @memberof Customer
   */
  'phone'?: string | null;
  /**
   * The customers profile image
   * @type {string}
   * @memberof Customer
   */
  'img'?: string | null;
  /**
   * The customers neighborhood
   * @type {string}
   * @memberof Customer
   */
  'neighborhood'?: string | null;
  /**
   * The customers city
   * @type {string}
   * @memberof Customer
   */
  'city'?: string | null;
  /**
   * The customers 2-letter country code
   * @type {string}
   * @memberof Customer
   */
  'country'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof Customer
   */
  'line1'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof Customer
   */
  'line2'?: string | null;
  /**
   * The customers postal code
   * @type {string}
   * @memberof Customer
   */
  'postal_code'?: string | null;
  /**
   * The customers state, county, province, or region
   * @type {string}
   * @memberof Customer
   */
  'state'?: string | null;
  /**
   * The customers town (only used in Japan)
   * @type {string}
   * @memberof Customer
   */
  'town'?: string | null;
  /**
   *
   * @type {BlockInfo}
   * @memberof Customer
   */
  'blocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof Customer
   */
  'phoneBlocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof Customer
   */
  'emailBlocked'?: BlockInfo;
  /**
   * The date the customer joined the business
   * @type {string}
   * @memberof Customer
   */
  'joined'?: string | null;
  /**
   * The customers stripe ID
   * @type {string}
   * @memberof Customer
   */
  'stripe'?: string | null;
  /**
   * The customers stripe ID in the dev environment
   * @type {string}
   * @memberof Customer
   */
  'stripeDev'?: string | null;
}
/**
 *
 * @export
 * @interface CustomerCreateResponse
 */
export interface CustomerCreateResponse {
  /**
   *
   * @type {boolean}
   * @memberof CustomerCreateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof CustomerCreateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof CustomerCreateResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface CustomerDeleteResponse
 */
export interface CustomerDeleteResponse {
  /**
   *
   * @type {boolean}
   * @memberof CustomerDeleteResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof CustomerDeleteResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof CustomerDeleteResponse
   */
  'id': string;
}
/**
 * A way for a business to group customers to use in scheduling batch conversations
 * @export
 * @interface CustomerGroup
 */
export interface CustomerGroup {
  /**
   * The name of the customer group
   * @type {string}
   * @memberof CustomerGroup
   */
  'name': string;
  /**
   * The description of the customer group
   * @type {string}
   * @memberof CustomerGroup
   */
  'description'?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof CustomerGroup
   */
  'metadata'?: { [key: string]: any; };
  /**
   *
   * @type {Array<CustomerGroupRecord>}
   * @memberof CustomerGroup
   */
  'customers': Array<CustomerGroupRecord>;
}
/**
 * A way for a business to group customers to use in scheduling batch conversations
 * @export
 * @interface CustomerGroupRecord
 */
export interface CustomerGroupRecord {
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof CustomerGroupRecord
   */
  'id': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof CustomerGroupRecord
   */
  'environment': ConversationEnvironment;
  /**
   * Overrides the default $agent for this customer
   * @type {string}
   * @memberof CustomerGroupRecord
   */
  '$agent'?: string;
}


/**
 *
 * @export
 * @interface CustomerUpdateResponse
 */
export interface CustomerUpdateResponse {
  /**
   *
   * @type {boolean}
   * @memberof CustomerUpdateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof CustomerUpdateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof CustomerUpdateResponse
   */
  'id': string;
}
/**
 * @type CustomerValue
 * @export
 */
export type CustomerValue = boolean | number | string;

/**
 *
 * @export
 * @interface DeleteCustomerGroupResponse
 */
export interface DeleteCustomerGroupResponse {
  /**
   *
   * @type {boolean}
   * @memberof DeleteCustomerGroupResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof DeleteCustomerGroupResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof DeleteCustomerGroupResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface DeleteCustomerGroupsResponse
 */
export interface DeleteCustomerGroupsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof DeleteCustomerGroupsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof DeleteCustomerGroupsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface DeleteCustomersResponse
 */
export interface DeleteCustomersResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof DeleteCustomersResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof DeleteCustomersResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface DeleteFileResponse
 */
export interface DeleteFileResponse {
  /**
   *
   * @type {string}
   * @memberof DeleteFileResponse
   */
  'id': string;
  /**
   *
   * @type {string}
   * @memberof DeleteFileResponse
   */
  'object': string;
  /**
   *
   * @type {boolean}
   * @memberof DeleteFileResponse
   */
  'deleted': boolean;
}
/**
 *
 * @export
 * @interface EntitiesBuildConfigInner
 */
export interface EntitiesBuildConfigInner {
  /**
   *
   * @type {Array<string>}
   * @memberof EntitiesBuildConfigInner
   */
  'entities'?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof EntitiesBuildConfigInner
   */
  'entity'?: string;
  /**
   *
   * @type {Array<EntityBuildConfigDefinitionsInner>}
   * @memberof EntitiesBuildConfigInner
   */
  'definitions'?: Array<EntityBuildConfigDefinitionsInner>;
  /**
   *
   * @type {Array<EntityBuildConfigTrainingInner>}
   * @memberof EntitiesBuildConfigInner
   */
  'training'?: Array<EntityBuildConfigTrainingInner>;
  /**
   *
   * @type {Array<EntityBuildConfigTestsInner>}
   * @memberof EntitiesBuildConfigInner
   */
  'tests'?: Array<EntityBuildConfigTestsInner>;
}
/**
 *
 * @export
 * @interface Entity
 */
export interface Entity {
  /**
   *
   * @type {string}
   * @memberof Entity
   */
  'type': string;
  /**
   *
   * @type {string}
   * @memberof Entity
   */
  'id': string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof Entity
   */
  'data': { [key: string]: any; };
}
/**
 *
 * @export
 * @interface EntityBuildConfig
 */
export interface EntityBuildConfig {
  /**
   *
   * @type {Array<EntityBuildConfigDefinitionsInner>}
   * @memberof EntityBuildConfig
   */
  'definitions'?: Array<EntityBuildConfigDefinitionsInner>;
  /**
   *
   * @type {Array<EntityBuildConfigTrainingInner>}
   * @memberof EntityBuildConfig
   */
  'training'?: Array<EntityBuildConfigTrainingInner>;
  /**
   *
   * @type {Array<EntityBuildConfigTestsInner>}
   * @memberof EntityBuildConfig
   */
  'tests'?: Array<EntityBuildConfigTestsInner>;
}
/**
 *
 * @export
 * @interface EntityBuildConfigDefinitionsInner
 */
export interface EntityBuildConfigDefinitionsInner {
  /**
   *
   * @type {string}
   * @memberof EntityBuildConfigDefinitionsInner
   */
  'utterance'?: string;
  /**
   *
   * @type {string}
   * @memberof EntityBuildConfigDefinitionsInner
   */
  'value'?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof EntityBuildConfigDefinitionsInner
   */
  'text'?: Array<string>;
}
/**
 *
 * @export
 * @interface EntityBuildConfigTestsInner
 */
export interface EntityBuildConfigTestsInner {
  /**
   *
   * @type {string}
   * @memberof EntityBuildConfigTestsInner
   */
  'text'?: string;
  /**
   *
   * @type {EntityBuildConfigTestsInnerExpected}
   * @memberof EntityBuildConfigTestsInner
   */
  'expected'?: EntityBuildConfigTestsInnerExpected;
}
/**
 *
 * @export
 * @interface EntityBuildConfigTestsInnerExpected
 */
export interface EntityBuildConfigTestsInnerExpected {
  /**
   *
   * @type {string}
   * @memberof EntityBuildConfigTestsInnerExpected
   */
  'intent'?: string;
  /**
   *
   * @type {object}
   * @memberof EntityBuildConfigTestsInnerExpected
   */
  'context'?: object;
}
/**
 *
 * @export
 * @interface EntityBuildConfigTrainingInner
 */
export interface EntityBuildConfigTrainingInner {
  /**
   *
   * @type {string}
   * @memberof EntityBuildConfigTrainingInner
   */
  'text'?: string;
  /**
   *
   * @type {string}
   * @memberof EntityBuildConfigTrainingInner
   */
  'intent'?: string;
}
/**
 *
 * @export
 * @interface EntityData
 */
export interface EntityData {
  /**
   * Data of the entity
   * @type {{ [key: string]: any; }}
   * @memberof EntityData
   */
  'data'?: { [key: string]: any; };
}
/**
 *
 * @export
 * @interface EqualityCondition
 */
export interface EqualityCondition {
  /**
   *
   * @type {string}
   * @memberof EqualityCondition
   */
  'path': string;
  /**
   *
   * @type {EqualityOperator}
   * @memberof EqualityCondition
   */
  'operator': EqualityOperator;
  /**
   *
   * @type {any}
   * @memberof EqualityCondition
   */
  'value': any;
  /**
   *
   * @type {boolean}
   * @memberof EqualityCondition
   */
  'external'?: boolean;
}


/**
 *
 * @export
 * @interface EqualityConditionAllOf
 */
export interface EqualityConditionAllOf {
  /**
   *
   * @type {EqualityOperator}
   * @memberof EqualityConditionAllOf
   */
  'operator': EqualityOperator;
  /**
   *
   * @type {any}
   * @memberof EqualityConditionAllOf
   */
  'value': any;
}


/**
 *
 * @export
 * @enum {string}
 */

export const EqualityOperator = {
  Eq: 'eq',
  Neq: 'neq',
  Gt: 'gt',
  Gte: 'gte',
  Lt: 'lt',
  Lte: 'lte',
  In: 'in',
  Nin: 'nin',
  Contains: 'contains',
  NotContains: 'notContains',
  StartsWith: 'startsWith',
  EndsWith: 'endsWith',
  ArrayContainsAny: 'arrayContainsAny',
  ArrayContains: 'arrayContains'
} as const;

export type EqualityOperator = typeof EqualityOperator[keyof typeof EqualityOperator];


/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
  /**
   *
   * @type {Error}
   * @memberof ErrorResponse
   */
  'error': Error;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ExistenceOperator = {
  Exists: 'exists',
  NotExists: 'notExists'
} as const;

export type ExistenceOperator = typeof ExistenceOperator[keyof typeof ExistenceOperator];


/**
 *
 * @export
 * @interface ExistsCondition
 */
export interface ExistsCondition {
  /**
   *
   * @type {string}
   * @memberof ExistsCondition
   */
  'path': string;
  /**
   *
   * @type {ExistenceOperator}
   * @memberof ExistsCondition
   */
  'operator': ExistenceOperator;
  /**
   *
   * @type {any}
   * @memberof ExistsCondition
   */
  'value'?: any;
  /**
   *
   * @type {boolean}
   * @memberof ExistsCondition
   */
  'external'?: boolean;
}


/**
 *
 * @export
 * @interface ExistsConditionAllOf
 */
export interface ExistsConditionAllOf {
  /**
   *
   * @type {ExistenceOperator}
   * @memberof ExistsConditionAllOf
   */
  'operator': ExistenceOperator;
}


/**
 *
 * @export
 * @interface FileUpload200Response
 */
export interface FileUpload200Response {
  /**
   *
   * @type {Array<Scout9File>}
   * @memberof FileUpload200Response
   */
  'files'?: Array<Scout9File>;
}
/**
 * Forward a conversation to the corresponding agent. .convo can be overwritten with a Conversation object, .latestMessage overrides the given conversations latest user messages (typically only used in development). If \".forward\" is provided, it will override the default agent to forward to.
 * @export
 * @interface ForwardRequest
 */
export interface ForwardRequest {
  /**
   *
   * @type {ForwardRequestConvo}
   * @memberof ForwardRequest
   */
  'convo'?: ForwardRequestConvo;
  /**
   *
   * @type {ForwardRequestForward}
   * @memberof ForwardRequest
   */
  'forward'?: ForwardRequestForward;
  /**
   *
   * @type {ForwardRequestLatestMessage}
   * @memberof ForwardRequest
   */
  'latestMessage'?: ForwardRequestLatestMessage;
}
/**
 * @type ForwardRequestConvo
 * @export
 */
export type ForwardRequestConvo = ConversationWithId | string;

/**
 * @type ForwardRequestForward
 * Forward information, if \"true\", it will automatically forward to the corresponding agent of the given conversation, \"string\" or \"object\" will override the default agent.
 * @export
 */
export type ForwardRequestForward = ForwardRequestForwardOneOf | boolean | string;

/**
 * The agent to forward to
 * @export
 * @interface ForwardRequestForwardOneOf
 */
export interface ForwardRequestForwardOneOf {
  /**
   * The ID, email or phone number to forward to
   * @type {string}
   * @memberof ForwardRequestForwardOneOf
   */
  'to': string;
  /**
   * The mode to forward the conversation (defaults to immediately)
   * @type {string}
   * @memberof ForwardRequestForwardOneOf
   */
  'mode'?: ForwardRequestForwardOneOfModeEnum;
}

export const ForwardRequestForwardOneOfModeEnum = {
  AfterReply: 'after-reply',
  Immediately: 'immediately'
} as const;

export type ForwardRequestForwardOneOfModeEnum = typeof ForwardRequestForwardOneOfModeEnum[keyof typeof ForwardRequestForwardOneOfModeEnum];

/**
 *
 * @export
 * @interface ForwardRequestLatestMessage
 */
export interface ForwardRequestLatestMessage {
  /**
   * The role of the message (customer, agent, or business)
   * @type {string}
   * @memberof ForwardRequestLatestMessage
   */
  'role': ForwardRequestLatestMessageRoleEnum;
  /**
   * The content of the message
   * @type {string}
   * @memberof ForwardRequestLatestMessage
   */
  'content': string;
  /**
   * The name of the sender
   * @type {string}
   * @memberof ForwardRequestLatestMessage
   */
  'name'?: string;
  /**
   * The time the message was sent
   * @type {string}
   * @memberof ForwardRequestLatestMessage
   */
  'time': string;
}

export const ForwardRequestLatestMessageRoleEnum = {
  Customer: 'customer',
  Agent: 'agent',
  Context: 'context'
} as const;

export type ForwardRequestLatestMessageRoleEnum = typeof ForwardRequestLatestMessageRoleEnum[keyof typeof ForwardRequestLatestMessageRoleEnum];

/**
 *
 * @export
 * @interface ForwardResponse
 */
export interface ForwardResponse {
  /**
   * The time it took to forward the message in milliseconds
   * @type {number}
   * @memberof ForwardResponse
   */
  'ms': number;
}
/**
 * @type GenerateRequest
 * Either a conversation ID or a conversation object with messages and context metadata to generate from
 * @export
 */
export type GenerateRequest = GenerateRequestOneOf | string;

/**
 *
 * @export
 * @interface GenerateRequestOneOf
 */
export interface GenerateRequestOneOf {
  /**
   * Conversation messages and context to generate message from
   * @type {Array<Message>}
   * @memberof GenerateRequestOneOf
   */
  'messages': Array<Message>;
  /**
   *
   * @type {GenerateRequestOneOfPersona}
   * @memberof GenerateRequestOneOf
   */
  'persona': GenerateRequestOneOfPersona;
  /**
   *
   * @type {LlmConfig}
   * @memberof GenerateRequestOneOf
   */
  'llm'?: LlmConfig;
  /**
   *
   * @type {PmtConfig}
   * @memberof GenerateRequestOneOf
   */
  'pmt'?: PmtConfig;
}
/**
 * @type GenerateRequestOneOfPersona
 * @export
 */
export type GenerateRequestOneOfPersona = Agent | string;

/**
 *
 * @export
 * @interface GenerateResponse
 */
export interface GenerateResponse {
  /**
   * The generated message
   * @type {string}
   * @memberof GenerateResponse
   */
  'message': string;
  /**
   * The time it took to generate the message in milliseconds
   * @type {number}
   * @memberof GenerateResponse
   */
  'ms': number;
  /**
   * Whether the message should be sent to the customer after generating
   * @type {boolean}
   * @memberof GenerateResponse
   */
  'send'?: boolean;
  /**
   * Any errors that occurred during generation
   * @type {string}
   * @memberof GenerateResponse
   */
  'error'?: string;
  /**
   * Whether the conversation should be forwarded to the agent after sending message
   * @type {boolean}
   * @memberof GenerateResponse
   */
  'forward'?: boolean;
  /**
   * reason for forwarding the conversation
   * @type {string}
   * @memberof GenerateResponse
   */
  'forwardNote'?: string;
}
/**
 *
 * @export
 * @interface GetAgentResponse
 */
export interface GetAgentResponse {
  /**
   * Agent first name
   * @type {string}
   * @memberof GetAgentResponse
   */
  'firstName': string;
  /**
   * Agent last name
   * @type {string}
   * @memberof GetAgentResponse
   */
  'lastName': string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof GetAgentResponse
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof GetAgentResponse
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof GetAgentResponse
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof GetAgentResponse
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof GetAgentResponse
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof GetAgentResponse
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof GetAgentResponse
   */
  'title'?: string;
  /**
   *
   * @type {AgentContext}
   * @memberof GetAgentResponse
   */
  'context'?: AgentContext;
  /**
   * Profile image file id of the agent
   * @type {string}
   * @memberof GetAgentResponse
   */
  'img'?: string;
  /**
   * Transcript file ids of the agent
   * @type {Array<string>}
   * @memberof GetAgentResponse
   */
  'transcripts'?: Array<string>;
  /**
   * Audio file ids of the agent
   * @type {Array<string>}
   * @memberof GetAgentResponse
   */
  'audios'?: Array<string>;
  /**
   * The ID of the agent
   * @type {string}
   * @memberof GetAgentResponse
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface GetAgentResponseAllOf
 */
export interface GetAgentResponseAllOf {
  /**
   * The ID of the agent
   * @type {string}
   * @memberof GetAgentResponseAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface GetApiOperationResponse
 */
export interface GetApiOperationResponse {
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof GetApiOperationResponse
   */
  'time': string;
  /**
   * The model that was created, updated, or deleted
   * @type {string}
   * @memberof GetApiOperationResponse
   */
  'model': string;
  /**
   * The method that was called
   * @type {string}
   * @memberof GetApiOperationResponse
   */
  'method': GetApiOperationResponseMethodEnum;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof GetApiOperationResponse
   */
  'results': { [key: string]: any; };
  /**
   * The ID of the operation
   * @type {string}
   * @memberof GetApiOperationResponse
   */
  '$id': string;
}

export const GetApiOperationResponseMethodEnum = {
  Get: 'get',
  Post: 'post',
  Put: 'put',
  Delete: 'delete',
  Patch: 'patch'
} as const;

export type GetApiOperationResponseMethodEnum = typeof GetApiOperationResponseMethodEnum[keyof typeof GetApiOperationResponseMethodEnum];

/**
 *
 * @export
 * @interface GetApiOperationResponseAllOf
 */
export interface GetApiOperationResponseAllOf {
  /**
   * The ID of the operation
   * @type {string}
   * @memberof GetApiOperationResponseAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface GetCustomerGroupResponse
 */
export interface GetCustomerGroupResponse {
  /**
   * The name of the customer group
   * @type {string}
   * @memberof GetCustomerGroupResponse
   */
  'name': string;
  /**
   * The description of the customer group
   * @type {string}
   * @memberof GetCustomerGroupResponse
   */
  'description'?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof GetCustomerGroupResponse
   */
  'metadata'?: { [key: string]: any; };
  /**
   *
   * @type {Array<CustomerGroupRecord>}
   * @memberof GetCustomerGroupResponse
   */
  'customers': Array<CustomerGroupRecord>;
  /**
   * The ID of the CustomerGroup
   * @type {string}
   * @memberof GetCustomerGroupResponse
   */
  '$id'?: string;
}
/**
 *
 * @export
 * @interface GetCustomerGroupResponseAllOf
 */
export interface GetCustomerGroupResponseAllOf {
  /**
   * The ID of the CustomerGroup
   * @type {string}
   * @memberof GetCustomerGroupResponseAllOf
   */
  '$id'?: string;
}
/**
 *
 * @export
 * @interface GetCustomerResponse
 */
export interface GetCustomerResponse {
  /**
   * The customers first name
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'firstName'?: string;
  /**
   * The customers last name
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'lastName'?: string;
  /**
   * The customers full name
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'name': string;
  /**
   * The customers email address
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'email'?: string | null;
  /**
   * The customers phone number
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'phone'?: string | null;
  /**
   * The customers profile image
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'img'?: string | null;
  /**
   * The customers neighborhood
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'neighborhood'?: string | null;
  /**
   * The customers city
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'city'?: string | null;
  /**
   * The customers 2-letter country code
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'country'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'line1'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'line2'?: string | null;
  /**
   * The customers postal code
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'postal_code'?: string | null;
  /**
   * The customers state, county, province, or region
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'state'?: string | null;
  /**
   * The customers town (only used in Japan)
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'town'?: string | null;
  /**
   *
   * @type {BlockInfo}
   * @memberof GetCustomerResponse
   */
  'blocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof GetCustomerResponse
   */
  'phoneBlocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof GetCustomerResponse
   */
  'emailBlocked'?: BlockInfo;
  /**
   * The date the customer joined the business
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'joined'?: string | null;
  /**
   * The customers stripe ID
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'stripe'?: string | null;
  /**
   * The customers stripe ID in the dev environment
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'stripeDev'?: string | null;
  /**
   * The ID of the customer
   * @type {string}
   * @memberof GetCustomerResponse
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface Instruction
 */
export interface Instruction {
  /**
   *
   * @type {string}
   * @memberof Instruction
   */
  'id': string;
  /**
   *
   * @type {string}
   * @memberof Instruction
   */
  'content': string;
}
/**
 *
 * @export
 * @interface ListAgentsResponseInner
 */
export interface ListAgentsResponseInner {
  /**
   * Agent first name
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'firstName'?: string;
  /**
   * Agent last name
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'lastName'?: string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof ListAgentsResponseInner
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'title'?: string;
  /**
   *
   * @type {AgentContext}
   * @memberof ListAgentsResponseInner
   */
  'context'?: AgentContext;
  /**
   * The ID of the agent
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListAgentsResponseInnerAllOf
 */
export interface ListAgentsResponseInnerAllOf {
  /**
   * The ID of the agent
   * @type {string}
   * @memberof ListAgentsResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListApiOperationsResponseInner
 */
export interface ListApiOperationsResponseInner {
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ListApiOperationsResponseInner
   */
  'time': string;
  /**
   * The model that was created, updated, or deleted
   * @type {string}
   * @memberof ListApiOperationsResponseInner
   */
  'model': string;
  /**
   * The method that was called
   * @type {string}
   * @memberof ListApiOperationsResponseInner
   */
  'method': ListApiOperationsResponseInnerMethodEnum;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof ListApiOperationsResponseInner
   */
  'results': { [key: string]: any; };
  /**
   * The ID of the operation
   * @type {string}
   * @memberof ListApiOperationsResponseInner
   */
  '$id': string;
}

export const ListApiOperationsResponseInnerMethodEnum = {
  Get: 'get',
  Post: 'post',
  Put: 'put',
  Delete: 'delete',
  Patch: 'patch'
} as const;

export type ListApiOperationsResponseInnerMethodEnum = typeof ListApiOperationsResponseInnerMethodEnum[keyof typeof ListApiOperationsResponseInnerMethodEnum];

/**
 *
 * @export
 * @interface ListApiOperationsResponseInnerAllOf
 */
export interface ListApiOperationsResponseInnerAllOf {
  /**
   * The ID of the operation
   * @type {string}
   * @memberof ListApiOperationsResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListConversationsResponseInner
 */
export interface ListConversationsResponseInner {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ListConversationsResponseInner
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ListConversationsResponseInner
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ListConversationsResponseInner
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * User for this conversation
   * @type {string}
   * @memberof ListConversationsResponseInner
   */
  '$user': string;
  /**
   * Customer this conversation is with (use $user instead)
   * @type {string}
   * @memberof ListConversationsResponseInner
   * @deprecated
   */
  '$customer'?: string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ListConversationsResponseInner
   */
  'environment': ConversationEnvironment;
  /**
   * Whether this conversation is a test or not
   * @type {boolean}
   * @memberof ListConversationsResponseInner
   */
  'test'?: boolean;
  /**
   * The client web url of the conversation
   * @type {string}
   * @memberof ListConversationsResponseInner
   */
  'clientWebUrl'?: string;
  /**
   * The agent web url of the conversation (requires phone two-factor authentication)
   * @type {string}
   * @memberof ListConversationsResponseInner
   */
  'agentWebUrl'?: string;
  /**
   * The agent test web url of the conversation, used for testing the conversation without notifying the customer
   * @type {string}
   * @memberof ListConversationsResponseInner
   */
  'agentTestWebUrl'?: string;
  /**
   * ISO 8601 date string of when the conversation was initiated
   * @type {string}
   * @memberof ListConversationsResponseInner
   */
  'initiated': string;
  /**
   * The ID of the conversation
   * @type {string}
   * @memberof ListConversationsResponseInner
   */
  '$id': string;
}


/**
 *
 * @export
 * @interface ListConversationsResponseInnerAllOf
 */
export interface ListConversationsResponseInnerAllOf {
  /**
   * The ID of the conversation
   * @type {string}
   * @memberof ListConversationsResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListCustomerGroupsResponseInner
 */
export interface ListCustomerGroupsResponseInner {
  /**
   * The name of the customer group
   * @type {string}
   * @memberof ListCustomerGroupsResponseInner
   */
  'name': string;
  /**
   * The description of the customer group
   * @type {string}
   * @memberof ListCustomerGroupsResponseInner
   */
  'description'?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof ListCustomerGroupsResponseInner
   */
  'metadata'?: { [key: string]: any; };
  /**
   *
   * @type {Array<CustomerGroupRecord>}
   * @memberof ListCustomerGroupsResponseInner
   */
  'customers': Array<CustomerGroupRecord>;
  /**
   * The ID of the CustomerGroup
   * @type {string}
   * @memberof ListCustomerGroupsResponseInner
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListCustomerGroupsResponseInnerAllOf
 */
export interface ListCustomerGroupsResponseInnerAllOf {
  /**
   * The ID of the CustomerGroup
   * @type {string}
   * @memberof ListCustomerGroupsResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListCustomersResponseInner
 */
export interface ListCustomersResponseInner {
  /**
   * The customers first name
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'firstName'?: string;
  /**
   * The customers last name
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'lastName'?: string;
  /**
   * The customers full name
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'name': string;
  /**
   * The customers email address
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'email'?: string | null;
  /**
   * The customers phone number
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'phone'?: string | null;
  /**
   * The customers profile image
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'img'?: string | null;
  /**
   * The customers neighborhood
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'neighborhood'?: string | null;
  /**
   * The customers city
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'city'?: string | null;
  /**
   * The customers 2-letter country code
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'country'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'line1'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'line2'?: string | null;
  /**
   * The customers postal code
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'postal_code'?: string | null;
  /**
   * The customers state, county, province, or region
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'state'?: string | null;
  /**
   * The customers town (only used in Japan)
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'town'?: string | null;
  /**
   *
   * @type {BlockInfo}
   * @memberof ListCustomersResponseInner
   */
  'blocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof ListCustomersResponseInner
   */
  'phoneBlocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof ListCustomersResponseInner
   */
  'emailBlocked'?: BlockInfo;
  /**
   * The date the customer joined the business
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'joined'?: string | null;
  /**
   * The customers stripe ID
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'stripe'?: string | null;
  /**
   * The customers stripe ID in the dev environment
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'stripeDev'?: string | null;
  /**
   * The ID of the customer
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListCustomersResponseInnerAllOf
 */
export interface ListCustomersResponseInnerAllOf {
  /**
   * The ID of the customer
   * @type {string}
   * @memberof ListCustomersResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListFilesResponseInner
 */
export interface ListFilesResponseInner {
  /**
   * The file identifier, which can be referenced in the API endpoints.
   * @type {string}
   * @memberof ListFilesResponseInner
   */
  '$id'?: string;
  /**
   * The name of the file.
   * @type {string}
   * @memberof ListFilesResponseInner
   */
  'name'?: string;
  /**
   * The path of the file.
   * @type {string}
   * @memberof ListFilesResponseInner
   */
  'path'?: string;
}
/**
 *
 * @export
 * @interface ListQuery
 */
export interface ListQuery {
  /**
   *
   * @type {ListQueryId}
   * @memberof ListQuery
   */
  'id'?: ListQueryId;
  /**
   *
   * @type {Array<ListQueryOperationsInner>}
   * @memberof ListQuery
   */
  'operations'?: Array<ListQueryOperationsInner>;
}
/**
 * @type ListQueryId
 * @export
 */
export type ListQueryId = Array<string> | string;

/**
 *
 * @export
 * @interface ListQueryOperationsInner
 */
export interface ListQueryOperationsInner {
  /**
   * The field path to filter on
   * @type {string}
   * @memberof ListQueryOperationsInner
   */
  'fieldPath': string;
  /**
   *
   * @type {Operator}
   * @memberof ListQueryOperationsInner
   */
  'operator': Operator;
  /**
   *
   * @type {AnyValue}
   * @memberof ListQueryOperationsInner
   */
  'value': AnyValue;
}
/**
 * @type LlmConfig
 * @export
 */
export type LlmConfig = LlmConfigOneOf | LlmConfigOneOf1 | LlmConfigOneOf2;

/**
 *
 * @export
 * @interface LlmConfigOneOf
 */
export interface LlmConfigOneOf {
  /**
   *
   * @type {string}
   * @memberof LlmConfigOneOf
   */
  'engine'?: LlmConfigOneOfEngineEnum;
  /**
   *
   * @type {string}
   * @memberof LlmConfigOneOf
   */
  'model'?: LlmConfigOneOfModelEnum;
}

export const LlmConfigOneOfEngineEnum = {
  Openai: 'openai'
} as const;

export type LlmConfigOneOfEngineEnum = typeof LlmConfigOneOfEngineEnum[keyof typeof LlmConfigOneOfEngineEnum];
export const LlmConfigOneOfModelEnum = {
  _41106Preview: 'gpt-4-1106-preview',
  _4VisionPreview: 'gpt-4-vision-preview',
  _4: 'gpt-4',
  _40314: 'gpt-4-0314',
  _40613: 'gpt-4-0613',
  _432k: 'gpt-4-32k',
  _432k0314: 'gpt-4-32k-0314',
  _432k0613: 'gpt-4-32k-0613',
  _35Turbo: 'gpt-3.5-turbo',
  _35Turbo16k: 'gpt-3.5-turbo-16k',
  _35Turbo0301: 'gpt-3.5-turbo-0301',
  _35Turbo0613: 'gpt-3.5-turbo-0613',
  _35Turbo16k0613: 'gpt-3.5-turbo-16k-0613'
} as const;

export type LlmConfigOneOfModelEnum = typeof LlmConfigOneOfModelEnum[keyof typeof LlmConfigOneOfModelEnum];

/**
 *
 * @export
 * @interface LlmConfigOneOf1
 */
export interface LlmConfigOneOf1 {
  /**
   *
   * @type {string}
   * @memberof LlmConfigOneOf1
   */
  'engine'?: LlmConfigOneOf1EngineEnum;
  /**
   *
   * @type {string}
   * @memberof LlmConfigOneOf1
   */
  'model'?: string;
}

export const LlmConfigOneOf1EngineEnum = {
  Llama: 'llama'
} as const;

export type LlmConfigOneOf1EngineEnum = typeof LlmConfigOneOf1EngineEnum[keyof typeof LlmConfigOneOf1EngineEnum];

/**
 *
 * @export
 * @interface LlmConfigOneOf2
 */
export interface LlmConfigOneOf2 {
  /**
   *
   * @type {string}
   * @memberof LlmConfigOneOf2
   */
  'engine'?: LlmConfigOneOf2EngineEnum;
  /**
   *
   * @type {string}
   * @memberof LlmConfigOneOf2
   */
  'model'?: string;
}

export const LlmConfigOneOf2EngineEnum = {
  Bard: 'bard'
} as const;

export type LlmConfigOneOf2EngineEnum = typeof LlmConfigOneOf2EngineEnum[keyof typeof LlmConfigOneOf2EngineEnum];

/**
 *
 * @export
 * @interface LogEntry
 */
export interface LogEntry {
  /**
   *
   * @type {string}
   * @memberof LogEntry
   */
  'id'?: string;
  /**
   * The timestamp of the log entry in ISO 8601 format.
   * @type {string}
   * @memberof LogEntry
   */
  'time'?: string;
  /**
   *
   * @type {string}
   * @memberof LogEntry
   */
  'severity'?: string;
  /**
   *
   * @type {string}
   * @memberof LogEntry
   */
  'message'?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof LogEntry
   */
  'details'?: { [key: string]: any; } | null;
}
/**
 *
 * @export
 * @interface LogResponse
 */
export interface LogResponse {
  /**
   *
   * @type {LogEntry}
   * @memberof LogResponse
   */
  'logs'?: LogEntry;
  /**
   * A token to retrieve the next set of logs, if any.
   * @type {string}
   * @memberof LogResponse
   */
  'nextToken'?: string | null;
}
/**
 * @type Logic
 * @export
 */
export type Logic = AndLogic | ConditionLogic | NotLogic | OrLogic;

/**
 *
 * @export
 * @interface Logs400Response
 */
export interface Logs400Response {
  /**
   *
   * @type {string}
   * @memberof Logs400Response
   */
  'status'?: string;
  /**
   *
   * @type {string}
   * @memberof Logs400Response
   */
  'message'?: string;
}
/**
 *
 * @export
 * @interface Logs500Response
 */
export interface Logs500Response {
  /**
   *
   * @type {string}
   * @memberof Logs500Response
   */
  'status'?: string;
  /**
   *
   * @type {string}
   * @memberof Logs500Response
   */
  'message'?: string;
}
/**
 *
 * @export
 * @interface MacroContextInput
 */
export interface MacroContextInput {
  /**
   *
   * @type {string}
   * @memberof MacroContextInput
   */
  'prompt': string;
  /**
   *
   * @type {string}
   * @memberof MacroContextInput
   */
  'convoId': string;
  /**
   *
   * @type {WorkflowEvent}
   * @memberof MacroContextInput
   */
  'event'?: WorkflowEvent;
  /**
   * Whether to use cache state to speed up requests
   * @type {boolean}
   * @memberof MacroContextInput
   */
  'cache'?: boolean;
  /**
   *
   * @type {MacroContextInputExamples}
   * @memberof MacroContextInput
   */
  'examples'?: MacroContextInputExamples;
}
/**
 * @type MacroContextInputExamples
 * @export
 */
export type MacroContextInputExamples = Array<MacroContextInputExamplesOneOfInner> | Array<{ [key: string]: any; }>;

/**
 *
 * @export
 * @interface MacroContextInputExamplesOneOfInner
 */
export interface MacroContextInputExamplesOneOfInner {
  /**
   *
   * @type {string}
   * @memberof MacroContextInputExamplesOneOfInner
   */
  'input': string;
  /**
   *
   * @type {MacroContextInputExamplesOneOfInnerOutput}
   * @memberof MacroContextInputExamplesOneOfInner
   */
  'output': MacroContextInputExamplesOneOfInnerOutput;
}
/**
 * @type MacroContextInputExamplesOneOfInnerOutput
 * @export
 */
export type MacroContextInputExamplesOneOfInnerOutput = Array<{ [key: string]: any; }> | { [key: string]: any; };

/**
 *
 * @export
 * @interface MacroContextResult
 */
export interface MacroContextResult {
  /**
   * The prompt that was used
   * @type {string}
   * @memberof MacroContextResult
   */
  'prompt'?: string;
  /**
   * Type is hard-coded to \'context\'
   * @type {string}
   * @memberof MacroContextResult
   */
  'type'?: MacroContextResultTypeEnum;
  /**
   *
   * @type {MacroContextValue}
   * @memberof MacroContextResult
   */
  'value'?: MacroContextValue;
  /**
   * The number of tokens used to generate this response
   * @type {number}
   * @memberof MacroContextResult
   */
  'tokensTotal'?: number;
}

export const MacroContextResultTypeEnum = {
  Context: 'context'
} as const;

export type MacroContextResultTypeEnum = typeof MacroContextResultTypeEnum[keyof typeof MacroContextResultTypeEnum];

/**
 * @type MacroContextValue
 * @export
 */
export type MacroContextValue = Array<{ [key: string]: any; }> | { [key: string]: any; };

/**
 *
 * @export
 * @interface MacroDidInput
 */
export interface MacroDidInput {
  /**
   *
   * @type {string}
   * @memberof MacroDidInput
   */
  'prompt': string;
  /**
   *
   * @type {WorkflowEvent}
   * @memberof MacroDidInput
   */
  'event'?: WorkflowEvent;
  /**
   *
   * @type {string}
   * @memberof MacroDidInput
   */
  'convoId': string;
  /**
   * Whether to use cache state to speed up requests
   * @type {boolean}
   * @memberof MacroDidInput
   */
  'cache'?: boolean;
}
/**
 *
 * @export
 * @interface MacroDidResult
 */
export interface MacroDidResult {
  /**
   * The prompt that was used
   * @type {string}
   * @memberof MacroDidResult
   */
  'prompt'?: string;
  /**
   * Type is hard-coded to \'did\'
   * @type {string}
   * @memberof MacroDidResult
   */
  'type'?: MacroDidResultTypeEnum;
  /**
   * The returned value is of type boolean
   * @type {boolean}
   * @memberof MacroDidResult
   */
  'value'?: boolean;
  /**
   * The number of tokens used to generate this response
   * @type {number}
   * @memberof MacroDidResult
   */
  'tokensTotal'?: number;
}

export const MacroDidResultTypeEnum = {
  Did: 'did'
} as const;

export type MacroDidResultTypeEnum = typeof MacroDidResultTypeEnum[keyof typeof MacroDidResultTypeEnum];

/**
 *
 * @export
 * @interface MacroDoesInput
 */
export interface MacroDoesInput {
  /**
   *
   * @type {string}
   * @memberof MacroDoesInput
   */
  'prompt': string;
  /**
   * Eval on customer\'s immediate message or last agent\'s message? (defaults to \"customer\")
   * @type {string}
   * @memberof MacroDoesInput
   */
  'role'?: MacroDoesInputRoleEnum;
  /**
   * Whether to use cache state to speed up requests
   * @type {boolean}
   * @memberof MacroDoesInput
   */
  'cache'?: boolean;
  /**
   *
   * @type {WorkflowEvent}
   * @memberof MacroDoesInput
   */
  'event'?: WorkflowEvent;
  /**
   *
   * @type {string}
   * @memberof MacroDoesInput
   */
  'convoId': string;
}

export const MacroDoesInputRoleEnum = {
  Customer: 'customer',
  Agent: 'agent'
} as const;

export type MacroDoesInputRoleEnum = typeof MacroDoesInputRoleEnum[keyof typeof MacroDoesInputRoleEnum];

/**
 *
 * @export
 * @interface MacroDoesResult
 */
export interface MacroDoesResult {
  /**
   * The prompt that was used
   * @type {string}
   * @memberof MacroDoesResult
   */
  'prompt'?: string;
  /**
   * Type is hard-coded to \'does\'
   * @type {string}
   * @memberof MacroDoesResult
   */
  'type'?: MacroDoesResultTypeEnum;
  /**
   * The returned value is of type boolean
   * @type {boolean}
   * @memberof MacroDoesResult
   */
  'value'?: boolean;
  /**
   * The number of tokens used to generate this response
   * @type {number}
   * @memberof MacroDoesResult
   */
  'tokensTotal'?: number;
}

export const MacroDoesResultTypeEnum = {
  Does: 'does'
} as const;

export type MacroDoesResultTypeEnum = typeof MacroDoesResultTypeEnum[keyof typeof MacroDoesResultTypeEnum];

/**
 *
 * @export
 * @interface MacroResult
 */
export interface MacroResult {
  /**
   * The prompt that was used
   * @type {string}
   * @memberof MacroResult
   */
  'prompt'?: string;
  /**
   * What type of Macro result this represents
   * @type {string}
   * @memberof MacroResult
   */
  'type'?: MacroResultTypeEnum;
  /**
   *
   * @type {MacroResultValue}
   * @memberof MacroResult
   */
  'value'?: MacroResultValue;
  /**
   * The number of tokens used to generate this response
   * @type {number}
   * @memberof MacroResult
   */
  'tokensTotal'?: number;
}

export const MacroResultTypeEnum = {
  Did: 'did',
  Context: 'context'
} as const;

export type MacroResultTypeEnum = typeof MacroResultTypeEnum[keyof typeof MacroResultTypeEnum];

/**
 * @type MacroResultValue
 * The returned value of the macro
 * @export
 */
export type MacroResultValue = MacroContextValue | boolean;

/**
 *
 * @export
 * @interface Message
 */
export interface Message {
  /**
   * The role of the message (customer, agent, or business)
   * @type {string}
   * @memberof Message
   */
  'role': MessageRoleEnum;
  /**
   * The content of the message
   * @type {string}
   * @memberof Message
   */
  'content': string;
  /**
   * The name of the sender
   * @type {string}
   * @memberof Message
   */
  'name'?: string;
  /**
   * The time the message was sent
   * @type {string}
   * @memberof Message
   */
  'time': string;
}

export const MessageRoleEnum = {
  Customer: 'customer',
  Agent: 'agent',
  Context: 'context'
} as const;

export type MessageRoleEnum = typeof MessageRoleEnum[keyof typeof MessageRoleEnum];

/**
 *
 * @export
 * @interface MessageAllOf
 */
export interface MessageAllOf {
  /**
   * The time the message was sent
   * @type {string}
   * @memberof MessageAllOf
   */
  'time': string;
}
/**
 *
 * @export
 * @interface MessageBase
 */
export interface MessageBase {
  /**
   * The role of the message (customer, agent, or business)
   * @type {string}
   * @memberof MessageBase
   */
  'role': MessageBaseRoleEnum;
  /**
   * The content of the message
   * @type {string}
   * @memberof MessageBase
   */
  'content': string;
  /**
   * The name of the sender
   * @type {string}
   * @memberof MessageBase
   */
  'name'?: string;
}

export const MessageBaseRoleEnum = {
  Customer: 'customer',
  Agent: 'agent',
  Context: 'context'
} as const;

export type MessageBaseRoleEnum = typeof MessageBaseRoleEnum[keyof typeof MessageBaseRoleEnum];

/**
 *
 * @export
 * @interface MessageCreateRequest
 */
export interface MessageCreateRequest {
  /**
   *
   * @type {MessageCreateRequestConvo}
   * @memberof MessageCreateRequest
   */
  'convo': MessageCreateRequestConvo;
  /**
   * The message content to send to a user
   * @type {string}
   * @memberof MessageCreateRequest
   */
  'message': string;
  /**
   * The message content to send to a user in HTML format (only available in email)
   * @type {string}
   * @memberof MessageCreateRequest
   */
  'messageHtml'?: string;
  /**
   * Overrides the role of the user sending the message
   * @type {string}
   * @memberof MessageCreateRequest
   */
  'role'?: MessageCreateRequestRoleEnum;
  /**
   * The delay in seconds until to send this message
   * @type {number}
   * @memberof MessageCreateRequest
   */
  'secondsDelay'?: number;
  /**
   * Unix timestamp to send the message
   * @type {number}
   * @memberof MessageCreateRequest
   */
  'scheduled'?: number;
}

export const MessageCreateRequestRoleEnum = {
  Agent: 'agent',
  Customer: 'customer',
  Context: 'context'
} as const;

export type MessageCreateRequestRoleEnum = typeof MessageCreateRequestRoleEnum[keyof typeof MessageCreateRequestRoleEnum];

/**
 * @type MessageCreateRequestConvo
 * @export
 */
export type MessageCreateRequestConvo = MessageCreateRequestConvoOneOf | string;

/**
 *
 * @export
 * @interface MessageCreateRequestConvoOneOf
 */
export interface MessageCreateRequestConvoOneOf {
  /**
   * The customers id, phone, or email to send to. The customer must be registered with your organization by having them reach out to you first.
   * @type {string}
   * @memberof MessageCreateRequestConvoOneOf
   */
  'customerIdOrPhoneOrEmail'?: string;
  /**
   * The agent id, phone (programmable or forward), or email this message is from. If an id is not provided and the provided value is a valid contact, the backend will resolve the agent with the corresponding agent document.
   * @type {string}
   * @memberof MessageCreateRequestConvoOneOf
   */
  'agentIdOrPhoneOrEmail'?: string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof MessageCreateRequestConvoOneOf
   */
  'environment'?: ConversationEnvironment;
}


/**
 *
 * @export
 * @interface MessageCreateResponse
 */
export interface MessageCreateResponse {
  /**
   *
   * @type {boolean}
   * @memberof MessageCreateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof MessageCreateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof MessageCreateResponse
   */
  'id': string;
  /**
   * The ID of the conversation
   * @type {string}
   * @memberof MessageCreateResponse
   */
  'convo': string;
}
/**
 *
 * @export
 * @interface MessageCreateResponseAllOf
 */
export interface MessageCreateResponseAllOf {
  /**
   * The ID of the conversation
   * @type {string}
   * @memberof MessageCreateResponseAllOf
   */
  'convo': string;
}
/**
 *
 * @export
 * @interface MessageGetResponseInner
 */
export interface MessageGetResponseInner {
  /**
   * The role of the message (customer, agent, or business)
   * @type {string}
   * @memberof MessageGetResponseInner
   */
  'role': MessageGetResponseInnerRoleEnum;
  /**
   * The content of the message
   * @type {string}
   * @memberof MessageGetResponseInner
   */
  'content': string;
  /**
   * The name of the sender
   * @type {string}
   * @memberof MessageGetResponseInner
   */
  'name'?: string;
  /**
   * The time the message was sent
   * @type {string}
   * @memberof MessageGetResponseInner
   */
  'time': string;
  /**
   * The ID of the message to get
   * @type {string}
   * @memberof MessageGetResponseInner
   */
  '$id': string;
}

export const MessageGetResponseInnerRoleEnum = {
  Customer: 'customer',
  Agent: 'agent',
  Context: 'context'
} as const;

export type MessageGetResponseInnerRoleEnum = typeof MessageGetResponseInnerRoleEnum[keyof typeof MessageGetResponseInnerRoleEnum];

/**
 *
 * @export
 * @interface MessageGetResponseInnerAllOf
 */
export interface MessageGetResponseInnerAllOf {
  /**
   * The ID of the message to get
   * @type {string}
   * @memberof MessageGetResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  'type': string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  'message': string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  'param': string | null;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  'code': string | null;
}
/**
 *
 * @export
 * @interface NotLogic
 */
export interface NotLogic {
  /**
   *
   * @type {Logic}
   * @memberof NotLogic
   */
  'not': Logic;
}
/**
 *
 * @export
 * @interface OperationBulkResponse
 */
export interface OperationBulkResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof OperationBulkResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof OperationBulkResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface OperationDocResponse
 */
export interface OperationDocResponse {
  /**
   *
   * @type {boolean}
   * @memberof OperationDocResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof OperationDocResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof OperationDocResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface OperationDocResponseAllOf
 */
export interface OperationDocResponseAllOf {
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof OperationDocResponseAllOf
   */
  'id': string;
}
/**
 *
 * @export
 * @interface OperationResponse
 */
export interface OperationResponse {
  /**
   *
   * @type {boolean}
   * @memberof OperationResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof OperationResponse
   */
  'error'?: Error;
}
/**
 * @type Operator
 * @export
 */
export type Operator = EqualityOperator | ExistenceOperator;

/**
 *
 * @export
 * @interface OrLogic
 */
export interface OrLogic {
  /**
   *
   * @type {Array<Logic>}
   * @memberof OrLogic
   */
  'or': Array<Logic>;
}
/**
 * The message to parse
 * @export
 * @interface ParseRequest
 */
export interface ParseRequest {
  /**
   * The message to parse
   * @type {string}
   * @memberof ParseRequest
   */
  'message': string;
  /**
   * The language of the message
   * @type {string}
   * @memberof ParseRequest
   */
  'language'?: string;
  /**
   *
   * @type {Array<EntitiesBuildConfigInner>}
   * @memberof ParseRequest
   */
  'entities'?: Array<EntitiesBuildConfigInner>;
}
/**
 * The parsed message
 * @export
 * @interface ParseResponse
 */
export interface ParseResponse {
  /**
   * The intent of the message
   * @type {string}
   * @memberof ParseResponse
   */
  'intent'?: string;
  /**
   * The confidence score of the intent
   * @type {number}
   * @memberof ParseResponse
   */
  'intentScore'?: number;
  /**
   * Context that is derived from the message
   * @type {{ [key: string]: any; }}
   * @memberof ParseResponse
   */
  'context': { [key: string]: any; };
  /**
   * The time it took to parse the message in milliseconds
   * @type {number}
   * @memberof ParseResponse
   */
  'ms': number;
  /**
   * the fields that were parsed
   * @type {Array<string>}
   * @memberof ParseResponse
   */
  'parsed': Array<string>;
}
/**
 * @type ParsedContextEntity
 * @export
 */
export type ParsedContextEntity = string | { [key: string]: any; };

/**
 *
 * @export
 * @interface PingRequest
 */
export interface PingRequest {
  /**
   *
   * @type {PurposeEnum}
   * @memberof PingRequest
   */
  'purpose'?: PurposeEnum;
}


/**
 *
 * @export
 * @interface PmtConfig
 */
export interface PmtConfig {
  /**
   *
   * @type {string}
   * @memberof PmtConfig
   */
  'engine'?: PmtConfigEngineEnum;
  /**
   *
   * @type {string}
   * @memberof PmtConfig
   */
  'model'?: PmtConfigModelEnum;
}

export const PmtConfigEngineEnum = {
  Scout9: 'scout9'
} as const;

export type PmtConfigEngineEnum = typeof PmtConfigEngineEnum[keyof typeof PmtConfigEngineEnum];
export const PmtConfigModelEnum = {
  _10: 'orin-1.0',
  _20Preview: 'orin-2.0-preview'
} as const;

export type PmtConfigModelEnum = typeof PmtConfigModelEnum[keyof typeof PmtConfigModelEnum];

/**
 * When audio or transcript files are provided, this will return the PMT (persona model transformer) status of the audio/transcript files
 * @export
 * @interface PmtRatings
 */
export interface PmtRatings {
  /**
   *
   * @type {Rating}
   * @memberof PmtRatings
   */
  'audio'?: Rating;
  /**
   *
   * @type {Rating}
   * @memberof PmtRatings
   */
  'transcripts'?: Rating;
}
/**
 * Purchase a phone number subscription for an agent
 * @export
 * @interface PurchasePhoneRequest
 */
export interface PurchasePhoneRequest {
  /**
   * The agent\'s id
   * @type {string}
   * @memberof PurchasePhoneRequest
   */
  '$agent'?: string;
  /**
   * If true, the phone number will be purchased for an annual subscription
   * @type {boolean}
   * @memberof PurchasePhoneRequest
   */
  'annual'?: boolean;
  /**
   * The area code of the phone number to purchase
   * @type {number}
   * @memberof PurchasePhoneRequest
   */
  'areaCode'?: number;
}
/**
 *
 * @export
 * @interface PurchasePhoneResponse
 */
export interface PurchasePhoneResponse {
  /**
   * the phone number that was purchased
   * @type {string}
   * @memberof PurchasePhoneResponse
   */
  'phoneNumber': string;
  /**
   * Internal identifier for the phone number
   * @type {string}
   * @memberof PurchasePhoneResponse
   */
  'sid': string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const PurposeEnum = {
  Context: 'context',
  AgentAudio: 'agent-audio',
  AgentTranscript: 'agent-transcript'
} as const;

export type PurposeEnum = typeof PurposeEnum[keyof typeof PurposeEnum];


/**
 *
 * @export
 * @interface Rating
 */
export interface Rating {
  /**
   * The rating of the audio file out of 100, only provided if audio/transcripts are provided
   * @type {number}
   * @memberof Rating
   */
  'rating': number;
  /**
   * classification of the rating
   * @type {string}
   * @memberof Rating
   */
  'name': string;
}
/**
 *
 * @export
 * @interface RegexCondition
 */
export interface RegexCondition {
  /**
   *
   * @type {string}
   * @memberof RegexCondition
   */
  'path': string;
  /**
   *
   * @type {string}
   * @memberof RegexCondition
   */
  'regex': string;
  /**
   *
   * @type {boolean}
   * @memberof RegexCondition
   */
  'external'?: boolean;
}
/**
 *
 * @export
 * @interface ScheduleCreateRequest
 */
export interface ScheduleCreateRequest {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduleCreateRequest
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduleCreateRequest
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduleCreateRequest
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * User for this conversation
   * @type {string}
   * @memberof ScheduleCreateRequest
   */
  '$user': string;
  /**
   * Customer this conversation is with (use $user instead)
   * @type {string}
   * @memberof ScheduleCreateRequest
   * @deprecated
   */
  '$customer'?: string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ScheduleCreateRequest
   */
  'environment': ConversationEnvironment;
  /**
   * Whether this conversation is a test or not
   * @type {boolean}
   * @memberof ScheduleCreateRequest
   */
  'test'?: boolean;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduleCreateRequest
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduleCreateRequest
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduleCreateRequest
   */
  'initialMessageHtml'?: string | null;
  /**
   * Group this conversation is in
   * @type {string}
   * @memberof ScheduleCreateRequest
   */
  '$group'?: string;
}


/**
 *
 * @export
 * @interface ScheduleCreateResponse
 */
export interface ScheduleCreateResponse {
  /**
   *
   * @type {boolean}
   * @memberof ScheduleCreateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ScheduleCreateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ScheduleCreateResponse
   */
  'id': string;
  /**
   * ISO Time the initial message has been sent
   * @type {string}
   * @memberof ScheduleCreateResponse
   */
  'sent'?: string;
}
/**
 *
 * @export
 * @interface ScheduleCreateResponseAllOf
 */
export interface ScheduleCreateResponseAllOf {
  /**
   * ISO Time the initial message has been sent
   * @type {string}
   * @memberof ScheduleCreateResponseAllOf
   */
  'sent'?: string;
}
/**
 *
 * @export
 * @interface ScheduleGetResponse
 */
export interface ScheduleGetResponse {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduleGetResponse
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduleGetResponse
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * User for this conversation
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  '$user': string;
  /**
   * Customer this conversation is with (use $user instead)
   * @type {string}
   * @memberof ScheduleGetResponse
   * @deprecated
   */
  '$customer'?: string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ScheduleGetResponse
   */
  'environment': ConversationEnvironment;
  /**
   * Whether this conversation is a test or not
   * @type {boolean}
   * @memberof ScheduleGetResponse
   */
  'test'?: boolean;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  'initialMessageHtml'?: string | null;
  /**
   * Group this conversation is in
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  '$group'?: string;
  /**
   * The client web url of the conversation
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  'clientWebUrl'?: string;
  /**
   * The agent web url of the conversation (requires phone two-factor authentication)
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  'agentWebUrl'?: string;
  /**
   * The agent test web url of the conversation, used for testing the conversation without notifying the customer
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  'agentTestWebUrl'?: string;
}


/**
 *
 * @export
 * @interface ScheduleGroupCreateRequest
 */
export interface ScheduleGroupCreateRequest {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduleGroupCreateRequest
   */
  '$agent'?: string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduleGroupCreateRequest
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduleGroupCreateRequest
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduleGroupCreateRequest
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduleGroupCreateRequest
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduleGroupCreateRequest
   */
  'initialMessageHtml'?: string | null;
  /**
   * The delay in milliseconds between each customer, defaults to 15000 (15 seconds)
   * @type {number}
   * @memberof ScheduleGroupCreateRequest
   */
  'delay'?: number;
  /**
   *
   * @type {ScheduleGroupCreateRequestAllOfCGroup}
   * @memberof ScheduleGroupCreateRequest
   */
  '$cGroup': ScheduleGroupCreateRequestAllOfCGroup;
}
/**
 *
 * @export
 * @interface ScheduleGroupCreateRequestAllOf
 */
export interface ScheduleGroupCreateRequestAllOf {
  /**
   *
   * @type {ScheduleGroupCreateRequestAllOfCGroup}
   * @memberof ScheduleGroupCreateRequestAllOf
   */
  '$cGroup': ScheduleGroupCreateRequestAllOfCGroup;
}
/**
 * @type ScheduleGroupCreateRequestAllOfCGroup
 * @export
 */
export type ScheduleGroupCreateRequestAllOfCGroup = CustomerGroup | string;

/**
 *
 * @export
 * @interface ScheduleGroupCreateResponse
 */
export interface ScheduleGroupCreateResponse {
  /**
   *
   * @type {boolean}
   * @memberof ScheduleGroupCreateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ScheduleGroupCreateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ScheduleGroupCreateResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface ScheduleGroupGetResponse
 */
export interface ScheduleGroupGetResponse {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  '$agent'?: string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduleGroupGetResponse
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduleGroupGetResponse
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  'initialMessageHtml'?: string | null;
  /**
   * The delay in milliseconds between each customer, defaults to 15000 (15 seconds)
   * @type {number}
   * @memberof ScheduleGroupGetResponse
   */
  'delay'?: number;
  /**
   * The ID of the scheduled conversation group
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  '$id': string;
  /**
   * ISO Time the initial message has been sent
   * @type {boolean}
   * @memberof ScheduleGroupGetResponse
   */
  'sent'?: boolean;
  /**
   * The ID of the group the customers belong to
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  '$cGroup'?: string;
}
/**
 *
 * @export
 * @interface ScheduleGroupGetResponseAllOf
 */
export interface ScheduleGroupGetResponseAllOf {
  /**
   * The ID of the scheduled conversation group
   * @type {string}
   * @memberof ScheduleGroupGetResponseAllOf
   */
  '$id': string;
  /**
   * ISO Time the initial message has been sent
   * @type {boolean}
   * @memberof ScheduleGroupGetResponseAllOf
   */
  'sent'?: boolean;
  /**
   * The ID of the group the customers belong to
   * @type {string}
   * @memberof ScheduleGroupGetResponseAllOf
   */
  '$cGroup'?: string;
}
/**
 *
 * @export
 * @interface ScheduleGroupRemoveResponse
 */
export interface ScheduleGroupRemoveResponse {
  /**
   *
   * @type {boolean}
   * @memberof ScheduleGroupRemoveResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ScheduleGroupRemoveResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ScheduleGroupRemoveResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface ScheduleGroupUpdateRequest
 */
export interface ScheduleGroupUpdateRequest {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduleGroupUpdateRequest
   */
  '$agent'?: string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduleGroupUpdateRequest
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduleGroupUpdateRequest
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduleGroupUpdateRequest
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduleGroupUpdateRequest
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduleGroupUpdateRequest
   */
  'initialMessageHtml'?: string | null;
  /**
   * The delay in milliseconds between each customer, defaults to 15000 (15 seconds)
   * @type {number}
   * @memberof ScheduleGroupUpdateRequest
   */
  'delay'?: number;
  /**
   *
   * @type {ScheduleGroupCreateRequestAllOfCGroup}
   * @memberof ScheduleGroupUpdateRequest
   */
  '$cGroup'?: ScheduleGroupCreateRequestAllOfCGroup;
  /**
   * The ID of the scheduled conversation group to update
   * @type {string}
   * @memberof ScheduleGroupUpdateRequest
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ScheduleGroupUpdateRequestAllOf
 */
export interface ScheduleGroupUpdateRequestAllOf {
  /**
   *
   * @type {ScheduleGroupCreateRequestAllOfCGroup}
   * @memberof ScheduleGroupUpdateRequestAllOf
   */
  '$cGroup'?: ScheduleGroupCreateRequestAllOfCGroup;
  /**
   * The ID of the scheduled conversation group to update
   * @type {string}
   * @memberof ScheduleGroupUpdateRequestAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ScheduleGroupUpdateResponse
 */
export interface ScheduleGroupUpdateResponse {
  /**
   *
   * @type {boolean}
   * @memberof ScheduleGroupUpdateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ScheduleGroupUpdateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ScheduleGroupUpdateResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface ScheduleRemoveResponse
 */
export interface ScheduleRemoveResponse {
  /**
   *
   * @type {boolean}
   * @memberof ScheduleRemoveResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ScheduleRemoveResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ScheduleRemoveResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface ScheduleUpdateRequest
 */
export interface ScheduleUpdateRequest {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduleUpdateRequest
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduleUpdateRequest
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * User for this conversation
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  '$user': string;
  /**
   * Customer this conversation is with (use $user instead)
   * @type {string}
   * @memberof ScheduleUpdateRequest
   * @deprecated
   */
  '$customer'?: string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ScheduleUpdateRequest
   */
  'environment': ConversationEnvironment;
  /**
   * Whether this conversation is a test or not
   * @type {boolean}
   * @memberof ScheduleUpdateRequest
   */
  'test'?: boolean;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  'initialMessageHtml'?: string | null;
  /**
   * Group this conversation is in
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  '$group'?: string;
  /**
   * The ID of the scheduled conversation to update
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  '$id'?: string;
}


/**
 *
 * @export
 * @interface ScheduleUpdateRequestAllOf
 */
export interface ScheduleUpdateRequestAllOf {
  /**
   * The ID of the scheduled conversation to update
   * @type {string}
   * @memberof ScheduleUpdateRequestAllOf
   */
  '$id'?: string;
}
/**
 *
 * @export
 * @interface ScheduleUpdateResponse
 */
export interface ScheduleUpdateResponse {
  /**
   *
   * @type {boolean}
   * @memberof ScheduleUpdateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ScheduleUpdateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ScheduleUpdateResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface ScheduledConversation
 */
export interface ScheduledConversation {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduledConversation
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduledConversation
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduledConversation
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * User for this conversation
   * @type {string}
   * @memberof ScheduledConversation
   */
  '$user': string;
  /**
   * Customer this conversation is with (use $user instead)
   * @type {string}
   * @memberof ScheduledConversation
   * @deprecated
   */
  '$customer'?: string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ScheduledConversation
   */
  'environment': ConversationEnvironment;
  /**
   * Whether this conversation is a test or not
   * @type {boolean}
   * @memberof ScheduledConversation
   */
  'test'?: boolean;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduledConversation
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduledConversation
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduledConversation
   */
  'initialMessageHtml'?: string | null;
  /**
   * Group this conversation is in
   * @type {string}
   * @memberof ScheduledConversation
   */
  '$group'?: string;
}


/**
 *
 * @export
 * @interface ScheduledConversationAllOf
 */
export interface ScheduledConversationAllOf {
  /**
   * Group this conversation is in
   * @type {string}
   * @memberof ScheduledConversationAllOf
   */
  '$group'?: string;
}
/**
 *
 * @export
 * @interface ScheduledConversationGroup
 */
export interface ScheduledConversationGroup {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduledConversationGroup
   */
  '$agent'?: string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduledConversationGroup
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduledConversationGroup
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduledConversationGroup
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduledConversationGroup
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduledConversationGroup
   */
  'initialMessageHtml'?: string | null;
  /**
   * The delay in milliseconds between each customer, defaults to 15000 (15 seconds)
   * @type {number}
   * @memberof ScheduledConversationGroup
   */
  'delay'?: number;
}
/**
 *
 * @export
 * @interface ScheduledConversationGroupAllOf
 */
export interface ScheduledConversationGroupAllOf {
  /**
   * The delay in milliseconds between each customer, defaults to 15000 (15 seconds)
   * @type {number}
   * @memberof ScheduledConversationGroupAllOf
   */
  'delay'?: number;
}
/**
 * The `File` object represents a document that has been uploaded to Scout9.
 * @export
 * @interface Scout9File
 */
export interface Scout9File {
  /**
   * The file identifier, which can be referenced in the API endpoints.
   * @type {string}
   * @memberof Scout9File
   */
  'id': string;
  /**
   * The object type, which is always \"file\".
   * @type {string}
   * @memberof Scout9File
   */
  'object': string;
  /**
   * The size of the file in bytes.
   * @type {number}
   * @memberof Scout9File
   */
  'bytes': number;
  /**
   * The unix timestamp for when the file was created.
   * @type {number}
   * @memberof Scout9File
   */
  'created_at': number;
  /**
   * The name of the file.
   * @type {string}
   * @memberof Scout9File
   */
  'filename': string;
  /**
   * The intended purpose of the file.
   * @type {string}
   * @memberof Scout9File
   */
  'purpose': string;
  /**
   * The current status of the file, which can be either `uploaded`, `processed`, `pending`, `error`, `deleting` or `deleted`.
   * @type {string}
   * @memberof Scout9File
   */
  'status'?: string;
  /**
   * Additional details about the status of the file. If the file is in the `error` state, this will include a message describing the error.
   * @type {string}
   * @memberof Scout9File
   */
  'status_details'?: string | null;
}
/**
 *
 * @export
 * @interface Scout9ProjectConfig
 */
export interface Scout9ProjectConfig {
  /**
   *
   * @type {LlmConfig}
   * @memberof Scout9ProjectConfig
   */
  'llm': LlmConfig;
  /**
   *
   * @type {PmtConfig}
   * @memberof Scout9ProjectConfig
   */
  'pmt': PmtConfig;
}
/**
 *
 * @export
 * @interface UpdateAgentRequest
 */
export interface UpdateAgentRequest {
  /**
   * The ID of the agent to update
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  '$id': string;
  /**
   * Agent first name
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'firstName'?: string;
  /**
   * Agent last name
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'lastName'?: string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof UpdateAgentRequest
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'title'?: string;
  /**
   *
   * @type {AgentContext}
   * @memberof UpdateAgentRequest
   */
  'context'?: AgentContext;
}
/**
 *
 * @export
 * @interface UpdateAgentRequestAllOf
 */
export interface UpdateAgentRequestAllOf {
  /**
   * The ID of the agent to update
   * @type {string}
   * @memberof UpdateAgentRequestAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateAgentResponse
 */
export interface UpdateAgentResponse {
  /**
   *
   * @type {boolean}
   * @memberof UpdateAgentResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof UpdateAgentResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof UpdateAgentResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface UpdateAgentsRequest
 */
export interface UpdateAgentsRequest {
  /**
   *
   * @type {Array<UpdateAgentsRequestAgentsInner>}
   * @memberof UpdateAgentsRequest
   */
  'agents'?: Array<UpdateAgentsRequestAgentsInner>;
}
/**
 *
 * @export
 * @interface UpdateAgentsRequestAgentsInner
 */
export interface UpdateAgentsRequestAgentsInner {
  /**
   * Agent first name
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'firstName': string;
  /**
   * Agent last name
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'lastName': string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'title'?: string;
  /**
   *
   * @type {AgentContext}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'context'?: AgentContext;
  /**
   * The ID of the agent
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateAgentsRequestAgentsInnerAllOf
 */
export interface UpdateAgentsRequestAgentsInnerAllOf {
  /**
   * The ID of the agent
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateAgentsResponse
 */
export interface UpdateAgentsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof UpdateAgentsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof UpdateAgentsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerGroupRequest
 */
export interface UpdateCustomerGroupRequest {
  /**
   * The name of the customer group
   * @type {string}
   * @memberof UpdateCustomerGroupRequest
   */
  'name': string;
  /**
   * The description of the customer group
   * @type {string}
   * @memberof UpdateCustomerGroupRequest
   */
  'description'?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof UpdateCustomerGroupRequest
   */
  'metadata'?: { [key: string]: any; };
  /**
   *
   * @type {Array<CustomerGroupRecord>}
   * @memberof UpdateCustomerGroupRequest
   */
  'customers': Array<CustomerGroupRecord>;
  /**
   * The ID of the CustomerGroup
   * @type {string}
   * @memberof UpdateCustomerGroupRequest
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerGroupRequestAllOf
 */
export interface UpdateCustomerGroupRequestAllOf {
  /**
   * The ID of the CustomerGroup
   * @type {string}
   * @memberof UpdateCustomerGroupRequestAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerGroupResponse
 */
export interface UpdateCustomerGroupResponse {
  /**
   *
   * @type {boolean}
   * @memberof UpdateCustomerGroupResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof UpdateCustomerGroupResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof UpdateCustomerGroupResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerGroupsRequest
 */
export interface UpdateCustomerGroupsRequest {
  /**
   *
   * @type {Array<ListCustomerGroupsResponseInner>}
   * @memberof UpdateCustomerGroupsRequest
   */
  'CustomerGroups'?: Array<ListCustomerGroupsResponseInner>;
}
/**
 *
 * @export
 * @interface UpdateCustomerGroupsResponse
 */
export interface UpdateCustomerGroupsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof UpdateCustomerGroupsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof UpdateCustomerGroupsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerRequest
 */
export interface UpdateCustomerRequest {
  /**
   * The customers first name
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'firstName'?: string;
  /**
   * The customers last name
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'lastName'?: string;
  /**
   * The customers full name
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'name': string;
  /**
   * The customers email address
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'email'?: string | null;
  /**
   * The customers phone number
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'phone'?: string | null;
  /**
   * The customers profile image
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'img'?: string | null;
  /**
   * The customers neighborhood
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'neighborhood'?: string | null;
  /**
   * The customers city
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'city'?: string | null;
  /**
   * The customers 2-letter country code
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'country'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'line1'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'line2'?: string | null;
  /**
   * The customers postal code
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'postal_code'?: string | null;
  /**
   * The customers state, county, province, or region
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'state'?: string | null;
  /**
   * The customers town (only used in Japan)
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'town'?: string | null;
  /**
   *
   * @type {BlockInfo}
   * @memberof UpdateCustomerRequest
   */
  'blocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof UpdateCustomerRequest
   */
  'phoneBlocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof UpdateCustomerRequest
   */
  'emailBlocked'?: BlockInfo;
  /**
   * The date the customer joined the business
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'joined'?: string | null;
  /**
   * The customers stripe ID
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'stripe'?: string | null;
  /**
   * The customers stripe ID in the dev environment
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'stripeDev'?: string | null;
  /**
   * The ID of the customer
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerRequestAllOf
 */
export interface UpdateCustomerRequestAllOf {
  /**
   * The ID of the customer
   * @type {string}
   * @memberof UpdateCustomerRequestAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateCustomersRequest
 */
export interface UpdateCustomersRequest {
  /**
   *
   * @type {Array<ListCustomersResponseInner>}
   * @memberof UpdateCustomersRequest
   */
  'customers': Array<ListCustomersResponseInner>;
}
/**
 *
 * @export
 * @interface UpdateCustomersResponse
 */
export interface UpdateCustomersResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof UpdateCustomersResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof UpdateCustomersResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface WorkflowEvent
 */
export interface WorkflowEvent {
  /**
   *
   * @type {Array<Message>}
   * @memberof WorkflowEvent
   */
  'messages': Array<Message>;
  /**
   *
   * @type {Message}
   * @memberof WorkflowEvent
   */
  'message'?: Message;
  /**
   *
   * @type {Conversation}
   * @memberof WorkflowEvent
   */
  'conversation': Conversation;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof WorkflowEvent
   */
  'context': { [key: string]: any; };
  /**
   *
   * @type {Agent}
   * @memberof WorkflowEvent
   */
  'agent': Agent;
  /**
   *
   * @type {Customer}
   * @memberof WorkflowEvent
   */
  'customer': Customer;
  /**
   *
   * @type {WorkflowEventIntent}
   * @memberof WorkflowEvent
   */
  'intent': WorkflowEventIntent;
  /**
   * The number of times the workflow has been triggered without a response
   * @type {number}
   * @memberof WorkflowEvent
   */
  'stagnationCount': number;
}
/**
 * @type WorkflowEventIntent
 * @export
 */
export type WorkflowEventIntent = WorkflowEventIntentOneOf | string;

/**
 *
 * @export
 * @interface WorkflowEventIntentOneOf
 */
export interface WorkflowEventIntentOneOf {
  /**
   *
   * @type {string}
   * @memberof WorkflowEventIntentOneOf
   */
  'current'?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof WorkflowEventIntentOneOf
   */
  'flow'?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof WorkflowEventIntentOneOf
   */
  'initial'?: string;
}
/**
 * @type WorkflowResponse
 * @export
 */
export type WorkflowResponse = Array<WorkflowResponseSlot> | WorkflowResponseSlot;

/**
 *
 * @export
 * @interface WorkflowResponseSlot
 */
export interface WorkflowResponseSlot {
  /**
   *
   * @type {WorkflowResponseSlotForward}
   * @memberof WorkflowResponseSlot
   */
  'forward'?: WorkflowResponseSlotForward;
  /**
   *
   * @type {WorkflowResponseSlotInstructions}
   * @memberof WorkflowResponseSlot
   */
  'instructions'?: WorkflowResponseSlotInstructions;
  /**
   *
   * @type {Array<string>}
   * @memberof WorkflowResponseSlot
   */
  'removeInstructions'?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof WorkflowResponseSlot
   */
  'message'?: string;
  /**
   *
   * @type {number}
   * @memberof WorkflowResponseSlot
   */
  'secondsDelay'?: number;
  /**
   *
   * @type {number}
   * @memberof WorkflowResponseSlot
   */
  'scheduled'?: number;
  /**
   *
   * @type {object}
   * @memberof WorkflowResponseSlot
   */
  'contextUpsert'?: object;
  /**
   *
   * @type {boolean}
   * @memberof WorkflowResponseSlot
   */
  'resetIntent'?: boolean;
}
/**
 * @type WorkflowResponseSlotForward
 * @export
 */
export type WorkflowResponseSlotForward = WorkflowResponseSlotForwardOneOf | boolean | string;

/**
 *
 * @export
 * @interface WorkflowResponseSlotForwardOneOf
 */
export interface WorkflowResponseSlotForwardOneOf {
  /**
   *
   * @type {string}
   * @memberof WorkflowResponseSlotForwardOneOf
   */
  'to'?: string;
  /**
   *
   * @type {string}
   * @memberof WorkflowResponseSlotForwardOneOf
   */
  'mode'?: WorkflowResponseSlotForwardOneOfModeEnum;
}

export const WorkflowResponseSlotForwardOneOfModeEnum = {
  AfterReply: 'after-reply',
  Immediately: 'immediately'
} as const;

export type WorkflowResponseSlotForwardOneOfModeEnum = typeof WorkflowResponseSlotForwardOneOfModeEnum[keyof typeof WorkflowResponseSlotForwardOneOfModeEnum];

/**
 * @type WorkflowResponseSlotInstructions
 * @export
 */
export type WorkflowResponseSlotInstructions = Array<Instruction> | Array<string> | Instruction | string;


/**
 * NoopApi - axios parameter creator
 * @export
 */
export const NoopApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary This is used for the generator to include PurposeEnum, because for whatever reason, query params are not included in the generator.
     * @param {PingRequest} pingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping: async (pingRequest: PingRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'pingRequest' is not null or undefined
      assertParamExists('ping', 'pingRequest', pingRequest)
      const localVarPath = `/v1-utils-ping`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(pingRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  }
};

/**
 * NoopApi - functional programming interface
 * @export
 */
export const NoopApiFp = function(configuration?: Configuration) {
  const localVarAxiosParamCreator = NoopApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary This is used for the generator to include PurposeEnum, because for whatever reason, query params are not included in the generator.
     * @param {PingRequest} pingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async ping(pingRequest: PingRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PingRequest>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.ping(pingRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  }
};

/**
 * NoopApi - factory interface
 * @export
 */
export const NoopApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = NoopApiFp(configuration)
  return {
    /**
     *
     * @summary This is used for the generator to include PurposeEnum, because for whatever reason, query params are not included in the generator.
     * @param {PingRequest} pingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    ping(pingRequest: PingRequest, options?: any): AxiosPromise<PingRequest> {
      return localVarFp.ping(pingRequest, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * NoopApi - object-oriented interface
 * @export
 * @class NoopApi
 * @extends {BaseAPI}
 */
export class NoopApi extends BaseAPI {
  /**
   *
   * @summary This is used for the generator to include PurposeEnum, because for whatever reason, query params are not included in the generator.
   * @param {PingRequest} pingRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof NoopApi
   */
  public ping(pingRequest: PingRequest, options?: AxiosRequestConfig) {
    return NoopApiFp(this.configuration).ping(pingRequest, options).then((request) => request(this.axios, this.basePath));
  }
}


/**
 * Scout9Api - axios parameter creator
 * @export
 */
export const Scout9ApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Create a new entity
     * @param {string} type
     * @param {string} id The unique identifier of the entity
     * @param {EntityData} entityData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addEntity: async (type: string, id: string, entityData: EntityData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists('addEntity', 'type', type)
      // verify required parameter 'id' is not null or undefined
      assertParamExists('addEntity', 'id', id)
      // verify required parameter 'entityData' is not null or undefined
      assertParamExists('addEntity', 'entityData', entityData)
      const localVarPath = `/v1-entity/{type}/{id}`
        .replace(`{${"type"}}`, encodeURIComponent(String(type)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(entityData, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agent: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('agent', 'id', id)
      const localVarPath = `/v1-agent`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('agentDelete', 'id', id)
      const localVarPath = `/v1-agent`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Registers a new agent
     * @param {CreateAgentRequest} createAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentRegister: async (createAgentRequest: CreateAgentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createAgentRequest' is not null or undefined
      assertParamExists('agentRegister', 'createAgentRequest', createAgentRequest)
      const localVarPath = `/v1-agent`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createAgentRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a agent
     * @param {UpdateAgentRequest} updateAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentUpdate: async (updateAgentRequest: UpdateAgentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateAgentRequest' is not null or undefined
      assertParamExists('agentUpdate', 'updateAgentRequest', updateAgentRequest)
      const localVarPath = `/v1-agent`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateAgentRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all or specific set of agents
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agents: async (q?: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-agents`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates new agents
     * @param {CreateAgentsRequest} createAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentsCreate: async (createAgentsRequest: CreateAgentsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createAgentsRequest' is not null or undefined
      assertParamExists('agentsCreate', 'createAgentsRequest', createAgentsRequest)
      const localVarPath = `/v1-agents`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createAgentsRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes multiple agents
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentsDelete: async (id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-agents`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates multiple agents
     * @param {UpdateAgentsRequest} updateAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentsUpdate: async (updateAgentsRequest: UpdateAgentsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateAgentsRequest' is not null or undefined
      assertParamExists('agentsUpdate', 'updateAgentsRequest', updateAgentsRequest)
      const localVarPath = `/v1-agents`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateAgentsRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Natural language prompt to resolve a context value derived from the conversation.
     * @param {MacroContextInput} macroContextInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    captureContext: async (macroContextInput: MacroContextInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'macroContextInput' is not null or undefined
      assertParamExists('captureContext', 'macroContextInput', macroContextInput)
      const localVarPath = `/v1-utils-macros-context`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(macroContextInput, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the current project configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    config: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-config`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a conversation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversation: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('conversation', 'id', id)
      const localVarPath = `/v1-conversation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a conversation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationContext: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('conversationContext', 'id', id)
      const localVarPath = `/v1-conversationContext`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a conversation
     * @param {ConversationContextUpdateRequest} conversationContextUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationContextUpdate: async (conversationContextUpdateRequest: ConversationContextUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'conversationContextUpdateRequest' is not null or undefined
      assertParamExists('conversationContextUpdate', 'conversationContextUpdateRequest', conversationContextUpdateRequest)
      const localVarPath = `/v1-conversationContext`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(conversationContextUpdateRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a new conversation
     * @param {ConversationCreateRequest} conversationCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationCreate: async (conversationCreateRequest: ConversationCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'conversationCreateRequest' is not null or undefined
      assertParamExists('conversationCreate', 'conversationCreateRequest', conversationCreateRequest)
      const localVarPath = `/v1-conversation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(conversationCreateRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('conversationDelete', 'id', id)
      const localVarPath = `/v1-conversation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a conversation
     * @param {ConversationUpdateRequest} conversationUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationUpdate: async (conversationUpdateRequest: ConversationUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'conversationUpdateRequest' is not null or undefined
      assertParamExists('conversationUpdate', 'conversationUpdateRequest', conversationUpdateRequest)
      const localVarPath = `/v1-conversation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(conversationUpdateRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all or specific set of conversations
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversations: async (q?: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-conversations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a customer
     * @param {string} idOrEmailOrPhone Either customers id, phone number or email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customer: async (idOrEmailOrPhone: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'idOrEmailOrPhone' is not null or undefined
      assertParamExists('customer', 'idOrEmailOrPhone', idOrEmailOrPhone)
      const localVarPath = `/v1-customer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (idOrEmailOrPhone !== undefined) {
        localVarQueryParameter['idOrEmailOrPhone'] = idOrEmailOrPhone;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates a new customer
     * @param {Customer} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerCreate: async (body: Customer, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('customerCreate', 'body', body)
      const localVarPath = `/v1-customer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a customer
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('customerDelete', 'id', id)
      const localVarPath = `/v1-customer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('customerGroup', 'id', id)
      const localVarPath = `/v1-customerGroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates a new customer group
     * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupCreate: async (createCustomerGroupRequest: CreateCustomerGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createCustomerGroupRequest' is not null or undefined
      assertParamExists('customerGroupCreate', 'createCustomerGroupRequest', createCustomerGroupRequest)
      const localVarPath = `/v1-customerGroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createCustomerGroupRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('customerGroupDelete', 'id', id)
      const localVarPath = `/v1-customerGroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates a customer group
     * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupUpdate: async (updateCustomerGroupRequest: UpdateCustomerGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateCustomerGroupRequest' is not null or undefined
      assertParamExists('customerGroupUpdate', 'updateCustomerGroupRequest', updateCustomerGroupRequest)
      const localVarPath = `/v1-customerGroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerGroupRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all or specific set of customer groups
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroups: async (q?: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-customerGroups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates new customer groups
     * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupsCreate: async (createCustomerGroupsRequest: CreateCustomerGroupsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createCustomerGroupsRequest' is not null or undefined
      assertParamExists('customerGroupsCreate', 'createCustomerGroupsRequest', createCustomerGroupsRequest)
      const localVarPath = `/v1-customerGroups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createCustomerGroupsRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes multiple customer groups
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupsDelete: async (id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-customerGroups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates multiple customer groups
     * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupsUpdate: async (updateCustomerGroupsRequest: UpdateCustomerGroupsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateCustomerGroupsRequest' is not null or undefined
      assertParamExists('customerGroupsUpdate', 'updateCustomerGroupsRequest', updateCustomerGroupsRequest)
      const localVarPath = `/v1-customerGroups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerGroupsRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates a customer
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerUpdate: async (updateCustomerRequest: UpdateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateCustomerRequest' is not null or undefined
      assertParamExists('customerUpdate', 'updateCustomerRequest', updateCustomerRequest)
      const localVarPath = `/v1-customer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all or specific set of customers
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customers: async (q?: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-customers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates new customers
     * @param {CreateCustomersRequest} createCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCreate: async (createCustomersRequest: CreateCustomersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createCustomersRequest' is not null or undefined
      assertParamExists('customersCreate', 'createCustomersRequest', createCustomersRequest)
      const localVarPath = `/v1-customers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createCustomersRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes multiple customers
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersDelete: async (id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-customers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates multiple customers
     * @param {UpdateCustomersRequest} updateCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersUpdate: async (updateCustomersRequest: UpdateCustomersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateCustomersRequest' is not null or undefined
      assertParamExists('customersUpdate', 'updateCustomersRequest', updateCustomersRequest)
      const localVarPath = `/v1-customers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateCustomersRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes an entity with the specified type and ID.
     * @summary Delete an entity
     * @param {string} type
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEntity: async (type: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists('deleteEntity', 'type', type)
      // verify required parameter 'id' is not null or undefined
      assertParamExists('deleteEntity', 'id', id)
      const localVarPath = `/v1-entity/{type}/{id}`
        .replace(`{${"type"}}`, encodeURIComponent(String(type)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Natural language prompt to resolve to a boolean value.
     * @param {MacroDidInput} macroDidInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    did: async (macroDidInput: MacroDidInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'macroDidInput' is not null or undefined
      assertParamExists('did', 'macroDidInput', macroDidInput)
      const localVarPath = `/v1-utils-macros-did`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(macroDidInput, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Natural language prompt to resolve to a boolean value in relation to the given immediate message.
     * @param {MacroDoesInput} macroDoesInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    does: async (macroDoesInput: MacroDoesInput, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'macroDoesInput' is not null or undefined
      assertParamExists('does', 'macroDoesInput', macroDoesInput)
      const localVarPath = `/v1-utils-macros-does`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(macroDoesInput, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get an entity by type and ID
     * @param {string} type The type of the entity to fetch
     * @param {string} id The unique identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    entity: async (type: string, id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists('entity', 'type', type)
      // verify required parameter 'id' is not null or undefined
      assertParamExists('entity', 'id', id)
      const localVarPath = `/v1-entity/{type}/{id}`
        .replace(`{${"type"}}`, encodeURIComponent(String(type)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns a file
     * @param {string} purpose File categorical purpose
     * @param {string} [entity] File entity id
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    file: async (purpose: string, entity?: string, agent?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'purpose' is not null or undefined
      assertParamExists('file', 'purpose', purpose)
      const localVarPath = `/v1-utils-file`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (purpose !== undefined) {
        localVarQueryParameter['purpose'] = purpose;
      }

      if (entity !== undefined) {
        localVarQueryParameter['entity'] = entity;
      }

      if (agent !== undefined) {
        localVarQueryParameter['agent'] = agent;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a file
     * @param {string} purpose File categorical purpose
     * @param {string} entity File entity id
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileRemove: async (purpose: string, entity: string, agent?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'purpose' is not null or undefined
      assertParamExists('fileRemove', 'purpose', purpose)
      // verify required parameter 'entity' is not null or undefined
      assertParamExists('fileRemove', 'entity', entity)
      const localVarPath = `/v1-utils-file`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (purpose !== undefined) {
        localVarQueryParameter['purpose'] = purpose;
      }

      if (entity !== undefined) {
        localVarQueryParameter['entity'] = entity;
      }

      if (agent !== undefined) {
        localVarQueryParameter['agent'] = agent;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
     * @param {File} file
     * @param {PurposeEnum} [purpose]
     * @param {string} [context] Additional information about this file
     * @param {string} [entity] The entity id, if not provided the entity id becomes the provided file name
     * @param {string} [$agent] The agent that this file belongs to. Only used for entity.audio and entity.transcript files.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileUpload: async (file: File, purpose?: PurposeEnum, context?: string, entity?: string, $agent?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists('fileUpload', 'file', file)
      const localVarPath = `/v1-utils-file`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


      if (file !== undefined) {
        localVarFormParams.append('file', file as any);
      }

      if (purpose !== undefined) {
        localVarFormParams.append('purpose', new Blob([JSON.stringify(purpose)], { type: "application/json", }));
      }

      if (context !== undefined) {
        localVarFormParams.append('context', context as any);
      }

      if (entity !== undefined) {
        localVarFormParams.append('entity', entity as any);
      }

      if ($agent !== undefined) {
        localVarFormParams.append('$agent', $agent as any);
      }


      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns a list of files that belong to the user\'s organization.
     * @param {string} purpose File categorical purpose
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    files: async (purpose: string, agent?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'purpose' is not null or undefined
      assertParamExists('files', 'purpose', purpose)
      const localVarPath = `/v1-utils-files`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (purpose !== undefined) {
        localVarQueryParameter['purpose'] = purpose;
      }

      if (agent !== undefined) {
        localVarQueryParameter['agent'] = agent;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Forwards a locked conversation to agent
     * @summary forwards a locked conversation to agent
     * @param {ForwardRequest} forwardRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forward: async (forwardRequest: ForwardRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'forwardRequest' is not null or undefined
      assertParamExists('forward', 'forwardRequest', forwardRequest)
      const localVarPath = `/v1-forward`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(forwardRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
     * @summary Generate a message from conversation
     * @param {GenerateRequest} generateRequest
     * @param {string} [convo] In relation to which conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generate: async (generateRequest: GenerateRequest, convo?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'generateRequest' is not null or undefined
      assertParamExists('generate', 'generateRequest', generateRequest)
      const localVarPath = `/v1-generate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (convo !== undefined) {
        localVarQueryParameter['convo'] = convo;
      }



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(generateRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Returns log data for a given range, specified by start and end Unix timestamps.
     * @summary Retrieve platform run time logs
     * @param {number} [start]
     * @param {number} [end]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logs: async (start?: number, end?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-utils-platform-logs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (start !== undefined) {
        localVarQueryParameter['start'] = start;
      }

      if (end !== undefined) {
        localVarQueryParameter['end'] = end;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
     * @summary Create and send message
     * @param {MessageCreateRequest} messageCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    message: async (messageCreateRequest: MessageCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'messageCreateRequest' is not null or undefined
      assertParamExists('message', 'messageCreateRequest', messageCreateRequest)
      const localVarPath = `/v1-messages`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(messageCreateRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all messages from a conversation
     * @param {string} id id of entity to query
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    messages: async (id: string, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('messages', 'id', id)
      const localVarPath = `/v1-messages`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the results of a bulk API operation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operation: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('operation', 'id', id)
      const localVarPath = `/v1-utils-operation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all or specific set of bulk API operations
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operations: async (q?: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-utils-operations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Parses a message\'s custom context relevant to your organization. This is useful for extracting information from a message to drive your auto reply workflows.
     * @summary Parse a message\'s custom context relevant to your organization
     * @param {ParseRequest} parseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parse: async (parseRequest: ParseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'parseRequest' is not null or undefined
      assertParamExists('parse', 'parseRequest', parseRequest)
      const localVarPath = `/v1-parse`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(parseRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Purchase phone for a given agent.
     * @param {PurchasePhoneRequest} [purchasePhoneRequest] If no agent id is provided, the phone will be purchased for the owner of the API key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchasePhone: async (purchasePhoneRequest?: PurchasePhoneRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-purchases-phone`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(purchasePhoneRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Replaces an existing entity with the specified type and ID with a new entity.
     * @summary Replace an existing entity
     * @param {string} type
     * @param {string} id
     * @param {EntityData} entityData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceEntity: async (type: string, id: string, entityData: EntityData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists('replaceEntity', 'type', type)
      // verify required parameter 'id' is not null or undefined
      assertParamExists('replaceEntity', 'id', id)
      // verify required parameter 'entityData' is not null or undefined
      assertParamExists('replaceEntity', 'entityData', entityData)
      const localVarPath = `/v1-entity/{type}/{id}`
        .replace(`{${"type"}}`, encodeURIComponent(String(type)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(entityData, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Runs your auto-reply app on the Scout9 platform.
     * @param {WorkflowEvent} workflowEvent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPlatform: async (workflowEvent: WorkflowEvent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'workflowEvent' is not null or undefined
      assertParamExists('runPlatform', 'workflowEvent', workflowEvent)
      const localVarPath = `/v1-utils-platform-run`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(workflowEvent, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns the platform run config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPlatformConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-utils-platform-run`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates an existing entity with the specified type and ID.
     * @summary Update an existing entity
     * @param {string} type
     * @param {string} id
     * @param {EntityData} entityData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntity: async (type: string, id: string, entityData: EntityData, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'type' is not null or undefined
      assertParamExists('updateEntity', 'type', type)
      // verify required parameter 'id' is not null or undefined
      assertParamExists('updateEntity', 'id', id)
      // verify required parameter 'entityData' is not null or undefined
      assertParamExists('updateEntity', 'entityData', entityData)
      const localVarPath = `/v1-entity/{type}/{id}`
        .replace(`{${"type"}}`, encodeURIComponent(String(type)))
        .replace(`{${"id"}}`, encodeURIComponent(String(id)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(entityData, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  }
};

/**
 * Scout9Api - functional programming interface
 * @export
 */
export const Scout9ApiFp = function(configuration?: Configuration) {
  const localVarAxiosParamCreator = Scout9ApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Create a new entity
     * @param {string} type
     * @param {string} id The unique identifier of the entity
     * @param {EntityData} entityData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async addEntity(type: string, id: string, entityData: EntityData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Entity>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.addEntity(type, id, entityData, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agent(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAgentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agent(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentDeleteResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agentDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Registers a new agent
     * @param {CreateAgentRequest} createAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentRegister(createAgentRequest: CreateAgentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAgentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agentRegister(createAgentRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update a agent
     * @param {UpdateAgentRequest} updateAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentUpdate(updateAgentRequest: UpdateAgentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAgentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agentUpdate(updateAgentRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets all or specific set of agents
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agents(q?: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListAgentsResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agents(q, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates new agents
     * @param {CreateAgentsRequest} createAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentsCreate(createAgentsRequest: CreateAgentsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAgentsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agentsCreate(createAgentsRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes multiple agents
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentsDelete(id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentsDeleteResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agentsDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates multiple agents
     * @param {UpdateAgentsRequest} updateAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentsUpdate(updateAgentsRequest: UpdateAgentsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAgentsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agentsUpdate(updateAgentsRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Natural language prompt to resolve a context value derived from the conversation.
     * @param {MacroContextInput} macroContextInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async captureContext(macroContextInput: MacroContextInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MacroContextResult>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.captureContext(macroContextInput, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get the current project configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async config(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Config200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.config(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a conversation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async conversation(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationGetResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.conversation(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a conversation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async conversationContext(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: ConversationContextValue; }>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.conversationContext(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update a conversation
     * @param {ConversationContextUpdateRequest} conversationContextUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async conversationContextUpdate(conversationContextUpdateRequest: ConversationContextUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationUpdateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.conversationContextUpdate(conversationContextUpdateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Create a new conversation
     * @param {ConversationCreateRequest} conversationCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async conversationCreate(conversationCreateRequest: ConversationCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationCreateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.conversationCreate(conversationCreateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async conversationDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationRemoveResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.conversationDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update a conversation
     * @param {ConversationUpdateRequest} conversationUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async conversationUpdate(conversationUpdateRequest: ConversationUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationUpdateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.conversationUpdate(conversationUpdateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets all or specific set of conversations
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async conversations(q?: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListConversationsResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.conversations(q, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a customer
     * @param {string} idOrEmailOrPhone Either customers id, phone number or email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customer(idOrEmailOrPhone: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomerResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customer(idOrEmailOrPhone, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates a new customer
     * @param {Customer} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerCreate(body: Customer, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerCreateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerCreate(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes a customer
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerDeleteResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomerGroupResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroup(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates a new customer group
     * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroupCreate(createCustomerGroupRequest: CreateCustomerGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomerGroupResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupCreate(createCustomerGroupRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroupDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCustomerGroupResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates a customer group
     * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroupUpdate(updateCustomerGroupRequest: UpdateCustomerGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCustomerGroupResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupUpdate(updateCustomerGroupRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets all or specific set of customer groups
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroups(q?: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListCustomerGroupsResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroups(q, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates new customer groups
     * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroupsCreate(createCustomerGroupsRequest: CreateCustomerGroupsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomerGroupsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupsCreate(createCustomerGroupsRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes multiple customer groups
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroupsDelete(id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCustomerGroupsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupsDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates multiple customer groups
     * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroupsUpdate(updateCustomerGroupsRequest: UpdateCustomerGroupsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCustomerGroupsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupsUpdate(updateCustomerGroupsRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates a customer
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerUpdate(updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerUpdateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerUpdate(updateCustomerRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets all or specific set of customers
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customers(q?: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListCustomersResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customers(q, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates new customers
     * @param {CreateCustomersRequest} createCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customersCreate(createCustomersRequest: CreateCustomersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomersResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customersCreate(createCustomersRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes multiple customers
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customersDelete(id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCustomersResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customersDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates multiple customers
     * @param {UpdateCustomersRequest} updateCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customersUpdate(updateCustomersRequest: UpdateCustomersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCustomersResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customersUpdate(updateCustomersRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Deletes an entity with the specified type and ID.
     * @summary Delete an entity
     * @param {string} type
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deleteEntity(type: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntity(type, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Natural language prompt to resolve to a boolean value.
     * @param {MacroDidInput} macroDidInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async did(macroDidInput: MacroDidInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MacroDidResult>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.did(macroDidInput, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Natural language prompt to resolve to a boolean value in relation to the given immediate message.
     * @param {MacroDoesInput} macroDoesInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async does(macroDoesInput: MacroDoesInput, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MacroDoesResult>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.does(macroDoesInput, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get an entity by type and ID
     * @param {string} type The type of the entity to fetch
     * @param {string} id The unique identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async entity(type: string, id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Entity>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.entity(type, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Returns a file
     * @param {string} purpose File categorical purpose
     * @param {string} [entity] File entity id
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async file(purpose: string, entity?: string, agent?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.file(purpose, entity, agent, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Remove a file
     * @param {string} purpose File categorical purpose
     * @param {string} entity File entity id
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fileRemove(purpose: string, entity: string, agent?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationDocResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.fileRemove(purpose, entity, agent, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
     * @param {File} file
     * @param {PurposeEnum} [purpose]
     * @param {string} [context] Additional information about this file
     * @param {string} [entity] The entity id, if not provided the entity id becomes the provided file name
     * @param {string} [$agent] The agent that this file belongs to. Only used for entity.audio and entity.transcript files.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fileUpload(file: File, purpose?: PurposeEnum, context?: string, entity?: string, $agent?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FileUpload200Response>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.fileUpload(file, purpose, context, entity, $agent, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Returns a list of files that belong to the user\'s organization.
     * @param {string} purpose File categorical purpose
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async files(purpose: string, agent?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListFilesResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.files(purpose, agent, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Forwards a locked conversation to agent
     * @summary forwards a locked conversation to agent
     * @param {ForwardRequest} forwardRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async forward(forwardRequest: ForwardRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForwardResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.forward(forwardRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
     * @summary Generate a message from conversation
     * @param {GenerateRequest} generateRequest
     * @param {string} [convo] In relation to which conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generate(generateRequest: GenerateRequest, convo?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generate(generateRequest, convo, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Returns log data for a given range, specified by start and end Unix timestamps.
     * @summary Retrieve platform run time logs
     * @param {number} [start]
     * @param {number} [end]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async logs(start?: number, end?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.logs(start, end, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
     * @summary Create and send message
     * @param {MessageCreateRequest} messageCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async message(messageCreateRequest: MessageCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageCreateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.message(messageCreateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get all messages from a conversation
     * @param {string} id id of entity to query
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async messages(id: string, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageGetResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.messages(id, q, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get the results of a bulk API operation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async operation(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApiOperationResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.operation(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets all or specific set of bulk API operations
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async operations(q?: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListApiOperationsResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.operations(q, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Parses a message\'s custom context relevant to your organization. This is useful for extracting information from a message to drive your auto reply workflows.
     * @summary Parse a message\'s custom context relevant to your organization
     * @param {ParseRequest} parseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async parse(parseRequest: ParseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.parse(parseRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Purchase phone for a given agent.
     * @param {PurchasePhoneRequest} [purchasePhoneRequest] If no agent id is provided, the phone will be purchased for the owner of the API key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async purchasePhone(purchasePhoneRequest?: PurchasePhoneRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PurchasePhoneResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.purchasePhone(purchasePhoneRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Replaces an existing entity with the specified type and ID with a new entity.
     * @summary Replace an existing entity
     * @param {string} type
     * @param {string} id
     * @param {EntityData} entityData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async replaceEntity(type: string, id: string, entityData: EntityData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Entity>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.replaceEntity(type, id, entityData, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Runs your auto-reply app on the Scout9 platform.
     * @param {WorkflowEvent} workflowEvent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPlatform(workflowEvent: WorkflowEvent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPlatform(workflowEvent, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Returns the platform run config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPlatformConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPlatformConfig(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Updates an existing entity with the specified type and ID.
     * @summary Update an existing entity
     * @param {string} type
     * @param {string} id
     * @param {EntityData} entityData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateEntity(type: string, id: string, entityData: EntityData, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Entity>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntity(type, id, entityData, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  }
};

/**
 * Scout9Api - factory interface
 * @export
 */
export const Scout9ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = Scout9ApiFp(configuration)
  return {
    /**
     *
     * @summary Create a new entity
     * @param {string} type
     * @param {string} id The unique identifier of the entity
     * @param {EntityData} entityData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    addEntity(type: string, id: string, entityData: EntityData, options?: any): AxiosPromise<Entity> {
      return localVarFp.addEntity(type, id, entityData, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agent(id: string, options?: any): AxiosPromise<GetAgentResponse> {
      return localVarFp.agent(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentDelete(id: string, options?: any): AxiosPromise<AgentDeleteResponse> {
      return localVarFp.agentDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Registers a new agent
     * @param {CreateAgentRequest} createAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentRegister(createAgentRequest: CreateAgentRequest, options?: any): AxiosPromise<CreateAgentResponse> {
      return localVarFp.agentRegister(createAgentRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a agent
     * @param {UpdateAgentRequest} updateAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentUpdate(updateAgentRequest: UpdateAgentRequest, options?: any): AxiosPromise<UpdateAgentResponse> {
      return localVarFp.agentUpdate(updateAgentRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all or specific set of agents
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agents(q?: string, id?: Array<string>, options?: any): AxiosPromise<Array<ListAgentsResponseInner>> {
      return localVarFp.agents(q, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates new agents
     * @param {CreateAgentsRequest} createAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentsCreate(createAgentsRequest: CreateAgentsRequest, options?: any): AxiosPromise<CreateAgentsResponse> {
      return localVarFp.agentsCreate(createAgentsRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes multiple agents
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentsDelete(id?: Array<string>, options?: any): AxiosPromise<AgentsDeleteResponse> {
      return localVarFp.agentsDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates multiple agents
     * @param {UpdateAgentsRequest} updateAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentsUpdate(updateAgentsRequest: UpdateAgentsRequest, options?: any): AxiosPromise<UpdateAgentsResponse> {
      return localVarFp.agentsUpdate(updateAgentsRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Natural language prompt to resolve a context value derived from the conversation.
     * @param {MacroContextInput} macroContextInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    captureContext(macroContextInput: MacroContextInput, options?: any): AxiosPromise<MacroContextResult> {
      return localVarFp.captureContext(macroContextInput, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the current project configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    config(options?: any): AxiosPromise<Config200Response> {
      return localVarFp.config(options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a conversation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversation(id: string, options?: any): AxiosPromise<ConversationGetResponse> {
      return localVarFp.conversation(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a conversation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationContext(id: string, options?: any): AxiosPromise<{ [key: string]: ConversationContextValue; }> {
      return localVarFp.conversationContext(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a conversation
     * @param {ConversationContextUpdateRequest} conversationContextUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationContextUpdate(conversationContextUpdateRequest: ConversationContextUpdateRequest, options?: any): AxiosPromise<ConversationUpdateResponse> {
      return localVarFp.conversationContextUpdate(conversationContextUpdateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a new conversation
     * @param {ConversationCreateRequest} conversationCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationCreate(conversationCreateRequest: ConversationCreateRequest, options?: any): AxiosPromise<ConversationCreateResponse> {
      return localVarFp.conversationCreate(conversationCreateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationDelete(id: string, options?: any): AxiosPromise<ConversationRemoveResponse> {
      return localVarFp.conversationDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a conversation
     * @param {ConversationUpdateRequest} conversationUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationUpdate(conversationUpdateRequest: ConversationUpdateRequest, options?: any): AxiosPromise<ConversationUpdateResponse> {
      return localVarFp.conversationUpdate(conversationUpdateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all or specific set of conversations
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversations(q?: string, id?: Array<string>, options?: any): AxiosPromise<Array<ListConversationsResponseInner>> {
      return localVarFp.conversations(q, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a customer
     * @param {string} idOrEmailOrPhone Either customers id, phone number or email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customer(idOrEmailOrPhone: string, options?: any): AxiosPromise<GetCustomerResponse> {
      return localVarFp.customer(idOrEmailOrPhone, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates a new customer
     * @param {Customer} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerCreate(body: Customer, options?: any): AxiosPromise<CustomerCreateResponse> {
      return localVarFp.customerCreate(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes a customer
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerDelete(id: string, options?: any): AxiosPromise<CustomerDeleteResponse> {
      return localVarFp.customerDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroup(id: string, options?: any): AxiosPromise<GetCustomerGroupResponse> {
      return localVarFp.customerGroup(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates a new customer group
     * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupCreate(createCustomerGroupRequest: CreateCustomerGroupRequest, options?: any): AxiosPromise<CreateCustomerGroupResponse> {
      return localVarFp.customerGroupCreate(createCustomerGroupRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupDelete(id: string, options?: any): AxiosPromise<DeleteCustomerGroupResponse> {
      return localVarFp.customerGroupDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates a customer group
     * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupUpdate(updateCustomerGroupRequest: UpdateCustomerGroupRequest, options?: any): AxiosPromise<UpdateCustomerGroupResponse> {
      return localVarFp.customerGroupUpdate(updateCustomerGroupRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all or specific set of customer groups
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroups(q?: string, id?: Array<string>, options?: any): AxiosPromise<Array<ListCustomerGroupsResponseInner>> {
      return localVarFp.customerGroups(q, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates new customer groups
     * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupsCreate(createCustomerGroupsRequest: CreateCustomerGroupsRequest, options?: any): AxiosPromise<CreateCustomerGroupsResponse> {
      return localVarFp.customerGroupsCreate(createCustomerGroupsRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes multiple customer groups
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupsDelete(id?: Array<string>, options?: any): AxiosPromise<DeleteCustomerGroupsResponse> {
      return localVarFp.customerGroupsDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates multiple customer groups
     * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupsUpdate(updateCustomerGroupsRequest: UpdateCustomerGroupsRequest, options?: any): AxiosPromise<UpdateCustomerGroupsResponse> {
      return localVarFp.customerGroupsUpdate(updateCustomerGroupsRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates a customer
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerUpdate(updateCustomerRequest: UpdateCustomerRequest, options?: any): AxiosPromise<CustomerUpdateResponse> {
      return localVarFp.customerUpdate(updateCustomerRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all or specific set of customers
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customers(q?: string, id?: Array<string>, options?: any): AxiosPromise<Array<ListCustomersResponseInner>> {
      return localVarFp.customers(q, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates new customers
     * @param {CreateCustomersRequest} createCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCreate(createCustomersRequest: CreateCustomersRequest, options?: any): AxiosPromise<CreateCustomersResponse> {
      return localVarFp.customersCreate(createCustomersRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes multiple customers
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersDelete(id?: Array<string>, options?: any): AxiosPromise<DeleteCustomersResponse> {
      return localVarFp.customersDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates multiple customers
     * @param {UpdateCustomersRequest} updateCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersUpdate(updateCustomersRequest: UpdateCustomersRequest, options?: any): AxiosPromise<UpdateCustomersResponse> {
      return localVarFp.customersUpdate(updateCustomersRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Deletes an entity with the specified type and ID.
     * @summary Delete an entity
     * @param {string} type
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deleteEntity(type: string, id: string, options?: any): AxiosPromise<void> {
      return localVarFp.deleteEntity(type, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Natural language prompt to resolve to a boolean value.
     * @param {MacroDidInput} macroDidInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    did(macroDidInput: MacroDidInput, options?: any): AxiosPromise<MacroDidResult> {
      return localVarFp.did(macroDidInput, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Natural language prompt to resolve to a boolean value in relation to the given immediate message.
     * @param {MacroDoesInput} macroDoesInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    does(macroDoesInput: MacroDoesInput, options?: any): AxiosPromise<MacroDoesResult> {
      return localVarFp.does(macroDoesInput, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get an entity by type and ID
     * @param {string} type The type of the entity to fetch
     * @param {string} id The unique identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    entity(type: string, id: string, options?: any): AxiosPromise<Entity> {
      return localVarFp.entity(type, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns a file
     * @param {string} purpose File categorical purpose
     * @param {string} [entity] File entity id
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    file(purpose: string, entity?: string, agent?: string, options?: any): AxiosPromise<File> {
      return localVarFp.file(purpose, entity, agent, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove a file
     * @param {string} purpose File categorical purpose
     * @param {string} entity File entity id
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileRemove(purpose: string, entity: string, agent?: string, options?: any): AxiosPromise<OperationDocResponse> {
      return localVarFp.fileRemove(purpose, entity, agent, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
     * @param {File} file
     * @param {PurposeEnum} [purpose]
     * @param {string} [context] Additional information about this file
     * @param {string} [entity] The entity id, if not provided the entity id becomes the provided file name
     * @param {string} [$agent] The agent that this file belongs to. Only used for entity.audio and entity.transcript files.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileUpload(file: File, purpose?: PurposeEnum, context?: string, entity?: string, $agent?: string, options?: any): AxiosPromise<FileUpload200Response> {
      return localVarFp.fileUpload(file, purpose, context, entity, $agent, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns a list of files that belong to the user\'s organization.
     * @param {string} purpose File categorical purpose
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    files(purpose: string, agent?: string, options?: any): AxiosPromise<Array<ListFilesResponseInner>> {
      return localVarFp.files(purpose, agent, options).then((request) => request(axios, basePath));
    },
    /**
     * Forwards a locked conversation to agent
     * @summary forwards a locked conversation to agent
     * @param {ForwardRequest} forwardRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forward(forwardRequest: ForwardRequest, options?: any): AxiosPromise<ForwardResponse> {
      return localVarFp.forward(forwardRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
     * @summary Generate a message from conversation
     * @param {GenerateRequest} generateRequest
     * @param {string} [convo] In relation to which conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generate(generateRequest: GenerateRequest, convo?: string, options?: any): AxiosPromise<GenerateResponse> {
      return localVarFp.generate(generateRequest, convo, options).then((request) => request(axios, basePath));
    },
    /**
     * Returns log data for a given range, specified by start and end Unix timestamps.
     * @summary Retrieve platform run time logs
     * @param {number} [start]
     * @param {number} [end]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    logs(start?: number, end?: number, options?: any): AxiosPromise<LogResponse> {
      return localVarFp.logs(start, end, options).then((request) => request(axios, basePath));
    },
    /**
     * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
     * @summary Create and send message
     * @param {MessageCreateRequest} messageCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    message(messageCreateRequest: MessageCreateRequest, options?: any): AxiosPromise<MessageCreateResponse> {
      return localVarFp.message(messageCreateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all messages from a conversation
     * @param {string} id id of entity to query
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    messages(id: string, q?: string, options?: any): AxiosPromise<Array<MessageGetResponseInner>> {
      return localVarFp.messages(id, q, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the results of a bulk API operation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operation(id: string, options?: any): AxiosPromise<GetApiOperationResponse> {
      return localVarFp.operation(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all or specific set of bulk API operations
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operations(q?: string, id?: Array<string>, options?: any): AxiosPromise<Array<ListApiOperationsResponseInner>> {
      return localVarFp.operations(q, id, options).then((request) => request(axios, basePath));
    },
    /**
     * Parses a message\'s custom context relevant to your organization. This is useful for extracting information from a message to drive your auto reply workflows.
     * @summary Parse a message\'s custom context relevant to your organization
     * @param {ParseRequest} parseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parse(parseRequest: ParseRequest, options?: any): AxiosPromise<ParseResponse> {
      return localVarFp.parse(parseRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Purchase phone for a given agent.
     * @param {PurchasePhoneRequest} [purchasePhoneRequest] If no agent id is provided, the phone will be purchased for the owner of the API key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchasePhone(purchasePhoneRequest?: PurchasePhoneRequest, options?: any): AxiosPromise<PurchasePhoneResponse> {
      return localVarFp.purchasePhone(purchasePhoneRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Replaces an existing entity with the specified type and ID with a new entity.
     * @summary Replace an existing entity
     * @param {string} type
     * @param {string} id
     * @param {EntityData} entityData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    replaceEntity(type: string, id: string, entityData: EntityData, options?: any): AxiosPromise<Entity> {
      return localVarFp.replaceEntity(type, id, entityData, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Runs your auto-reply app on the Scout9 platform.
     * @param {WorkflowEvent} workflowEvent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPlatform(workflowEvent: WorkflowEvent, options?: any): AxiosPromise<WorkflowResponse> {
      return localVarFp.runPlatform(workflowEvent, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns the platform run config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPlatformConfig(options?: any): AxiosPromise<{ [key: string]: any; }> {
      return localVarFp.runPlatformConfig(options).then((request) => request(axios, basePath));
    },
    /**
     * Updates an existing entity with the specified type and ID.
     * @summary Update an existing entity
     * @param {string} type
     * @param {string} id
     * @param {EntityData} entityData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateEntity(type: string, id: string, entityData: EntityData, options?: any): AxiosPromise<Entity> {
      return localVarFp.updateEntity(type, id, entityData, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * Scout9ApiGenerated - object-oriented interface
 * @export
 * @class Scout9ApiGenerated
 * @extends {BaseAPI}
 */
export class Scout9ApiGenerated extends BaseAPI {
  /**
   *
   * @summary Create a new entity
   * @param {string} type
   * @param {string} id The unique identifier of the entity
   * @param {EntityData} entityData
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public addEntity(type: string, id: string, entityData: EntityData, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).addEntity(type, id, entityData, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a agent
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agent(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agent(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes a agent
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agentDelete(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agentDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Registers a new agent
   * @param {CreateAgentRequest} createAgentRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agentRegister(createAgentRequest: CreateAgentRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agentRegister(createAgentRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a agent
   * @param {UpdateAgentRequest} updateAgentRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agentUpdate(updateAgentRequest: UpdateAgentRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agentUpdate(updateAgentRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets all or specific set of agents
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agents(q?: string, id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agents(q, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates new agents
   * @param {CreateAgentsRequest} createAgentsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agentsCreate(createAgentsRequest: CreateAgentsRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agentsCreate(createAgentsRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes multiple agents
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agentsDelete(id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agentsDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates multiple agents
   * @param {UpdateAgentsRequest} updateAgentsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agentsUpdate(updateAgentsRequest: UpdateAgentsRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agentsUpdate(updateAgentsRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Natural language prompt to resolve a context value derived from the conversation.
   * @param {MacroContextInput} macroContextInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public captureContext(macroContextInput: MacroContextInput, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).captureContext(macroContextInput, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the current project configuration
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public config(options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).config(options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a conversation
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public conversation(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).conversation(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a conversation
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public conversationContext(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).conversationContext(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a conversation
   * @param {ConversationContextUpdateRequest} conversationContextUpdateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public conversationContextUpdate(conversationContextUpdateRequest: ConversationContextUpdateRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).conversationContextUpdate(conversationContextUpdateRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a new conversation
   * @param {ConversationCreateRequest} conversationCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public conversationCreate(conversationCreateRequest: ConversationCreateRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).conversationCreate(conversationCreateRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes a schedule
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public conversationDelete(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).conversationDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a conversation
   * @param {ConversationUpdateRequest} conversationUpdateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public conversationUpdate(conversationUpdateRequest: ConversationUpdateRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).conversationUpdate(conversationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets all or specific set of conversations
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public conversations(q?: string, id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).conversations(q, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a customer
   * @param {string} idOrEmailOrPhone Either customers id, phone number or email
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customer(idOrEmailOrPhone: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customer(idOrEmailOrPhone, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates a new customer
   * @param {Customer} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerCreate(body: Customer, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerCreate(body, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes a customer
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerDelete(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a customer group
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroup(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroup(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates a new customer group
   * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroupCreate(createCustomerGroupRequest: CreateCustomerGroupRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroupCreate(createCustomerGroupRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes a customer group
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroupDelete(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroupDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates a customer group
   * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroupUpdate(updateCustomerGroupRequest: UpdateCustomerGroupRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroupUpdate(updateCustomerGroupRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets all or specific set of customer groups
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroups(q?: string, id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroups(q, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates new customer groups
   * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroupsCreate(createCustomerGroupsRequest: CreateCustomerGroupsRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroupsCreate(createCustomerGroupsRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes multiple customer groups
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroupsDelete(id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroupsDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates multiple customer groups
   * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroupsUpdate(updateCustomerGroupsRequest: UpdateCustomerGroupsRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroupsUpdate(updateCustomerGroupsRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates a customer
   * @param {UpdateCustomerRequest} updateCustomerRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerUpdate(updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerUpdate(updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets all or specific set of customers
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customers(q?: string, id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customers(q, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates new customers
   * @param {CreateCustomersRequest} createCustomersRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customersCreate(createCustomersRequest: CreateCustomersRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customersCreate(createCustomersRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes multiple customers
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customersDelete(id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customersDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates multiple customers
   * @param {UpdateCustomersRequest} updateCustomersRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customersUpdate(updateCustomersRequest: UpdateCustomersRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customersUpdate(updateCustomersRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Deletes an entity with the specified type and ID.
   * @summary Delete an entity
   * @param {string} type
   * @param {string} id
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public deleteEntity(type: string, id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).deleteEntity(type, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Natural language prompt to resolve to a boolean value.
   * @param {MacroDidInput} macroDidInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public did(macroDidInput: MacroDidInput, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).did(macroDidInput, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Natural language prompt to resolve to a boolean value in relation to the given immediate message.
   * @param {MacroDoesInput} macroDoesInput
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public does(macroDoesInput: MacroDoesInput, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).does(macroDoesInput, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get an entity by type and ID
   * @param {string} type The type of the entity to fetch
   * @param {string} id The unique identifier of the entity
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public entity(type: string, id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).entity(type, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Returns a file
   * @param {string} purpose File categorical purpose
   * @param {string} [entity] File entity id
   * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public file(purpose: string, entity?: string, agent?: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).file(purpose, entity, agent, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove a file
   * @param {string} purpose File categorical purpose
   * @param {string} entity File entity id
   * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public fileRemove(purpose: string, entity: string, agent?: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).fileRemove(purpose, entity, agent, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
   * @param {File} file
   * @param {PurposeEnum} [purpose]
   * @param {string} [context] Additional information about this file
   * @param {string} [entity] The entity id, if not provided the entity id becomes the provided file name
   * @param {string} [$agent] The agent that this file belongs to. Only used for entity.audio and entity.transcript files.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public fileUpload(file: File, purpose?: PurposeEnum, context?: string, entity?: string, $agent?: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).fileUpload(file, purpose, context, entity, $agent, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Returns a list of files that belong to the user\'s organization.
   * @param {string} purpose File categorical purpose
   * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public files(purpose: string, agent?: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).files(purpose, agent, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Forwards a locked conversation to agent
   * @summary forwards a locked conversation to agent
   * @param {ForwardRequest} forwardRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public forward(forwardRequest: ForwardRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).forward(forwardRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
   * @summary Generate a message from conversation
   * @param {GenerateRequest} generateRequest
   * @param {string} [convo] In relation to which conversation
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public generate(generateRequest: GenerateRequest, convo?: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).generate(generateRequest, convo, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Returns log data for a given range, specified by start and end Unix timestamps.
   * @summary Retrieve platform run time logs
   * @param {number} [start]
   * @param {number} [end]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public logs(start?: number, end?: number, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).logs(start, end, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
   * @summary Create and send message
   * @param {MessageCreateRequest} messageCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public message(messageCreateRequest: MessageCreateRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).message(messageCreateRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all messages from a conversation
   * @param {string} id id of entity to query
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public messages(id: string, q?: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).messages(id, q, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the results of a bulk API operation
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public operation(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).operation(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets all or specific set of bulk API operations
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public operations(q?: string, id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).operations(q, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Parses a message\'s custom context relevant to your organization. This is useful for extracting information from a message to drive your auto reply workflows.
   * @summary Parse a message\'s custom context relevant to your organization
   * @param {ParseRequest} parseRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public parse(parseRequest: ParseRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).parse(parseRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Purchase phone for a given agent.
   * @param {PurchasePhoneRequest} [purchasePhoneRequest] If no agent id is provided, the phone will be purchased for the owner of the API key.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public purchasePhone(purchasePhoneRequest?: PurchasePhoneRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).purchasePhone(purchasePhoneRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Replaces an existing entity with the specified type and ID with a new entity.
   * @summary Replace an existing entity
   * @param {string} type
   * @param {string} id
   * @param {EntityData} entityData
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public replaceEntity(type: string, id: string, entityData: EntityData, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).replaceEntity(type, id, entityData, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Runs your auto-reply app on the Scout9 platform.
   * @param {WorkflowEvent} workflowEvent
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public runPlatform(workflowEvent: WorkflowEvent, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).runPlatform(workflowEvent, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Returns the platform run config
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public runPlatformConfig(options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).runPlatformConfig(options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Updates an existing entity with the specified type and ID.
   * @summary Update an existing entity
   * @param {string} type
   * @param {string} id
   * @param {EntityData} entityData
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public updateEntity(type: string, id: string, entityData: EntityData, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).updateEntity(type, id, entityData, options).then((request) => request(this.axios, this.basePath));
  }
}



import { Readable } from 'stream';



/**
 * Scout9Api - object-oriented interface
 * @export
 * @class Scout9Api
 * @extends {Scout9ApiGenerated}
 */
export class Scout9Api extends Scout9ApiGenerated {

  public organizationLogo(file: Blob | File | Buffer) {
    assertParamExists('organizationLogo', 'file', file);
    const formData: FormData = new ((this.configuration && this.configuration.formDataCtor) || FormData)();

    if (Buffer.isBuffer(file)) {
      // Convert Buffer to Blob
      file = new Blob([file], {type: 'application/octet-stream'});

      // Convert Blob to Stream
      const fileStream = Readable.from((file as any).stream());

      formData.append('file', fileStream as any, 'logo');
    } else {
      formData.append('file', file, (file as File)?.name || 'logo');
    }

    return this.axios.request<{ url?: string; success: boolean; error?: string }>({
      method: 'POST',
      url: `${this.configuration?.basePath || BASE_PATH}/v1-organizationLogo`,
      data: formData,
      headers: {
        'Content-Type': 'multipart/form-data',
        'Authorization': 'Bearer ' + this.configuration?.apiKey || '',
      }
    });
  }

  public organizationIcon(file: Blob | File | Buffer) {
    assertParamExists('organizationLogo', 'file', file);
    const formData: FormData = new ((this.configuration && this.configuration.formDataCtor) || FormData)();

    if (Buffer.isBuffer(file)) {
      // Convert Buffer to Blob
      file = new Blob([file], {type: 'application/octet-stream'});

      // Convert Blob to Stream
      const fileStream = Readable.from((file as any).stream());

      formData.append('file', fileStream as any, 'icon');
    } else {
      formData.append('file', file, (file as File)?.name || 'icon');
    }
    return this.axios.request<{ url?: string; success: boolean; error?: string }>({
      method: 'POST',
      url: `${this.configuration?.basePath || BASE_PATH}/v1-organizationIcon`,
      data: formData,
      headers: {
        'Content-Type': 'multipart/form-data',
        'Authorization': 'Bearer ' + this.configuration?.apiKey || '',
      }
    });
  }

  public agentProfileUpload(agentId: string = '', file: Blob | File | Buffer) {
    // assertParamExists('agentProfileUpload', 'agentId', agentId);
    assertParamExists('agentProfileUpload', 'file', file);
    const formData: FormData = new ((this.configuration && this.configuration.formDataCtor) || FormData)();

    if (Buffer.isBuffer(file)) {
      // Convert Buffer to Blob
      file = new Blob([file], { type: "application/octet-stream" });

      // Convert Blob to Stream
      const fileStream = Readable.from((file as any).stream());

      formData.append('file', fileStream as any, 'profile');
    } else {
      formData.append('file', file, (file as any)?.name || 'profile');
    }
    if (agentId) {
      formData.append('agentId', agentId);
    }

    return this.axios.request<{ url?: string; success: boolean; error?: string }>({
      method: 'POST',
      url: `${this.configuration?.basePath || BASE_PATH}/v1-agentImg`,
      data: formData,
      headers: {
        'Content-Type': 'multipart/form-data',
        'Authorization': 'Bearer ' + this.configuration?.apiKey || '',
      }
    });
  }

  public agentTranscriptUpload(agentId: string = '', transcripts: (Blob | File | Buffer)[]) {
    // assertParamExists('agentProfileUpload', 'agentId', agentId);
    assertParamExists('agentProfileUpload', 'transcripts', transcripts);
    const formData: FormData = new ((this.configuration && this.configuration.formDataCtor) || FormData)();

    if (agentId) {
      formData.append('agentId', agentId);
    }
    transcripts.forEach((file, i) => {
      if (Buffer.isBuffer(file)) {
        // Convert Buffer to Blob
        file = new Blob([file], { type: "text/plain" });

        // Convert Blob to Stream
        const fileStream = Readable.from((file as any).stream());

        formData.append(`transcripts[${i}]`,  fileStream as any, (file as File)?.name || 'transcript' + i);
      } else {
        formData.append(`transcripts[${i}]`, file, (file as File)?.name || 'transcript' + i);
      }
    });

    return this.axios.request<{ urls?: string[]; success: boolean; error?: string }>({
      method: 'POST',
      url: `${this.configuration?.basePath || BASE_PATH}/v1-agentTranscripts`,
      data: formData,
      headers: {
        'Content-Type': 'multipart/form-data',
        'Authorization': 'Bearer ' + this.configuration?.apiKey || '',
      }
    });
  }

  public agentAudioUpload(agentId: string = '', audios: (Blob | File | Buffer)[]) {
    // assertParamExists('agentProfileUpload', 'agentId', agentId);
    assertParamExists('agentProfileUpload', 'audios', audios);
    const formData: FormData = new ((this.configuration && this.configuration.formDataCtor) || FormData)();

    if (agentId) {
      formData.append('agentId', agentId);
    }

    audios.forEach((file, i) => {
      if (Buffer.isBuffer(file)) {
        // Convert Buffer to Blob
        file = new Blob([file], { type: "application/octet-stream" });

        // Convert Blob to Stream
        const fileStream = Readable.from((file as any).stream());

        formData.append(`audios[${i}]`,  fileStream as any, (file as File)?.name || 'audio' + i);
      } else {
        formData.append(`audios[${i}]`, file, (file as File)?.name || 'audio' + i);
      }
    });

    return this.axios.request<{ urls?: string[]; success: boolean; error?: string }>({
      method: 'POST',
      url: `${this.configuration?.basePath || BASE_PATH}/v1-agentAudios`,
      data: formData,
      headers: {
        'Content-Type': 'multipart/form-data',
        'Authorization': 'Bearer ' + this.configuration?.apiKey || '',
      }
    });
  }

}

