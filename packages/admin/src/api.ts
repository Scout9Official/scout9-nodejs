/* tslint:disable */
/* eslint-disable */
/**
 * Scout9 API
 * APIs for managing Scout9 users and conversations
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface BlockInfo
 */
export interface BlockInfo {
    /**
     *
     * @type {string}
     * @memberof BlockInfo
     */
    'message'?: string;
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof BlockInfo
     */
    'time'?: string;
}
/**
 *
 * @export
 * @interface Conversation
 */
export interface Conversation {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof Conversation
     */
    '$customer'?: string;
    /**
     * Business this conversation is with
     * @type {string}
     * @memberof Conversation
     */
    '$business'?: string;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof Conversation
     */
    '$agent'?: string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof Conversation
     */
    '$thread'?: string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof Conversation
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof Conversation
     */
    'environment'?: string;
}
/**
 *
 * @export
 * @interface ConversationCreateRequest
 */
export interface ConversationCreateRequest {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ConversationCreateRequest
     */
    '$customer'?: string;
    /**
     *
     * @type {any}
     * @memberof ConversationCreateRequest
     */
    '$business'?: any | null;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ConversationCreateRequest
     */
    '$agent'?: string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ConversationCreateRequest
     */
    '$thread'?: string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ConversationCreateRequest
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ConversationCreateRequest
     */
    'environment'?: string;
}
/**
 *
 * @export
 * @interface ConversationCreateRequestAllOf
 */
export interface ConversationCreateRequestAllOf {
    /**
     *
     * @type {any}
     * @memberof ConversationCreateRequestAllOf
     */
    '$business'?: any | null;
}
/**
 *
 * @export
 * @interface ConversationCreateResponse
 */
export interface ConversationCreateResponse {
    /**
     *
     * @type {boolean}
     * @memberof ConversationCreateResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof ConversationCreateResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ConversationGetResponse
 */
export interface ConversationGetResponse {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ConversationGetResponse
     */
    '$customer'?: string;
    /**
     * Business this conversation is with
     * @type {string}
     * @memberof ConversationGetResponse
     */
    '$business'?: string;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ConversationGetResponse
     */
    '$agent'?: string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ConversationGetResponse
     */
    '$thread'?: string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ConversationGetResponse
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ConversationGetResponse
     */
    'environment'?: string;
}
/**
 *
 * @export
 * @interface ConversationRemoveResponse
 */
export interface ConversationRemoveResponse {
    /**
     *
     * @type {boolean}
     * @memberof ConversationRemoveResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof ConversationRemoveResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ConversationUpdateRequest
 */
export interface ConversationUpdateRequest {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ConversationUpdateRequest
     */
    '$customer'?: string;
    /**
     * Business this conversation is with
     * @type {string}
     * @memberof ConversationUpdateRequest
     */
    '$business'?: string;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ConversationUpdateRequest
     */
    '$agent'?: string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ConversationUpdateRequest
     */
    '$thread'?: string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ConversationUpdateRequest
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ConversationUpdateRequest
     */
    'environment'?: string;
    /**
     * The ID of the conversation to update
     * @type {string}
     * @memberof ConversationUpdateRequest
     */
    'id'?: string;
}
/**
 *
 * @export
 * @interface ConversationUpdateRequestAllOf
 */
export interface ConversationUpdateRequestAllOf {
    /**
     * The ID of the conversation to update
     * @type {string}
     * @memberof ConversationUpdateRequestAllOf
     */
    'id'?: string;
}
/**
 *
 * @export
 * @interface ConversationUpdateResponse
 */
export interface ConversationUpdateResponse {
    /**
     *
     * @type {boolean}
     * @memberof ConversationUpdateResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof ConversationUpdateResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface CreateCustomerRequest
 */
export interface CreateCustomerRequest {
    /**
     * The customers first name
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'firstName': string;
    /**
     * The customers last name
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'lastName': string;
    /**
     * The customers full name
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'name'?: string;
    /**
     * The customers email address
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'email'?: string | null;
    /**
     * The customers phone number
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'phone'?: string | null;
    /**
     * The customers profile image
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'img'?: string | null;
    /**
     * The customers neighborhood
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'neighborhood'?: string | null;
    /**
     * The customers city
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'city'?: string | null;
    /**
     * The customers 2-letter country code
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'country'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'line1'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'line2'?: string | null;
    /**
     * The customers postal code
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'postal_code'?: string | null;
    /**
     * The customers state, county, province, or region
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'state'?: string | null;
    /**
     * The customers town (only used in Japan)
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'town'?: string | null;
    /**
     *
     * @type {BlockInfo}
     * @memberof CreateCustomerRequest
     */
    'blocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof CreateCustomerRequest
     */
    'phoneBlocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof CreateCustomerRequest
     */
    'emailBlocked'?: BlockInfo;
    /**
     * The date the customer joined the business
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'joined'?: string | null;
    /**
     * The customers stripe ID
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'stripe'?: string | null;
    /**
     * The customers stripe ID in the dev environment
     * @type {string}
     * @memberof CreateCustomerRequest
     */
    'stripeDev'?: string | null;
}
/**
 *
 * @export
 * @interface CreateCustomerResponse
 */
export interface CreateCustomerResponse {
    /**
     *
     * @type {boolean}
     * @memberof CreateCustomerResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof CreateCustomerResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface CreateCustomersRequest
 */
export interface CreateCustomersRequest {
    /**
     *
     * @type {Array<CreateCustomersRequestCustomersInner>}
     * @memberof CreateCustomersRequest
     */
    'customers'?: Array<CreateCustomersRequestCustomersInner>;
}
/**
 *
 * @export
 * @interface CreateCustomersRequestCustomersInner
 */
export interface CreateCustomersRequestCustomersInner {
    /**
     * The customers first name
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'firstName': string;
    /**
     * The customers last name
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'lastName': string;
    /**
     * The customers full name
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'name'?: string;
    /**
     * The customers email address
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'email'?: string | null;
    /**
     * The customers phone number
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'phone'?: string | null;
    /**
     * The customers profile image
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'img'?: string | null;
    /**
     * The customers neighborhood
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'neighborhood'?: string | null;
    /**
     * The customers city
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'city'?: string | null;
    /**
     * The customers 2-letter country code
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'country'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'line1'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'line2'?: string | null;
    /**
     * The customers postal code
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'postal_code'?: string | null;
    /**
     * The customers state, county, province, or region
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'state'?: string | null;
    /**
     * The customers town (only used in Japan)
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'town'?: string | null;
    /**
     *
     * @type {BlockInfo}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'blocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'phoneBlocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'emailBlocked'?: BlockInfo;
    /**
     * The date the customer joined the business
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'joined'?: string | null;
    /**
     * The customers stripe ID
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'stripe'?: string | null;
    /**
     * The customers stripe ID in the dev environment
     * @type {string}
     * @memberof CreateCustomersRequestCustomersInner
     */
    'stripeDev'?: string | null;
}
/**
 *
 * @export
 * @interface CreateCustomersResponse
 */
export interface CreateCustomersResponse {
    /**
     *
     * @type {boolean}
     * @memberof CreateCustomersResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof CreateCustomersResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface Customer
 */
export interface Customer {
    /**
     * The customers first name
     * @type {string}
     * @memberof Customer
     */
    'firstName'?: string;
    /**
     * The customers last name
     * @type {string}
     * @memberof Customer
     */
    'lastName'?: string;
    /**
     * The customers full name
     * @type {string}
     * @memberof Customer
     */
    'name'?: string;
    /**
     * The customers email address
     * @type {string}
     * @memberof Customer
     */
    'email'?: string | null;
    /**
     * The customers phone number
     * @type {string}
     * @memberof Customer
     */
    'phone'?: string | null;
    /**
     * The customers profile image
     * @type {string}
     * @memberof Customer
     */
    'img'?: string | null;
    /**
     * The customers neighborhood
     * @type {string}
     * @memberof Customer
     */
    'neighborhood'?: string | null;
    /**
     * The customers city
     * @type {string}
     * @memberof Customer
     */
    'city'?: string | null;
    /**
     * The customers 2-letter country code
     * @type {string}
     * @memberof Customer
     */
    'country'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof Customer
     */
    'line1'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof Customer
     */
    'line2'?: string | null;
    /**
     * The customers postal code
     * @type {string}
     * @memberof Customer
     */
    'postal_code'?: string | null;
    /**
     * The customers state, county, province, or region
     * @type {string}
     * @memberof Customer
     */
    'state'?: string | null;
    /**
     * The customers town (only used in Japan)
     * @type {string}
     * @memberof Customer
     */
    'town'?: string | null;
    /**
     *
     * @type {BlockInfo}
     * @memberof Customer
     */
    'blocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof Customer
     */
    'phoneBlocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof Customer
     */
    'emailBlocked'?: BlockInfo;
    /**
     * The date the customer joined the business
     * @type {string}
     * @memberof Customer
     */
    'joined'?: string | null;
    /**
     * The customers stripe ID
     * @type {string}
     * @memberof Customer
     */
    'stripe'?: string | null;
    /**
     * The customers stripe ID in the dev environment
     * @type {string}
     * @memberof Customer
     */
    'stripeDev'?: string | null;
}
/**
 *
 * @export
 * @interface DeleteCustomerResponse
 */
export interface DeleteCustomerResponse {
    /**
     *
     * @type {boolean}
     * @memberof DeleteCustomerResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof DeleteCustomerResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface DeleteCustomersResponse
 */
export interface DeleteCustomersResponse {
    /**
     *
     * @type {boolean}
     * @memberof DeleteCustomersResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof DeleteCustomersResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
    /**
     *
     * @type {Error}
     * @memberof ErrorResponse
     */
    'error': Error;
}
/**
 *
 * @export
 * @interface GenerateRequest
 */
export interface GenerateRequest {
    /**
     * Conversation ID to generate message from
     * @type {string}
     * @memberof GenerateRequest
     */
    'convo'?: string;
}
/**
 *
 * @export
 * @interface GenerateResponse
 */
export interface GenerateResponse {
    /**
     * The role of the message (customer, agent, or business)
     * @type {string}
     * @memberof GenerateResponse
     */
    'role'?: string;
    /**
     * The content of the message
     * @type {string}
     * @memberof GenerateResponse
     */
    'content'?: string;
    /**
     * The name of the sender
     * @type {string}
     * @memberof GenerateResponse
     */
    'name'?: string;
    /**
     * The time the message was sent
     * @type {string}
     * @memberof GenerateResponse
     */
    'time'?: string;
}
/**
 *
 * @export
 * @interface GetCustomerResponse
 */
export interface GetCustomerResponse {
    /**
     * The customers first name
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'firstName': string;
    /**
     * The customers last name
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'lastName': string;
    /**
     * The customers full name
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'name'?: string;
    /**
     * The customers email address
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'email'?: string | null;
    /**
     * The customers phone number
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'phone'?: string | null;
    /**
     * The customers profile image
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'img'?: string | null;
    /**
     * The customers neighborhood
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'neighborhood'?: string | null;
    /**
     * The customers city
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'city'?: string | null;
    /**
     * The customers 2-letter country code
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'country'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'line1'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'line2'?: string | null;
    /**
     * The customers postal code
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'postal_code'?: string | null;
    /**
     * The customers state, county, province, or region
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'state'?: string | null;
    /**
     * The customers town (only used in Japan)
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'town'?: string | null;
    /**
     *
     * @type {BlockInfo}
     * @memberof GetCustomerResponse
     */
    'blocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof GetCustomerResponse
     */
    'phoneBlocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof GetCustomerResponse
     */
    'emailBlocked'?: BlockInfo;
    /**
     * The date the customer joined the business
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'joined'?: string | null;
    /**
     * The customers stripe ID
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'stripe'?: string | null;
    /**
     * The customers stripe ID in the dev environment
     * @type {string}
     * @memberof GetCustomerResponse
     */
    'stripeDev'?: string | null;
}
/**
 *
 * @export
 * @interface Message
 */
export interface Message {
    /**
     * The role of the message (customer, agent, or business)
     * @type {string}
     * @memberof Message
     */
    'role'?: string;
    /**
     * The content of the message
     * @type {string}
     * @memberof Message
     */
    'content'?: string;
    /**
     * The name of the sender
     * @type {string}
     * @memberof Message
     */
    'name'?: string;
    /**
     * The time the message was sent
     * @type {string}
     * @memberof Message
     */
    'time'?: string;
}
/**
 *
 * @export
 * @interface MessageCreateRequest
 */
export interface MessageCreateRequest {
    /**
     * Conveersation ID this belonds to
     * @type {string}
     * @memberof MessageCreateRequest
     */
    'convo'?: string;
    /**
     *
     * @type {MessageGetResponseInner}
     * @memberof MessageCreateRequest
     */
    'message'?: MessageGetResponseInner;
}
/**
 *
 * @export
 * @interface MessageCreateResponse
 */
export interface MessageCreateResponse {
    /**
     *
     * @type {boolean}
     * @memberof MessageCreateResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof MessageCreateResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface MessageGetResponseInner
 */
export interface MessageGetResponseInner {
    /**
     * The role of the message (customer, agent, or business)
     * @type {string}
     * @memberof MessageGetResponseInner
     */
    'role'?: string;
    /**
     * The content of the message
     * @type {string}
     * @memberof MessageGetResponseInner
     */
    'content'?: string;
    /**
     * The name of the sender
     * @type {string}
     * @memberof MessageGetResponseInner
     */
    'name'?: string;
    /**
     * The time the message was sent
     * @type {string}
     * @memberof MessageGetResponseInner
     */
    'time'?: string;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    'type': string;
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    'param': string | null;
    /**
     *
     * @type {string}
     * @memberof ModelError
     */
    'code': string | null;
}
/**
 *
 * @export
 * @interface OperationResponse
 */
export interface OperationResponse {
    /**
     *
     * @type {boolean}
     * @memberof OperationResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof OperationResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ScheduleCreateRequest
 */
export interface ScheduleCreateRequest {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    '$customer'?: string;
    /**
     *
     * @type {any}
     * @memberof ScheduleCreateRequest
     */
    '$business'?: any | null;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    '$agent'?: string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    '$thread'?: string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ScheduleCreateRequest
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    'environment'?: string;
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    'scheduled'?: string;
    /**
     * The initial message to send to the customer
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    'initialMessage'?: string;
    /**
     * The initial message to send to the customer in HTML
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    'initialMessageHtml'?: string | null;
    /**
     * Whether the initial message has been sent
     * @type {boolean}
     * @memberof ScheduleCreateRequest
     */
    'sent'?: boolean;
    /**
     * Group this conversation is in
     * @type {string}
     * @memberof ScheduleCreateRequest
     */
    '$group'?: string;
}
/**
 *
 * @export
 * @interface ScheduleCreateResponse
 */
export interface ScheduleCreateResponse {
    /**
     *
     * @type {boolean}
     * @memberof ScheduleCreateResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof ScheduleCreateResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ScheduleGetResponse
 */
export interface ScheduleGetResponse {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ScheduleGetResponse
     */
    '$customer'?: string;
    /**
     * Business this conversation is with
     * @type {string}
     * @memberof ScheduleGetResponse
     */
    '$business'?: string;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ScheduleGetResponse
     */
    '$agent'?: string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ScheduleGetResponse
     */
    '$thread'?: string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ScheduleGetResponse
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ScheduleGetResponse
     */
    'environment'?: string;
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof ScheduleGetResponse
     */
    'scheduled'?: string;
    /**
     * The initial message to send to the customer
     * @type {string}
     * @memberof ScheduleGetResponse
     */
    'initialMessage'?: string;
    /**
     * The initial message to send to the customer in HTML
     * @type {string}
     * @memberof ScheduleGetResponse
     */
    'initialMessageHtml'?: string | null;
    /**
     * Whether the initial message has been sent
     * @type {boolean}
     * @memberof ScheduleGetResponse
     */
    'sent'?: boolean;
    /**
     * Group this conversation is in
     * @type {string}
     * @memberof ScheduleGetResponse
     */
    '$group'?: string;
}
/**
 *
 * @export
 * @interface ScheduleGroupCreateRequest
 */
export interface ScheduleGroupCreateRequest {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ScheduleGroupCreateRequest
     */
    '$customer'?: string;
    /**
     *
     * @type {any}
     * @memberof ScheduleGroupCreateRequest
     */
    '$business'?: any | null;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ScheduleGroupCreateRequest
     */
    '$agent'?: string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ScheduleGroupCreateRequest
     */
    '$thread'?: string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ScheduleGroupCreateRequest
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ScheduleGroupCreateRequest
     */
    'environment'?: string;
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof ScheduleGroupCreateRequest
     */
    'scheduled'?: string;
    /**
     * The initial message to send to the customer
     * @type {string}
     * @memberof ScheduleGroupCreateRequest
     */
    'initialMessage'?: string;
    /**
     * The initial message to send to the customer in HTML
     * @type {string}
     * @memberof ScheduleGroupCreateRequest
     */
    'initialMessageHtml'?: string | null;
    /**
     * Whether the initial message has been sent
     * @type {boolean}
     * @memberof ScheduleGroupCreateRequest
     */
    'sent'?: boolean;
    /**
     * Group this conversation is in
     * @type {string}
     * @memberof ScheduleGroupCreateRequest
     */
    '$group'?: string;
    /**
     * The delay in miliseconds between each conversation
     * @type {number}
     * @memberof ScheduleGroupCreateRequest
     */
    'delay'?: number;
    /**
     * Customers in this group
     * @type {Array<ScheduledConversationGroupAllOfCustomers>}
     * @memberof ScheduleGroupCreateRequest
     */
    'customers'?: Array<ScheduledConversationGroupAllOfCustomers>;
}
/**
 *
 * @export
 * @interface ScheduleGroupCreateResponse
 */
export interface ScheduleGroupCreateResponse {
    /**
     *
     * @type {boolean}
     * @memberof ScheduleGroupCreateResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof ScheduleGroupCreateResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ScheduleGroupGetResponse
 */
export interface ScheduleGroupGetResponse {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ScheduleGroupGetResponse
     */
    '$customer'?: string;
    /**
     * Business this conversation is with
     * @type {string}
     * @memberof ScheduleGroupGetResponse
     */
    '$business'?: string;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ScheduleGroupGetResponse
     */
    '$agent'?: string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ScheduleGroupGetResponse
     */
    '$thread'?: string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ScheduleGroupGetResponse
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ScheduleGroupGetResponse
     */
    'environment'?: string;
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof ScheduleGroupGetResponse
     */
    'scheduled'?: string;
    /**
     * The initial message to send to the customer
     * @type {string}
     * @memberof ScheduleGroupGetResponse
     */
    'initialMessage'?: string;
    /**
     * The initial message to send to the customer in HTML
     * @type {string}
     * @memberof ScheduleGroupGetResponse
     */
    'initialMessageHtml'?: string | null;
    /**
     * Whether the initial message has been sent
     * @type {boolean}
     * @memberof ScheduleGroupGetResponse
     */
    'sent'?: boolean;
    /**
     * Group this conversation is in
     * @type {string}
     * @memberof ScheduleGroupGetResponse
     */
    '$group'?: string;
    /**
     * The delay in miliseconds between each conversation
     * @type {number}
     * @memberof ScheduleGroupGetResponse
     */
    'delay'?: number;
    /**
     * Customers in this group
     * @type {Array<ScheduledConversationGroupAllOfCustomers>}
     * @memberof ScheduleGroupGetResponse
     */
    'customers'?: Array<ScheduledConversationGroupAllOfCustomers>;
}
/**
 *
 * @export
 * @interface ScheduleGroupRemoveResponse
 */
export interface ScheduleGroupRemoveResponse {
    /**
     *
     * @type {boolean}
     * @memberof ScheduleGroupRemoveResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof ScheduleGroupRemoveResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ScheduleGroupUpdateRequest
 */
export interface ScheduleGroupUpdateRequest {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    '$customer'?: string;
    /**
     * Business this conversation is with
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    '$business'?: string;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    '$agent'?: string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    '$thread'?: string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ScheduleGroupUpdateRequest
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    'environment'?: string;
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    'scheduled'?: string;
    /**
     * The initial message to send to the customer
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    'initialMessage'?: string;
    /**
     * The initial message to send to the customer in HTML
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    'initialMessageHtml'?: string | null;
    /**
     * Whether the initial message has been sent
     * @type {boolean}
     * @memberof ScheduleGroupUpdateRequest
     */
    'sent'?: boolean;
    /**
     * Group this conversation is in
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    '$group'?: string;
    /**
     * The delay in miliseconds between each conversation
     * @type {number}
     * @memberof ScheduleGroupUpdateRequest
     */
    'delay'?: number;
    /**
     * Customers in this group
     * @type {Array<ScheduledConversationGroupAllOfCustomers>}
     * @memberof ScheduleGroupUpdateRequest
     */
    'customers'?: Array<ScheduledConversationGroupAllOfCustomers>;
    /**
     * The ID of the scheduled conversation group to update
     * @type {string}
     * @memberof ScheduleGroupUpdateRequest
     */
    'id'?: string;
}
/**
 *
 * @export
 * @interface ScheduleGroupUpdateRequestAllOf
 */
export interface ScheduleGroupUpdateRequestAllOf {
    /**
     * The ID of the scheduled conversation group to update
     * @type {string}
     * @memberof ScheduleGroupUpdateRequestAllOf
     */
    'id'?: string;
}
/**
 *
 * @export
 * @interface ScheduleGroupUpdateResponse
 */
export interface ScheduleGroupUpdateResponse {
    /**
     *
     * @type {boolean}
     * @memberof ScheduleGroupUpdateResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof ScheduleGroupUpdateResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ScheduleRemoveResponse
 */
export interface ScheduleRemoveResponse {
    /**
     *
     * @type {boolean}
     * @memberof ScheduleRemoveResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof ScheduleRemoveResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ScheduleUpdateRequest
 */
export interface ScheduleUpdateRequest {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    '$customer'?: string;
    /**
     * Business this conversation is with
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    '$business'?: string;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    '$agent'?: string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    '$thread'?: string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ScheduleUpdateRequest
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'environment'?: string;
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'scheduled'?: string;
    /**
     * The initial message to send to the customer
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'initialMessage'?: string;
    /**
     * The initial message to send to the customer in HTML
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'initialMessageHtml'?: string | null;
    /**
     * Whether the initial message has been sent
     * @type {boolean}
     * @memberof ScheduleUpdateRequest
     */
    'sent'?: boolean;
    /**
     * Group this conversation is in
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    '$group'?: string;
    /**
     * The ID of the scheduled conversation to update
     * @type {string}
     * @memberof ScheduleUpdateRequest
     */
    'id'?: string;
}
/**
 *
 * @export
 * @interface ScheduleUpdateRequestAllOf
 */
export interface ScheduleUpdateRequestAllOf {
    /**
     * The ID of the scheduled conversation to update
     * @type {string}
     * @memberof ScheduleUpdateRequestAllOf
     */
    'id'?: string;
}
/**
 *
 * @export
 * @interface ScheduleUpdateResponse
 */
export interface ScheduleUpdateResponse {
    /**
     *
     * @type {boolean}
     * @memberof ScheduleUpdateResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof ScheduleUpdateResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface ScheduledConversation
 */
export interface ScheduledConversation {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ScheduledConversation
     */
    '$customer'?: string;
    /**
     * Business this conversation is with
     * @type {string}
     * @memberof ScheduledConversation
     */
    '$business'?: string;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ScheduledConversation
     */
    '$agent'?: string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ScheduledConversation
     */
    '$thread'?: string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ScheduledConversation
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ScheduledConversation
     */
    'environment'?: string;
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof ScheduledConversation
     */
    'scheduled'?: string;
    /**
     * The initial message to send to the customer
     * @type {string}
     * @memberof ScheduledConversation
     */
    'initialMessage'?: string;
    /**
     * The initial message to send to the customer in HTML
     * @type {string}
     * @memberof ScheduledConversation
     */
    'initialMessageHtml'?: string | null;
    /**
     * Whether the initial message has been sent
     * @type {boolean}
     * @memberof ScheduledConversation
     */
    'sent'?: boolean;
    /**
     * Group this conversation is in
     * @type {string}
     * @memberof ScheduledConversation
     */
    '$group'?: string;
}
/**
 *
 * @export
 * @interface ScheduledConversationAllOf
 */
export interface ScheduledConversationAllOf {
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof ScheduledConversationAllOf
     */
    'scheduled'?: string;
    /**
     * The initial message to send to the customer
     * @type {string}
     * @memberof ScheduledConversationAllOf
     */
    'initialMessage'?: string;
    /**
     * The initial message to send to the customer in HTML
     * @type {string}
     * @memberof ScheduledConversationAllOf
     */
    'initialMessageHtml'?: string | null;
    /**
     * Whether the initial message has been sent
     * @type {boolean}
     * @memberof ScheduledConversationAllOf
     */
    'sent'?: boolean;
    /**
     * Group this conversation is in
     * @type {string}
     * @memberof ScheduledConversationAllOf
     */
    '$group'?: string;
}
/**
 *
 * @export
 * @interface ScheduledConversationGroup
 */
export interface ScheduledConversationGroup {
    /**
     * Customer this conversation is with
     * @type {string}
     * @memberof ScheduledConversationGroup
     */
    '$customer'?: string;
    /**
     * Business this conversation is with
     * @type {string}
     * @memberof ScheduledConversationGroup
     */
    '$business'?: string;
    /**
     * Agent assigned to this conversation
     * @type {string}
     * @memberof ScheduledConversationGroup
     */
    '$agent'?: string;
    /**
     * Thread this conversation is in - this determines what context to pull when loading the conversation
     * @type {string}
     * @memberof ScheduledConversationGroup
     */
    '$thread'?: string;
    /**
     * Initial contexts to load when starting the conversation
     * @type {Array<string>}
     * @memberof ScheduledConversationGroup
     */
    'initialContexts'?: Array<string>;
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ScheduledConversationGroup
     */
    'environment'?: string;
    /**
     * ISO 8601 datetime string
     * @type {string}
     * @memberof ScheduledConversationGroup
     */
    'scheduled'?: string;
    /**
     * The initial message to send to the customer
     * @type {string}
     * @memberof ScheduledConversationGroup
     */
    'initialMessage'?: string;
    /**
     * The initial message to send to the customer in HTML
     * @type {string}
     * @memberof ScheduledConversationGroup
     */
    'initialMessageHtml'?: string | null;
    /**
     * Whether the initial message has been sent
     * @type {boolean}
     * @memberof ScheduledConversationGroup
     */
    'sent'?: boolean;
    /**
     * Group this conversation is in
     * @type {string}
     * @memberof ScheduledConversationGroup
     */
    '$group'?: string;
    /**
     * The delay in miliseconds between each conversation
     * @type {number}
     * @memberof ScheduledConversationGroup
     */
    'delay'?: number;
    /**
     * Customers in this group
     * @type {Array<ScheduledConversationGroupAllOfCustomers>}
     * @memberof ScheduledConversationGroup
     */
    'customers'?: Array<ScheduledConversationGroupAllOfCustomers>;
}
/**
 *
 * @export
 * @interface ScheduledConversationGroupAllOf
 */
export interface ScheduledConversationGroupAllOf {
    /**
     * The delay in miliseconds between each conversation
     * @type {number}
     * @memberof ScheduledConversationGroupAllOf
     */
    'delay'?: number;
    /**
     * Customers in this group
     * @type {Array<ScheduledConversationGroupAllOfCustomers>}
     * @memberof ScheduledConversationGroupAllOf
     */
    'customers'?: Array<ScheduledConversationGroupAllOfCustomers>;
}
/**
 *
 * @export
 * @interface ScheduledConversationGroupAllOfCustomers
 */
export interface ScheduledConversationGroupAllOfCustomers {
    /**
     * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
     * @type {string}
     * @memberof ScheduledConversationGroupAllOfCustomers
     */
    'environment'?: string;
    /**
     * Customer ID
     * @type {string}
     * @memberof ScheduledConversationGroupAllOfCustomers
     */
    'id'?: string;
}
/**
 *
 * @export
 * @interface UpdateCustomerRequest
 */
export interface UpdateCustomerRequest {
    /**
     * The customers first name
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'firstName'?: string;
    /**
     * The customers last name
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'lastName'?: string;
    /**
     * The customers full name
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'name'?: string;
    /**
     * The customers email address
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'email'?: string | null;
    /**
     * The customers phone number
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'phone'?: string | null;
    /**
     * The customers profile image
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'img'?: string | null;
    /**
     * The customers neighborhood
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'neighborhood'?: string | null;
    /**
     * The customers city
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'city'?: string | null;
    /**
     * The customers 2-letter country code
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'country'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'line1'?: string | null;
    /**
     * The customers street address
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'line2'?: string | null;
    /**
     * The customers postal code
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'postal_code'?: string | null;
    /**
     * The customers state, county, province, or region
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'state'?: string | null;
    /**
     * The customers town (only used in Japan)
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'town'?: string | null;
    /**
     *
     * @type {BlockInfo}
     * @memberof UpdateCustomerRequest
     */
    'blocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof UpdateCustomerRequest
     */
    'phoneBlocked'?: BlockInfo;
    /**
     *
     * @type {BlockInfo}
     * @memberof UpdateCustomerRequest
     */
    'emailBlocked'?: BlockInfo;
    /**
     * The date the customer joined the business
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'joined'?: string | null;
    /**
     * The customers stripe ID
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'stripe'?: string | null;
    /**
     * The customers stripe ID in the dev environment
     * @type {string}
     * @memberof UpdateCustomerRequest
     */
    'stripeDev'?: string | null;
}
/**
 *
 * @export
 * @interface UpdateCustomerResponse
 */
export interface UpdateCustomerResponse {
    /**
     *
     * @type {boolean}
     * @memberof UpdateCustomerResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof UpdateCustomerResponse
     */
    'error'?: Error;
}
/**
 *
 * @export
 * @interface UpdateCustomersRequest
 */
export interface UpdateCustomersRequest {
    /**
     *
     * @type {Array<Customer>}
     * @memberof UpdateCustomersRequest
     */
    'customers'?: Array<Customer>;
}
/**
 *
 * @export
 * @interface UpdateCustomersResponse
 */
export interface UpdateCustomersResponse {
    /**
     *
     * @type {boolean}
     * @memberof UpdateCustomersResponse
     */
    'success': boolean;
    /**
     *
     * @type {Error}
     * @memberof UpdateCustomersResponse
     */
    'error'?: Error;
}

/**
 * Scout9Api - axios parameter creator
 * @export
 */
export const Scout9ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *
         * @summary Create a new conversation
         * @param {ConversationCreateRequest} conversationCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversation: async (conversationCreateRequest: ConversationCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationCreateRequest' is not null or undefined
            assertParamExists('createConversation', 'conversationCreateRequest', conversationCreateRequest)
            const localVarPath = `/v1/conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conversationCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new customer
         * @param {CreateCustomerRequest} createCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer: async (createCustomerRequest: CreateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCustomerRequest' is not null or undefined
            assertParamExists('createCustomer', 'createCustomerRequest', createCustomerRequest)
            const localVarPath = `/v1/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates new customers
         * @param {CreateCustomersRequest} createCustomersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomers: async (createCustomersRequest: CreateCustomersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createCustomersRequest' is not null or undefined
            assertParamExists('createCustomers', 'createCustomersRequest', createCustomersRequest)
            const localVarPath = `/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createCustomersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create and send message
         * @param {MessageCreateRequest} messageCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessage: async (messageCreateRequest: MessageCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'messageCreateRequest' is not null or undefined
            assertParamExists('createMessage', 'messageCreateRequest', messageCreateRequest)
            const localVarPath = `/v1/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(messageCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new scheduled conversation
         * @param {ScheduleCreateRequest} scheduleCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchedule: async (scheduleCreateRequest: ScheduleCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleCreateRequest' is not null or undefined
            assertParamExists('createSchedule', 'scheduleCreateRequest', scheduleCreateRequest)
            const localVarPath = `/v1/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new schedule group
         * @param {ScheduleGroupCreateRequest} scheduleGroupCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScheduleGroup: async (scheduleGroupCreateRequest: ScheduleGroupCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleGroupCreateRequest' is not null or undefined
            assertParamExists('createScheduleGroup', 'scheduleGroupCreateRequest', scheduleGroupCreateRequest)
            const localVarPath = `/v1/scheduleGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleGroupCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id Schedule ID to delete schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversation: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteConversation', 'id', id)
            const localVarPath = `/v1/conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a customer
         * @param {string} id Customer ID to delete customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCustomer', 'id', id)
            const localVarPath = `/v1/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes multiple customers
         * @param {string} id Customer IDs to delete multiple customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomers: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteCustomers', 'id', id)
            const localVarPath = `/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id Schedule ID to delete schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchedule: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteSchedule', 'id', id)
            const localVarPath = `/v1/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a schedule group
         * @param {string} id Schedule group ID to delete schedule group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduleGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteScheduleGroup', 'id', id)
            const localVarPath = `/v1/scheduleGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Generate a message from conversation
         * @param {GenerateRequest} generateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate: async (generateRequest: GenerateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateRequest' is not null or undefined
            assertParamExists('generate', 'generateRequest', generateRequest)
            const localVarPath = `/v1/generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a conversation
         * @param {string} id Conversation ID to get conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getConversation', 'id', id)
            const localVarPath = `/v1/conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a customer
         * @param {string} id Customer ID to get customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCustomer', 'id', id)
            const localVarPath = `/v1/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all or specific set of customers
         * @param {string} [id] Optional get specific customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers: async (id?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all messages from a conversation
         * @param {string} id Conversation ID to get messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMessage', 'id', id)
            const localVarPath = `/v1/messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a schedule
         * @param {string} id Schedule ID to get schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedule: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSchedule', 'id', id)
            const localVarPath = `/v1/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a schedule group
         * @param {string} id Schedule group ID to get schedule group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getScheduleGroup', 'id', id)
            const localVarPath = `/v1/scheduleGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a conversation
         * @param {ConversationUpdateRequest} conversationUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversation: async (conversationUpdateRequest: ConversationUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'conversationUpdateRequest' is not null or undefined
            assertParamExists('updateConversation', 'conversationUpdateRequest', conversationUpdateRequest)
            const localVarPath = `/v1/conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(conversationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates a customer
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer: async (updateCustomerRequest: UpdateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateCustomerRequest' is not null or undefined
            assertParamExists('updateCustomer', 'updateCustomerRequest', updateCustomerRequest)
            const localVarPath = `/v1/customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates multiple customers
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomers: async (updateCustomerRequest: UpdateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateCustomerRequest' is not null or undefined
            assertParamExists('updateCustomers', 'updateCustomerRequest', updateCustomerRequest)
            const localVarPath = `/v1/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates a schedule
         * @param {ScheduleUpdateRequest} scheduleUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchedule: async (scheduleUpdateRequest: ScheduleUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleUpdateRequest' is not null or undefined
            assertParamExists('updateSchedule', 'scheduleUpdateRequest', scheduleUpdateRequest)
            const localVarPath = `/v1/schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates a schedule group
         * @param {ScheduleGroupUpdateRequest} scheduleGroupUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduleGroup: async (scheduleGroupUpdateRequest: ScheduleGroupUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'scheduleGroupUpdateRequest' is not null or undefined
            assertParamExists('updateScheduleGroup', 'scheduleGroupUpdateRequest', scheduleGroupUpdateRequest)
            const localVarPath = `/v1/scheduleGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(scheduleGroupUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Scout9Api - functional programming interface
 * @export
 */
export const Scout9ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Scout9ApiAxiosParamCreator(configuration)
    return {
        /**
         *
         * @summary Create a new conversation
         * @param {ConversationCreateRequest} conversationCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createConversation(conversationCreateRequest: ConversationCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createConversation(conversationCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a new customer
         * @param {CreateCustomerRequest} createCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomer(createCustomerRequest: CreateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomer(createCustomerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates new customers
         * @param {CreateCustomersRequest} createCustomersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createCustomers(createCustomersRequest: CreateCustomersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createCustomers(createCustomersRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create and send message
         * @param {MessageCreateRequest} messageCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createMessage(messageCreateRequest: MessageCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createMessage(messageCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a new scheduled conversation
         * @param {ScheduleCreateRequest} scheduleCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createSchedule(scheduleCreateRequest: ScheduleCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createSchedule(scheduleCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a new schedule group
         * @param {ScheduleGroupCreateRequest} scheduleGroupCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createScheduleGroup(scheduleGroupCreateRequest: ScheduleGroupCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleGroupCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createScheduleGroup(scheduleGroupCreateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id Schedule ID to delete schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteConversation(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationRemoveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteConversation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a customer
         * @param {string} id Customer ID to delete customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomer(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCustomerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes multiple customers
         * @param {string} id Customer IDs to delete multiple customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteCustomers(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCustomersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteCustomers(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id Schedule ID to delete schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteSchedule(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleRemoveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteSchedule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a schedule group
         * @param {string} id Schedule group ID to delete schedule group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteScheduleGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleGroupRemoveResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteScheduleGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Generate a message from conversation
         * @param {GenerateRequest} generateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generate(generateRequest: GenerateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generate(generateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a conversation
         * @param {string} id Conversation ID to get conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConversation(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConversation(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a customer
         * @param {string} id Customer ID to get customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomer(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomerRequest>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets all or specific set of customers
         * @param {string} [id] Optional get specific customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomers(id?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Customer>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomers(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all messages from a conversation
         * @param {string} id Conversation ID to get messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMessage(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageGetResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMessage(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a schedule
         * @param {string} id Schedule ID to get schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSchedule(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSchedule(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a schedule group
         * @param {string} id Schedule group ID to get schedule group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getScheduleGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleGroupGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduleGroup(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update a conversation
         * @param {ConversationUpdateRequest} conversationUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateConversation(conversationUpdateRequest: ConversationUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateConversation(conversationUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates a customer
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomer(updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCustomerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomer(updateCustomerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates multiple customers
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateCustomers(updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCustomersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateCustomers(updateCustomerRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates a schedule
         * @param {ScheduleUpdateRequest} scheduleUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateSchedule(scheduleUpdateRequest: ScheduleUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateSchedule(scheduleUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates a schedule group
         * @param {ScheduleGroupUpdateRequest} scheduleGroupUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateScheduleGroup(scheduleGroupUpdateRequest: ScheduleGroupUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ScheduleGroupUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateScheduleGroup(scheduleGroupUpdateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * Scout9Api - factory interface
 * @export
 */
export const Scout9ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Scout9ApiFp(configuration)
    return {
        /**
         *
         * @summary Create a new conversation
         * @param {ConversationCreateRequest} conversationCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createConversation(conversationCreateRequest: ConversationCreateRequest, options?: any): AxiosPromise<ConversationCreateResponse> {
            return localVarFp.createConversation(conversationCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a new customer
         * @param {CreateCustomerRequest} createCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomer(createCustomerRequest: CreateCustomerRequest, options?: any): AxiosPromise<CreateCustomerResponse> {
            return localVarFp.createCustomer(createCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates new customers
         * @param {CreateCustomersRequest} createCustomersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createCustomers(createCustomersRequest: CreateCustomersRequest, options?: any): AxiosPromise<CreateCustomersResponse> {
            return localVarFp.createCustomers(createCustomersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create and send message
         * @param {MessageCreateRequest} messageCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createMessage(messageCreateRequest: MessageCreateRequest, options?: any): AxiosPromise<MessageCreateResponse> {
            return localVarFp.createMessage(messageCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a new scheduled conversation
         * @param {ScheduleCreateRequest} scheduleCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createSchedule(scheduleCreateRequest: ScheduleCreateRequest, options?: any): AxiosPromise<ScheduleCreateResponse> {
            return localVarFp.createSchedule(scheduleCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a new schedule group
         * @param {ScheduleGroupCreateRequest} scheduleGroupCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createScheduleGroup(scheduleGroupCreateRequest: ScheduleGroupCreateRequest, options?: any): AxiosPromise<ScheduleGroupCreateResponse> {
            return localVarFp.createScheduleGroup(scheduleGroupCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id Schedule ID to delete schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteConversation(id: string, options?: any): AxiosPromise<ConversationRemoveResponse> {
            return localVarFp.deleteConversation(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a customer
         * @param {string} id Customer ID to delete customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomer(id: string, options?: any): AxiosPromise<DeleteCustomerResponse> {
            return localVarFp.deleteCustomer(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes multiple customers
         * @param {string} id Customer IDs to delete multiple customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCustomers(id: string, options?: any): AxiosPromise<DeleteCustomersResponse> {
            return localVarFp.deleteCustomers(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id Schedule ID to delete schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteSchedule(id: string, options?: any): AxiosPromise<ScheduleRemoveResponse> {
            return localVarFp.deleteSchedule(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a schedule group
         * @param {string} id Schedule group ID to delete schedule group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteScheduleGroup(id: string, options?: any): AxiosPromise<ScheduleGroupRemoveResponse> {
            return localVarFp.deleteScheduleGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Generate a message from conversation
         * @param {GenerateRequest} generateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate(generateRequest: GenerateRequest, options?: any): AxiosPromise<GenerateResponse> {
            return localVarFp.generate(generateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a conversation
         * @param {string} id Conversation ID to get conversation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConversation(id: string, options?: any): AxiosPromise<ConversationGetResponse> {
            return localVarFp.getConversation(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a customer
         * @param {string} id Customer ID to get customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomer(id: string, options?: any): AxiosPromise<CreateCustomerRequest> {
            return localVarFp.getCustomer(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all or specific set of customers
         * @param {string} [id] Optional get specific customers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(id?: string, options?: any): AxiosPromise<Array<Customer>> {
            return localVarFp.getCustomers(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all messages from a conversation
         * @param {string} id Conversation ID to get messages
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMessage(id: string, options?: any): AxiosPromise<Array<MessageGetResponseInner>> {
            return localVarFp.getMessage(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a schedule
         * @param {string} id Schedule ID to get schedule
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSchedule(id: string, options?: any): AxiosPromise<ScheduleCreateResponse> {
            return localVarFp.getSchedule(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a schedule group
         * @param {string} id Schedule group ID to get schedule group
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getScheduleGroup(id: string, options?: any): AxiosPromise<ScheduleGroupGetResponse> {
            return localVarFp.getScheduleGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a conversation
         * @param {ConversationUpdateRequest} conversationUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateConversation(conversationUpdateRequest: ConversationUpdateRequest, options?: any): AxiosPromise<ConversationUpdateResponse> {
            return localVarFp.updateConversation(conversationUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a customer
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomer(updateCustomerRequest: UpdateCustomerRequest, options?: any): AxiosPromise<UpdateCustomerResponse> {
            return localVarFp.updateCustomer(updateCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates multiple customers
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCustomers(updateCustomerRequest: UpdateCustomerRequest, options?: any): AxiosPromise<UpdateCustomersResponse> {
            return localVarFp.updateCustomers(updateCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a schedule
         * @param {ScheduleUpdateRequest} scheduleUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSchedule(scheduleUpdateRequest: ScheduleUpdateRequest, options?: any): AxiosPromise<ScheduleUpdateResponse> {
            return localVarFp.updateSchedule(scheduleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a schedule group
         * @param {ScheduleGroupUpdateRequest} scheduleGroupUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateScheduleGroup(scheduleGroupUpdateRequest: ScheduleGroupUpdateRequest, options?: any): AxiosPromise<ScheduleGroupUpdateResponse> {
            return localVarFp.updateScheduleGroup(scheduleGroupUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Scout9Api - object-oriented interface
 * @export
 * @class Scout9Api
 * @extends {BaseAPI}
 */
export class Scout9Api extends BaseAPI {
    /**
     *
     * @summary Create a new conversation
     * @param {ConversationCreateRequest} conversationCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public createConversation(conversationCreateRequest: ConversationCreateRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).createConversation(conversationCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Creates a new customer
     * @param {CreateCustomerRequest} createCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public createCustomer(createCustomerRequest: CreateCustomerRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).createCustomer(createCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Creates new customers
     * @param {CreateCustomersRequest} createCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public createCustomers(createCustomersRequest: CreateCustomersRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).createCustomers(createCustomersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Create and send message
     * @param {MessageCreateRequest} messageCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public createMessage(messageCreateRequest: MessageCreateRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).createMessage(messageCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Creates a new scheduled conversation
     * @param {ScheduleCreateRequest} scheduleCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public createSchedule(scheduleCreateRequest: ScheduleCreateRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).createSchedule(scheduleCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Creates a new schedule group
     * @param {ScheduleGroupCreateRequest} scheduleGroupCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public createScheduleGroup(scheduleGroupCreateRequest: ScheduleGroupCreateRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).createScheduleGroup(scheduleGroupCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Deletes a schedule
     * @param {string} id Schedule ID to delete schedule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public deleteConversation(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).deleteConversation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Deletes a customer
     * @param {string} id Customer ID to delete customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public deleteCustomer(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).deleteCustomer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Deletes multiple customers
     * @param {string} id Customer IDs to delete multiple customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public deleteCustomers(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).deleteCustomers(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Deletes a schedule
     * @param {string} id Schedule ID to delete schedule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public deleteSchedule(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).deleteSchedule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Deletes a schedule group
     * @param {string} id Schedule group ID to delete schedule group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public deleteScheduleGroup(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).deleteScheduleGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Generate a message from conversation
     * @param {GenerateRequest} generateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public generate(generateRequest: GenerateRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).generate(generateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Gets a conversation
     * @param {string} id Conversation ID to get conversation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public getConversation(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).getConversation(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Gets a customer
     * @param {string} id Customer ID to get customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public getCustomer(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).getCustomer(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Gets all or specific set of customers
     * @param {string} [id] Optional get specific customers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public getCustomers(id?: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).getCustomers(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Get all messages from a conversation
     * @param {string} id Conversation ID to get messages
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public getMessage(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).getMessage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Gets a schedule
     * @param {string} id Schedule ID to get schedule
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public getSchedule(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).getSchedule(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Gets a schedule group
     * @param {string} id Schedule group ID to get schedule group
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public getScheduleGroup(id: string, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).getScheduleGroup(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Update a conversation
     * @param {ConversationUpdateRequest} conversationUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public updateConversation(conversationUpdateRequest: ConversationUpdateRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).updateConversation(conversationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Updates a customer
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public updateCustomer(updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).updateCustomer(updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Updates multiple customers
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public updateCustomers(updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).updateCustomers(updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Updates a schedule
     * @param {ScheduleUpdateRequest} scheduleUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public updateSchedule(scheduleUpdateRequest: ScheduleUpdateRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).updateSchedule(scheduleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *
     * @summary Updates a schedule group
     * @param {ScheduleGroupUpdateRequest} scheduleGroupUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    public updateScheduleGroup(scheduleGroupUpdateRequest: ScheduleGroupUpdateRequest, options?: AxiosRequestConfig) {
        return Scout9ApiFp(this.configuration).updateScheduleGroup(scheduleGroupUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


