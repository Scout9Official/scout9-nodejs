/* tslint:disable */
/* eslint-disable */
/**
 * Scout9 API
 * Scout9 APIs for managing Scout9 users and conversations with your Scout9 agents
 *
 * The version of the OpenAPI document: 1.0.0-alpha.0.0.9
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 *
 * @export
 * @interface Agent
 */
export interface Agent {
  /**
   * Agent first name
   * @type {string}
   * @memberof Agent
   */
  'firstName'?: string;
  /**
   * Agent last name
   * @type {string}
   * @memberof Agent
   */
  'lastName'?: string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof Agent
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof Agent
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof Agent
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof Agent
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof Agent
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof Agent
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof Agent
   */
  'title'?: string;
  /**
   *
   * @type {AgentContext}
   * @memberof Agent
   */
  'context'?: AgentContext;
  /**
   * Transcripts of the agent
   * @type {Array<string>}
   * @memberof Agent
   */
  'transcripts'?: Array<string>;
  /**
   * Audios of the agent
   * @type {Array<string>}
   * @memberof Agent
   */
  'audios'?: Array<string>;
  /**
   * Locations ids the agent is included in
   * @type {Array<string>}
   * @memberof Agent
   */
  'includedLocations'?: Array<string>;
  /**
   * Locations id the agent is excluded from
   * @type {Array<string>}
   * @memberof Agent
   */
  'excludedLocations'?: Array<string>;
}
/**
 * @type AgentContext
 * Context of the agent, defaults to \"Agent\"
 * @export
 */
export type AgentContext = Array<string> | string;

/**
 *
 * @export
 * @interface AgentDeleteResponse
 */
export interface AgentDeleteResponse {
  /**
   *
   * @type {boolean}
   * @memberof AgentDeleteResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof AgentDeleteResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof AgentDeleteResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface AgentsDeleteResponse
 */
export interface AgentsDeleteResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof AgentsDeleteResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof AgentsDeleteResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface AndLogic
 */
export interface AndLogic {
  /**
   *
   * @type {Array<Logic>}
   * @memberof AndLogic
   */
  'and': Array<Logic>;
}
/**
 * @type AnyValue
 * @export
 */
export type AnyValue = boolean | number | object | string;

/**
 *
 * @export
 * @interface ApiOperation
 */
export interface ApiOperation {
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ApiOperation
   */
  'time': string;
  /**
   * The model that was created, updated, or deleted
   * @type {string}
   * @memberof ApiOperation
   */
  'model': string;
  /**
   * The method that was called
   * @type {string}
   * @memberof ApiOperation
   */
  'method': ApiOperationMethodEnum;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof ApiOperation
   */
  'results': { [key: string]: any; };
}

export const ApiOperationMethodEnum = {
  Get: 'get',
  Post: 'post',
  Put: 'put',
  Delete: 'delete',
  Patch: 'patch'
} as const;

export type ApiOperationMethodEnum = typeof ApiOperationMethodEnum[keyof typeof ApiOperationMethodEnum];

/**
 *
 * @export
 * @interface BlockInfo
 */
export interface BlockInfo {
  /**
   *
   * @type {string}
   * @memberof BlockInfo
   */
  'message'?: string;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof BlockInfo
   */
  'time'?: string;
}
/**
 * @type Condition
 * @export
 */
export type Condition = EqualityCondition | ExistsCondition | RegexCondition;

/**
 *
 * @export
 * @interface ConditionBase
 */
export interface ConditionBase {
  /**
   *
   * @type {string}
   * @memberof ConditionBase
   */
  'path': string;
  /**
   *
   * @type {Operator}
   * @memberof ConditionBase
   */
  'operator': Operator;
  /**
   *
   * @type {any}
   * @memberof ConditionBase
   */
  'value'?: any;
  /**
   *
   * @type {boolean}
   * @memberof ConditionBase
   */
  'external'?: boolean;
}
/**
 *
 * @export
 * @interface ConditionLogic
 */
export interface ConditionLogic {
  /**
   *
   * @type {Condition}
   * @memberof ConditionLogic
   */
  'condition': Condition;
}
/**
 *
 * @export
 * @interface Context
 */
export interface Context {
  /**
   * The name of the context
   * @type {string}
   * @memberof Context
   */
  'name': string;
  /**
   * Whether or not the context is modifiable
   * @type {boolean}
   * @memberof Context
   */
  'modifiable'?: boolean;
  /**
   * The description of the context
   * @type {string}
   * @memberof Context
   */
  'description'?: string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof Context
   */
  'detection'?: ContextDetectionParams;
  /**
   * The API to use for context detection
   * @type {string}
   * @memberof Context
   */
  'detectionApi'?: string;
  /**
   * The ID column of the context
   * @type {string}
   * @memberof Context
   */
  'idColumn'?: string;
  /**
   * The columns of the context
   * @type {Array<string>}
   * @memberof Context
   */
  'columns'?: Array<string>;
  /**
   * The required columns of the context
   * @type {Array<string>}
   * @memberof Context
   */
  'requiredColumns'?: Array<string>;
  /**
   * Whether or not to force NER
   * @type {boolean}
   * @memberof Context
   */
  'forceNER'?: boolean;
  /**
   *
   * @type {ContextModel}
   * @memberof Context
   */
  'model'?: ContextModel;
}
/**
 *
 * @export
 * @interface ContextDetectionDocument
 */
export interface ContextDetectionDocument {
  /**
   * The languages the entity is available in
   * @type {string}
   * @memberof ContextDetectionDocument
   */
  'language'?: string;
  /**
   *
   * @type {string}
   * @memberof ContextDetectionDocument
   */
  'text': string;
  /**
   *
   * @type {string}
   * @memberof ContextDetectionDocument
   */
  'intent'?: string;
}
/**
 *
 * @export
 * @interface ContextDetectionEntity
 */
export interface ContextDetectionEntity {
  /**
   * The utterance ID of the entity, if this is not provided then it will default to the context model id. If this is provided, the utterance of this entity wont be able to point to a context data record within the associated data table.
   * @type {string}
   * @memberof ContextDetectionEntity
   */
  'utteranceId'?: string;
  /**
   * The classification of the given text
   * @type {string}
   * @memberof ContextDetectionEntity
   */
  'option': string;
  /**
   * The languages the entity is available in
   * @type {Array<string>}
   * @memberof ContextDetectionEntity
   */
  'languages'?: Array<string>;
  /**
   *
   * @type {Array<string>}
   * @memberof ContextDetectionEntity
   */
  'text': Array<string>;
}
/**
 *
 * @export
 * @interface ContextDetectionParams
 */
export interface ContextDetectionParams {
  /**
   *
   * @type {Array<ContextDetectionEntity>}
   * @memberof ContextDetectionParams
   */
  'entities': Array<ContextDetectionEntity>;
  /**
   *
   * @type {Array<ContextDetectionDocument>}
   * @memberof ContextDetectionParams
   */
  'documents': Array<ContextDetectionDocument>;
  /**
   * The activation intent of the context
   * @type {string}
   * @memberof ContextDetectionParams
   */
  'activationIntent'?: string;
  /**
   *
   * @type {Array<ContextDetectionTest>}
   * @memberof ContextDetectionParams
   */
  'test'?: Array<ContextDetectionTest>;
}
/**
 *
 * @export
 * @interface ContextDetectionTest
 */
export interface ContextDetectionTest {
  /**
   *
   * @type {string}
   * @memberof ContextDetectionTest
   */
  'language'?: string;
  /**
   *
   * @type {string}
   * @memberof ContextDetectionTest
   */
  'text': string;
  /**
   *
   * @type {ContextDetectionTestExpected}
   * @memberof ContextDetectionTest
   */
  'expected': ContextDetectionTestExpected;
}
/**
 * The expected result of the test
 * @export
 * @interface ContextDetectionTestExpected
 */
export interface ContextDetectionTestExpected {
  /**
   *
   * @type {string}
   * @memberof ContextDetectionTestExpected
   */
  'intent': string;
  /**
   *
   * @type {Array<ParsedContextEntity>}
   * @memberof ContextDetectionTestExpected
   */
  'entities': Array<ParsedContextEntity>;
}
/**
 * The model to use for context detection
 * @export
 * @interface ContextModel
 */
export interface ContextModel {
  /**
   * The last time the model was updated
   * @type {string}
   * @memberof ContextModel
   */
  'lastUpdate': string;
  /**
   * The reference to the model
   * @type {string}
   * @memberof ContextModel
   */
  'ref': string;
}
/**
 * @type ContextRowValue
 * @export
 */
export type ContextRowValue = boolean | number | string;

/**
 *
 * @export
 * @interface ContextTestRequest
 */
export interface ContextTestRequest {
  /**
   * The context id to test
   * @type {string}
   * @memberof ContextTestRequest
   */
  'context': string;
  /**
   * The text to test the context against
   * @type {string}
   * @memberof ContextTestRequest
   */
  'text'?: string;
  /**
   * The language to test the context against
   * @type {string}
   * @memberof ContextTestRequest
   */
  'language'?: string;
  /**
   *
   * @type {Array<ContextDetectionTest>}
   * @memberof ContextTestRequest
   */
  'data'?: Array<ContextDetectionTest>;
  /**
   * If true, the context will be saved to the database as an update call
   * @type {boolean}
   * @memberof ContextTestRequest
   */
  'save'?: boolean;
}
/**
 *
 * @export
 * @interface ContextTestResponse
 */
export interface ContextTestResponse {
  /**
   * The context id to test
   * @type {string}
   * @memberof ContextTestResponse
   */
  'message': string;
  /**
   * Parsed data results of the text input for the specific context model
   * @type {{ [key: string]: any; }}
   * @memberof ContextTestResponse
   */
  'parsed'?: { [key: string]: any; };
  /**
   * Success percentage of the context detection in decimal format
   * @type {number}
   * @memberof ContextTestResponse
   */
  'success': number;
}
/**
 *
 * @export
 * @interface Conversation
 */
export interface Conversation {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof Conversation
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof Conversation
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof Conversation
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof Conversation
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof Conversation
   */
  'environment': ConversationEnvironment;
}


/**
 *
 * @export
 * @interface ConversationAllOf
 */
export interface ConversationAllOf {
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof ConversationAllOf
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ConversationAllOf
   */
  'environment': ConversationEnvironment;
}


/**
 * Base props all conversation types will have
 * @export
 * @interface ConversationBase
 */
export interface ConversationBase {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ConversationBase
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ConversationBase
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ConversationBase
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
}
/**
 * Environment properties for the conversation
 * @export
 * @interface ConversationBaseEnvironmentProps
 */
export interface ConversationBaseEnvironmentProps {
  /**
   * HTML subject line
   * @type {string}
   * @memberof ConversationBaseEnvironmentProps
   */
  'subject'?: string;
  /**
   * Used to sync email messages with the conversation
   * @type {string}
   * @memberof ConversationBaseEnvironmentProps
   */
  'platformEmailThreadId'?: string;
}
/**
 *
 * @export
 * @interface ConversationContextField
 */
export interface ConversationContextField {
  /**
   * The ID of the context
   * @type {string}
   * @memberof ConversationContextField
   */
  'id': string;
  /**
   * The time the context was created
   * @type {string}
   * @memberof ConversationContextField
   */
  'time'?: string;
  /**
   * The context of the conversation
   * @type {string}
   * @memberof ConversationContextField
   */
  'context': string;
  /**
   * The note of the conversation
   * @type {string}
   * @memberof ConversationContextField
   */
  'note'?: string;
  /**
   * The metadata of the conversation
   * @type {object}
   * @memberof ConversationContextField
   */
  'metadata'?: object;
  /**
   *
   * @type {Logic}
   * @memberof ConversationContextField
   */
  'logic'?: Logic;
  /**
   * The conditions of the conversation
   * @type {Array<ConversationContextGroup>}
   * @memberof ConversationContextField
   * @deprecated
   */
  'conditions'?: Array<ConversationContextGroup>;
  /**
   * The triggers of the conversation
   * @type {Array<string>}
   * @memberof ConversationContextField
   */
  'triggers'?: Array<string>;
}
/**
 *
 * @export
 * @interface ConversationContextFieldCondition
 */
export interface ConversationContextFieldCondition {
  /**
   * The key of the condition
   * @type {string}
   * @memberof ConversationContextFieldCondition
   */
  'key': string;
  /**
   * The operator of the condition or query
   * @type {string}
   * @memberof ConversationContextFieldCondition
   */
  'operator': ConversationContextFieldConditionOperatorEnum;
  /**
   * The regex of the condition
   * @type {string}
   * @memberof ConversationContextFieldCondition
   */
  'regex'?: string;
  /**
   *
   * @type {AnyValue}
   * @memberof ConversationContextFieldCondition
   */
  'value': AnyValue;
}

export const ConversationContextFieldConditionOperatorEnum = {
  Eq: 'eq',
  Equal: 'equal',
  Ne: 'ne',
  NotEquals: 'not-equals',
  Gt: 'gt',
  GreaterThan: 'greater-than',
  Gte: 'gte',
  GreaterThanEquals: 'greater-than-equals',
  Lt: 'lt',
  LessThan: 'less-than',
  Lte: 'lte',
  LessThanEquals: 'less-than-equals',
  ArrayContains: 'array-contains',
  In: 'in',
  ArrayContainsAny: 'array-contains-any',
  NotIn: 'not-in',
  Exists: 'exists',
  NotExists: 'notExists',
  Contains: 'contains',
  NotContains: 'notContains',
  StartsWith: 'startsWith',
  EndsWith: 'endsWith'
} as const;

export type ConversationContextFieldConditionOperatorEnum = typeof ConversationContextFieldConditionOperatorEnum[keyof typeof ConversationContextFieldConditionOperatorEnum];

/**
 *
 * @export
 * @interface ConversationContextGroup
 */
export interface ConversationContextGroup {
  /**
   * The conditions of the conversation
   * @type {Array<ConversationContextFieldCondition>}
   * @memberof ConversationContextGroup
   */
  'conditions': Array<ConversationContextFieldCondition>;
}
/**
 *
 * @export
 * @interface ConversationCreateRequest
 */
export interface ConversationCreateRequest {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ConversationCreateRequest
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ConversationCreateRequest
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ConversationCreateRequest
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof ConversationCreateRequest
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ConversationCreateRequest
   */
  'environment': ConversationEnvironment;
  /**
   *
   * @type {ConversationCreateRequestBaseWorkflow}
   * @memberof ConversationCreateRequest
   */
  '$workflow'?: ConversationCreateRequestBaseWorkflow;
}


/**
 *
 * @export
 * @interface ConversationCreateRequestBase
 */
export interface ConversationCreateRequestBase {
  /**
   *
   * @type {ConversationCreateRequestBaseWorkflow}
   * @memberof ConversationCreateRequestBase
   */
  '$workflow'?: ConversationCreateRequestBaseWorkflow;
}
/**
 * @type ConversationCreateRequestBaseWorkflow
 * @export
 */
export type ConversationCreateRequestBaseWorkflow = Workflow | string;

/**
 *
 * @export
 * @interface ConversationCreateResponse
 */
export interface ConversationCreateResponse {
  /**
   *
   * @type {boolean}
   * @memberof ConversationCreateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ConversationCreateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ConversationCreateResponse
   */
  'id': string;
  /**
   * The client web url of the conversation
   * @type {string}
   * @memberof ConversationCreateResponse
   */
  'clientWebUrl'?: string;
  /**
   * The agent web url of the conversation (requires phone two-factor authentication)
   * @type {string}
   * @memberof ConversationCreateResponse
   */
  'agentWebUrl'?: string;
  /**
   * The agent test web url of the conversation, used for testing the conversation without notifying the customer
   * @type {string}
   * @memberof ConversationCreateResponse
   */
  'agentTestWebUrl'?: string;
  /**
   * ISO 8601 date string of when the conversation was initiated
   * @type {string}
   * @memberof ConversationCreateResponse
   */
  'initiated': string;
}
/**
 *
 * @export
 * @interface ConversationCreateResponseAllOf
 */
export interface ConversationCreateResponseAllOf {
  /**
   * ISO 8601 date string of when the conversation was initiated
   * @type {string}
   * @memberof ConversationCreateResponseAllOf
   */
  'initiated': string;
}
/**
 * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
 * @export
 * @enum {string}
 */

export const ConversationEnvironment = {
  Phone: 'phone',
  Web: 'web',
  Email: 'email'
} as const;

export type ConversationEnvironment = typeof ConversationEnvironment[keyof typeof ConversationEnvironment];


/**
 *
 * @export
 * @interface ConversationGetResponse
 */
export interface ConversationGetResponse {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ConversationGetResponse
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ConversationGetResponse
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ConversationGetResponse
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof ConversationGetResponse
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ConversationGetResponse
   */
  'environment': ConversationEnvironment;
  /**
   * The client web url of the conversation
   * @type {string}
   * @memberof ConversationGetResponse
   */
  'clientWebUrl'?: string;
  /**
   * The agent web url of the conversation (requires phone two-factor authentication)
   * @type {string}
   * @memberof ConversationGetResponse
   */
  'agentWebUrl'?: string;
  /**
   * The agent test web url of the conversation, used for testing the conversation without notifying the customer
   * @type {string}
   * @memberof ConversationGetResponse
   */
  'agentTestWebUrl'?: string;
  /**
   * The ID of the workflow used for this conversation
   * @type {string}
   * @memberof ConversationGetResponse
   */
  '$workflow': string;
  /**
   * ISO 8601 date string of when the conversation was initiated
   * @type {string}
   * @memberof ConversationGetResponse
   */
  'initiated': string;
  /**
   * The ID of the conversation
   * @type {string}
   * @memberof ConversationGetResponse
   */
  '$id': string;
}


/**
 *
 * @export
 * @interface ConversationGetResponseAllOf
 */
export interface ConversationGetResponseAllOf {
  /**
   * ISO 8601 date string of when the conversation was initiated
   * @type {string}
   * @memberof ConversationGetResponseAllOf
   */
  'initiated': string;
  /**
   * The ID of the conversation
   * @type {string}
   * @memberof ConversationGetResponseAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ConversationGetResponseBase
 */
export interface ConversationGetResponseBase {
  /**
   * The ID of the workflow used for this conversation
   * @type {string}
   * @memberof ConversationGetResponseBase
   */
  '$workflow': string;
}
/**
 *
 * @export
 * @interface ConversationRemoveResponse
 */
export interface ConversationRemoveResponse {
  /**
   *
   * @type {boolean}
   * @memberof ConversationRemoveResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ConversationRemoveResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ConversationRemoveResponse
   */
  'id': string;
}
/**
 * Base properties for all scheduled conversation types
 * @export
 * @interface ConversationScheduleParams
 */
export interface ConversationScheduleParams {
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ConversationScheduleParams
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ConversationScheduleParams
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ConversationScheduleParams
   */
  'initialMessageHtml'?: string | null;
}
/**
 *
 * @export
 * @interface ConversationUpdateRequest
 */
export interface ConversationUpdateRequest {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ConversationUpdateRequest
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ConversationUpdateRequest
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ConversationUpdateRequest
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof ConversationUpdateRequest
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ConversationUpdateRequest
   */
  'environment': ConversationEnvironment;
  /**
   *
   * @type {ConversationUpdateRequestAllOfWorkflow}
   * @memberof ConversationUpdateRequest
   * @deprecated
   */
  '$workflow'?: ConversationUpdateRequestAllOfWorkflow;
  /**
   * The ID of the conversation to update
   * @type {string}
   * @memberof ConversationUpdateRequest
   */
  '$id': string;
}


/**
 *
 * @export
 * @interface ConversationUpdateRequestAllOf
 */
export interface ConversationUpdateRequestAllOf {
  /**
   * The ID of the conversation to update
   * @type {string}
   * @memberof ConversationUpdateRequestAllOf
   */
  '$id': string;
  /**
   *
   * @type {ConversationUpdateRequestAllOfWorkflow}
   * @memberof ConversationUpdateRequestAllOf
   * @deprecated
   */
  '$workflow'?: ConversationUpdateRequestAllOfWorkflow;
}
/**
 * @type ConversationUpdateRequestAllOfWorkflow
 * @export
 */
export type ConversationUpdateRequestAllOfWorkflow = Workflow | string;

/**
 *
 * @export
 * @interface ConversationUpdateRequestBase
 */
export interface ConversationUpdateRequestBase {
  /**
   *
   * @type {ConversationUpdateRequestBaseWorkflow}
   * @memberof ConversationUpdateRequestBase
   * @deprecated
   */
  '$workflow'?: ConversationUpdateRequestBaseWorkflow;
}
/**
 * @type ConversationUpdateRequestBaseWorkflow
 * @export
 */
export type ConversationUpdateRequestBaseWorkflow = Workflow | string;

/**
 *
 * @export
 * @interface ConversationUpdateResponse
 */
export interface ConversationUpdateResponse {
  /**
   *
   * @type {boolean}
   * @memberof ConversationUpdateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ConversationUpdateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ConversationUpdateResponse
   */
  'id': string;
}
/**
 * Conversation web urls
 * @export
 * @interface ConversationUrls
 */
export interface ConversationUrls {
  /**
   * The client web url of the conversation
   * @type {string}
   * @memberof ConversationUrls
   */
  'clientWebUrl'?: string;
  /**
   * The agent web url of the conversation (requires phone two-factor authentication)
   * @type {string}
   * @memberof ConversationUrls
   */
  'agentWebUrl'?: string;
  /**
   * The agent test web url of the conversation, used for testing the conversation without notifying the customer
   * @type {string}
   * @memberof ConversationUrls
   */
  'agentTestWebUrl'?: string;
}
/**
 *
 * @export
 * @interface ConversationWithId
 */
export interface ConversationWithId {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ConversationWithId
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ConversationWithId
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ConversationWithId
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof ConversationWithId
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ConversationWithId
   */
  'environment': ConversationEnvironment;
  /**
   * The ID of the conversation
   * @type {string}
   * @memberof ConversationWithId
   */
  '$id': string;
}


/**
 *
 * @export
 * @interface ConversationWithIdAllOf
 */
export interface ConversationWithIdAllOf {
  /**
   * The ID of the conversation
   * @type {string}
   * @memberof ConversationWithIdAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface CreateAgentRequest
 */
export interface CreateAgentRequest {
  /**
   * Agent first name
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'firstName': string;
  /**
   * Agent last name
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'lastName': string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof CreateAgentRequest
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'forwardEmail': string;
  /**
   * Forward phone
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'forwardPhone': string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof CreateAgentRequest
   */
  'title'?: string;
  /**
   *
   * @type {AgentContext}
   * @memberof CreateAgentRequest
   */
  'context'?: AgentContext;
  /**
   * Transcripts of the agent
   * @type {Array<string>}
   * @memberof CreateAgentRequest
   */
  'transcripts'?: Array<string>;
  /**
   * Audios of the agent
   * @type {Array<string>}
   * @memberof CreateAgentRequest
   */
  'audios'?: Array<string>;
  /**
   * Locations ids the agent is included in
   * @type {Array<string>}
   * @memberof CreateAgentRequest
   */
  'includedLocations'?: Array<string>;
  /**
   * Locations id the agent is excluded from
   * @type {Array<string>}
   * @memberof CreateAgentRequest
   */
  'excludedLocations'?: Array<string>;
  /**
   * Sample conversations that help build out your agent to mimic your responses
   * @type {Array<CreateAgentRequestAllOfConversationsInner>}
   * @memberof CreateAgentRequest
   */
  'conversations'?: Array<CreateAgentRequestAllOfConversationsInner>;
  /**
   * Sample audio files that help build out your agent to mimic your voice
   * @type {Array<string>}
   * @memberof CreateAgentRequest
   */
  'audio'?: Array<string>;
}
/**
 *
 * @export
 * @interface CreateAgentRequestAllOf
 */
export interface CreateAgentRequestAllOf {
  /**
   * Sample conversations that help build out your agent to mimic your responses
   * @type {Array<CreateAgentRequestAllOfConversationsInner>}
   * @memberof CreateAgentRequestAllOf
   */
  'conversations'?: Array<CreateAgentRequestAllOfConversationsInner>;
  /**
   * Sample audio files that help build out your agent to mimic your voice
   * @type {Array<string>}
   * @memberof CreateAgentRequestAllOf
   */
  'audio'?: Array<string>;
}
/**
 * @type CreateAgentRequestAllOfConversationsInner
 * @export
 */
export type CreateAgentRequestAllOfConversationsInner = CreateAgentRequestAllOfConversationsInnerOneOf | string;

/**
 * Conversation sample
 * @export
 * @interface CreateAgentRequestAllOfConversationsInnerOneOf
 */
export interface CreateAgentRequestAllOfConversationsInnerOneOf {
  /**
   * The type or category of the conversation (this helps with associating work flows)
   * @type {string}
   * @memberof CreateAgentRequestAllOfConversationsInnerOneOf
   */
  'type': string;
  /**
   * The context of the conversation, this helps with associating work flows, or any caveats to the conversation
   * @type {string}
   * @memberof CreateAgentRequestAllOfConversationsInnerOneOf
   */
  'context'?: string;
  /**
   * Conversation
   * @type {Array<CreateAgentRequestAllOfConversationsInnerOneOfConversationInner>}
   * @memberof CreateAgentRequestAllOfConversationsInnerOneOf
   */
  'conversation': Array<CreateAgentRequestAllOfConversationsInnerOneOfConversationInner>;
}
/**
 *
 * @export
 * @interface CreateAgentRequestAllOfConversationsInnerOneOfConversationInner
 */
export interface CreateAgentRequestAllOfConversationsInnerOneOfConversationInner {
  /**
   * The speaker of the message, if this from the agent then this must have \"agent\" or match the agent\'s first or full name
   * @type {string}
   * @memberof CreateAgentRequestAllOfConversationsInnerOneOfConversationInner
   */
  'speaker': string;
  /**
   * The message content
   * @type {string}
   * @memberof CreateAgentRequestAllOfConversationsInnerOneOfConversationInner
   */
  'message': string;
}
/**
 *
 * @export
 * @interface CreateAgentResponse
 */
export interface CreateAgentResponse {
  /**
   *
   * @type {boolean}
   * @memberof CreateAgentResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof CreateAgentResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof CreateAgentResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface CreateAgentsRequest
 */
export interface CreateAgentsRequest {
  /**
   *
   * @type {Array<CreateAgentsRequestAgentsInner>}
   * @memberof CreateAgentsRequest
   */
  'agents'?: Array<CreateAgentsRequestAgentsInner>;
}
/**
 *
 * @export
 * @interface CreateAgentsRequestAgentsInner
 */
export interface CreateAgentsRequestAgentsInner {
  /**
   * Agent first name
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'firstName': string;
  /**
   * Agent last name
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'lastName': string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'title'?: string;
  /**
   *
   * @type {AgentContext}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'context'?: AgentContext;
  /**
   * Transcripts of the agent
   * @type {Array<string>}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'transcripts'?: Array<string>;
  /**
   * Audios of the agent
   * @type {Array<string>}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'audios'?: Array<string>;
  /**
   * Locations ids the agent is included in
   * @type {Array<string>}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'includedLocations'?: Array<string>;
  /**
   * Locations id the agent is excluded from
   * @type {Array<string>}
   * @memberof CreateAgentsRequestAgentsInner
   */
  'excludedLocations'?: Array<string>;
}
/**
 *
 * @export
 * @interface CreateAgentsResponse
 */
export interface CreateAgentsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof CreateAgentsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof CreateAgentsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface CreateContextDataRequest
 */
export interface CreateContextDataRequest {
  /**
   * The context id to create data for
   * @type {string}
   * @memberof CreateContextDataRequest
   */
  'context': string;
  /**
   *
   * @type {Array<{ [key: string]: ContextRowValue; }>}
   * @memberof CreateContextDataRequest
   */
  'rows': Array<{ [key: string]: ContextRowValue; }>;
}
/**
 *
 * @export
 * @interface CreateContextDataResponse
 */
export interface CreateContextDataResponse {
  /**
   *
   * @type {boolean}
   * @memberof CreateContextDataResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof CreateContextDataResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof CreateContextDataResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface CreateContextRequest
 */
export interface CreateContextRequest {
  /**
   * The name of the context
   * @type {string}
   * @memberof CreateContextRequest
   */
  'name': string;
  /**
   * Whether or not the context is modifiable
   * @type {boolean}
   * @memberof CreateContextRequest
   */
  'modifiable'?: boolean;
  /**
   * The description of the context
   * @type {string}
   * @memberof CreateContextRequest
   */
  'description'?: string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof CreateContextRequest
   */
  'detection'?: ContextDetectionParams;
  /**
   * The API to use for context detection
   * @type {string}
   * @memberof CreateContextRequest
   */
  'detectionApi'?: string;
  /**
   * The ID column of the context
   * @type {string}
   * @memberof CreateContextRequest
   */
  'idColumn'?: string;
  /**
   * The columns of the context
   * @type {Array<string>}
   * @memberof CreateContextRequest
   */
  'columns'?: Array<string>;
  /**
   * The required columns of the context
   * @type {Array<string>}
   * @memberof CreateContextRequest
   */
  'requiredColumns'?: Array<string>;
  /**
   * Whether or not to force NER
   * @type {boolean}
   * @memberof CreateContextRequest
   */
  'forceNER'?: boolean;
  /**
   *
   * @type {ContextModel}
   * @memberof CreateContextRequest
   */
  'model'?: ContextModel;
}
/**
 * The response from creating a context
 * @export
 * @interface CreateContextResponse
 */
export interface CreateContextResponse {
  /**
   *
   * @type {boolean}
   * @memberof CreateContextResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof CreateContextResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof CreateContextResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface CreateContextsRequest
 */
export interface CreateContextsRequest {
  /**
   *
   * @type {Array<CreateContextsRequestContextsInner>}
   * @memberof CreateContextsRequest
   */
  'contexts'?: Array<CreateContextsRequestContextsInner>;
}
/**
 *
 * @export
 * @interface CreateContextsRequestContextsInner
 */
export interface CreateContextsRequestContextsInner {
  /**
   * The name of the context
   * @type {string}
   * @memberof CreateContextsRequestContextsInner
   */
  'name': string;
  /**
   * Whether or not the context is modifiable
   * @type {boolean}
   * @memberof CreateContextsRequestContextsInner
   */
  'modifiable'?: boolean;
  /**
   * The description of the context
   * @type {string}
   * @memberof CreateContextsRequestContextsInner
   */
  'description'?: string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof CreateContextsRequestContextsInner
   */
  'detection'?: ContextDetectionParams;
  /**
   * The API to use for context detection
   * @type {string}
   * @memberof CreateContextsRequestContextsInner
   */
  'detectionApi'?: string;
  /**
   * The ID column of the context
   * @type {string}
   * @memberof CreateContextsRequestContextsInner
   */
  'idColumn'?: string;
  /**
   * The columns of the context
   * @type {Array<string>}
   * @memberof CreateContextsRequestContextsInner
   */
  'columns'?: Array<string>;
  /**
   * The required columns of the context
   * @type {Array<string>}
   * @memberof CreateContextsRequestContextsInner
   */
  'requiredColumns'?: Array<string>;
  /**
   * Whether or not to force NER
   * @type {boolean}
   * @memberof CreateContextsRequestContextsInner
   */
  'forceNER'?: boolean;
  /**
   *
   * @type {ContextModel}
   * @memberof CreateContextsRequestContextsInner
   */
  'model'?: ContextModel;
}
/**
 *
 * @export
 * @interface CreateContextsResponse
 */
export interface CreateContextsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof CreateContextsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof CreateContextsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface CreateCustomerGroupRequest
 */
export interface CreateCustomerGroupRequest {
  /**
   * The name of the customer group
   * @type {string}
   * @memberof CreateCustomerGroupRequest
   */
  'name': string;
  /**
   * The description of the customer group
   * @type {string}
   * @memberof CreateCustomerGroupRequest
   */
  'description'?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof CreateCustomerGroupRequest
   */
  'metadata'?: { [key: string]: any; };
  /**
   *
   * @type {Array<CustomerGroupRecord>}
   * @memberof CreateCustomerGroupRequest
   */
  'customers': Array<CustomerGroupRecord>;
}
/**
 *
 * @export
 * @interface CreateCustomerGroupResponse
 */
export interface CreateCustomerGroupResponse {
  /**
   *
   * @type {boolean}
   * @memberof CreateCustomerGroupResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof CreateCustomerGroupResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof CreateCustomerGroupResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface CreateCustomerGroupsRequest
 */
export interface CreateCustomerGroupsRequest {
  /**
   *
   * @type {Array<CustomerGroup>}
   * @memberof CreateCustomerGroupsRequest
   */
  'CustomerGroups': Array<CustomerGroup>;
}
/**
 *
 * @export
 * @interface CreateCustomerGroupsResponse
 */
export interface CreateCustomerGroupsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof CreateCustomerGroupsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof CreateCustomerGroupsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface CreateCustomersRequest
 */
export interface CreateCustomersRequest {
  /**
   *
   * @type {Array<Customer>}
   * @memberof CreateCustomersRequest
   */
  'customers': Array<Customer>;
}
/**
 *
 * @export
 * @interface CreateCustomersResponse
 */
export interface CreateCustomersResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof CreateCustomersResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof CreateCustomersResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface CreateFileRequestWithStringPurpose
 */
export interface CreateFileRequestWithStringPurpose {
  /**
   *
   * @type {File}
   * @memberof CreateFileRequestWithStringPurpose
   */
  'file': File | Buffer | Blob;
  /**
   *
   * @type {string}
   * @memberof CreateFileRequestWithStringPurpose
   */
  'purpose': string;
  /**
   *
   * @type {string}
   * @memberof CreateFileRequestWithStringPurpose
   */
  'entity': string;
}
/**
 *
 * @export
 * @interface CreateWorkflowRequest
 */
export interface CreateWorkflowRequest {
  /**
   *
   * @type {PurposeEnum}
   * @memberof CreateWorkflowRequest
   */
  'purpose'?: PurposeEnum;
  /**
   * The name of the workflow
   * @type {string}
   * @memberof CreateWorkflowRequest
   */
  'name': string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof CreateWorkflowRequest
   */
  'initiators': ContextDetectionParams;
  /**
   * The fields of the workflow
   * @type {Array<ConversationContextField>}
   * @memberof CreateWorkflowRequest
   */
  'fields': Array<ConversationContextField>;
  /**
   * About this conversation - used as initial context
   * @type {string}
   * @memberof CreateWorkflowRequest
   */
  'context': string;
  /**
   * The webhook to call when a workflow is created
   * @type {string}
   * @memberof CreateWorkflowRequest
   */
  'onCreated'?: string;
  /**
   * The webhook to call when a workflow is updated
   * @type {string}
   * @memberof CreateWorkflowRequest
   */
  'onUpdated'?: string;
  /**
   * The webhook to call when a workflow is deleted
   * @type {string}
   * @memberof CreateWorkflowRequest
   */
  'onDeleted'?: string;
  /**
   * The webhook to call when a workflow has an error
   * @type {string}
   * @memberof CreateWorkflowRequest
   */
  'onError'?: string;
  /**
   * The priority of the workflow in relation to other workflows (determines activation order)
   * @type {number}
   * @memberof CreateWorkflowRequest
   */
  'priority': number;
}


/**
 *
 * @export
 * @interface CreateWorkflowResponse
 */
export interface CreateWorkflowResponse {
  /**
   *
   * @type {boolean}
   * @memberof CreateWorkflowResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof CreateWorkflowResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof CreateWorkflowResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface CreateWorkflowsRequest
 */
export interface CreateWorkflowsRequest {
  /**
   *
   * @type {Array<CreateWorkflowsRequestWorkflowsInner>}
   * @memberof CreateWorkflowsRequest
   */
  'workflows'?: Array<CreateWorkflowsRequestWorkflowsInner>;
}
/**
 *
 * @export
 * @interface CreateWorkflowsRequestWorkflowsInner
 */
export interface CreateWorkflowsRequestWorkflowsInner {
  /**
   *
   * @type {PurposeEnum}
   * @memberof CreateWorkflowsRequestWorkflowsInner
   */
  'purpose'?: PurposeEnum;
  /**
   * The name of the workflow
   * @type {string}
   * @memberof CreateWorkflowsRequestWorkflowsInner
   */
  'name': string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof CreateWorkflowsRequestWorkflowsInner
   */
  'initiators': ContextDetectionParams;
  /**
   * The fields of the workflow
   * @type {Array<ConversationContextField>}
   * @memberof CreateWorkflowsRequestWorkflowsInner
   */
  'fields': Array<ConversationContextField>;
  /**
   * About this conversation - used as initial context
   * @type {string}
   * @memberof CreateWorkflowsRequestWorkflowsInner
   */
  'context': string;
  /**
   * The webhook to call when a workflow is created
   * @type {string}
   * @memberof CreateWorkflowsRequestWorkflowsInner
   */
  'onCreated'?: string;
  /**
   * The webhook to call when a workflow is updated
   * @type {string}
   * @memberof CreateWorkflowsRequestWorkflowsInner
   */
  'onUpdated'?: string;
  /**
   * The webhook to call when a workflow is deleted
   * @type {string}
   * @memberof CreateWorkflowsRequestWorkflowsInner
   */
  'onDeleted'?: string;
  /**
   * The webhook to call when a workflow has an error
   * @type {string}
   * @memberof CreateWorkflowsRequestWorkflowsInner
   */
  'onError'?: string;
  /**
   * The priority of the workflow in relation to other workflows (determines activation order)
   * @type {number}
   * @memberof CreateWorkflowsRequestWorkflowsInner
   */
  'priority': number;
}


/**
 *
 * @export
 * @interface CreateWorkflowsResponse
 */
export interface CreateWorkflowsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof CreateWorkflowsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof CreateWorkflowsResponse
   */
  '$operation': string;
}
/**
 * Represents a customer for your business or organization
 * @export
 * @interface Customer
 */
export interface Customer {
  [key: string]: CustomerValue | any;

  /**
   * The customers first name
   * @type {string}
   * @memberof Customer
   */
  'firstName'?: string;
  /**
   * The customers last name
   * @type {string}
   * @memberof Customer
   */
  'lastName'?: string;
  /**
   * The customers full name
   * @type {string}
   * @memberof Customer
   */
  'name': string;
  /**
   * The customers email address
   * @type {string}
   * @memberof Customer
   */
  'email'?: string | null;
  /**
   * The customers phone number
   * @type {string}
   * @memberof Customer
   */
  'phone'?: string | null;
  /**
   * The customers profile image
   * @type {string}
   * @memberof Customer
   */
  'img'?: string | null;
  /**
   * The customers neighborhood
   * @type {string}
   * @memberof Customer
   */
  'neighborhood'?: string | null;
  /**
   * The customers city
   * @type {string}
   * @memberof Customer
   */
  'city'?: string | null;
  /**
   * The customers 2-letter country code
   * @type {string}
   * @memberof Customer
   */
  'country'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof Customer
   */
  'line1'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof Customer
   */
  'line2'?: string | null;
  /**
   * The customers postal code
   * @type {string}
   * @memberof Customer
   */
  'postal_code'?: string | null;
  /**
   * The customers state, county, province, or region
   * @type {string}
   * @memberof Customer
   */
  'state'?: string | null;
  /**
   * The customers town (only used in Japan)
   * @type {string}
   * @memberof Customer
   */
  'town'?: string | null;
  /**
   *
   * @type {BlockInfo}
   * @memberof Customer
   */
  'blocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof Customer
   */
  'phoneBlocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof Customer
   */
  'emailBlocked'?: BlockInfo;
  /**
   * The date the customer joined the business
   * @type {string}
   * @memberof Customer
   */
  'joined'?: string | null;
  /**
   * The customers stripe ID
   * @type {string}
   * @memberof Customer
   */
  'stripe'?: string | null;
  /**
   * The customers stripe ID in the dev environment
   * @type {string}
   * @memberof Customer
   */
  'stripeDev'?: string | null;
}
/**
 *
 * @export
 * @interface CustomerCreateResponse
 */
export interface CustomerCreateResponse {
  /**
   *
   * @type {boolean}
   * @memberof CustomerCreateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof CustomerCreateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof CustomerCreateResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface CustomerDeleteResponse
 */
export interface CustomerDeleteResponse {
  /**
   *
   * @type {boolean}
   * @memberof CustomerDeleteResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof CustomerDeleteResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof CustomerDeleteResponse
   */
  'id': string;
}
/**
 * A way for a business to group customers to use in scheduling batch conversations
 * @export
 * @interface CustomerGroup
 */
export interface CustomerGroup {
  /**
   * The name of the customer group
   * @type {string}
   * @memberof CustomerGroup
   */
  'name': string;
  /**
   * The description of the customer group
   * @type {string}
   * @memberof CustomerGroup
   */
  'description'?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof CustomerGroup
   */
  'metadata'?: { [key: string]: any; };
  /**
   *
   * @type {Array<CustomerGroupRecord>}
   * @memberof CustomerGroup
   */
  'customers': Array<CustomerGroupRecord>;
}
/**
 * A way for a business to group customers to use in scheduling batch conversations
 * @export
 * @interface CustomerGroupRecord
 */
export interface CustomerGroupRecord {
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof CustomerGroupRecord
   */
  'id': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof CustomerGroupRecord
   */
  'environment': ConversationEnvironment;
  /**
   * Overrides the default $agent for this customer
   * @type {string}
   * @memberof CustomerGroupRecord
   */
  '$agent'?: string;
}


/**
 *
 * @export
 * @interface CustomerUpdateResponse
 */
export interface CustomerUpdateResponse {
  /**
   *
   * @type {boolean}
   * @memberof CustomerUpdateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof CustomerUpdateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof CustomerUpdateResponse
   */
  'id': string;
}
/**
 * @type CustomerValue
 * @export
 */
export type CustomerValue = boolean | number | string;

/**
 *
 * @export
 * @interface DeleteContextDataResponse
 */
export interface DeleteContextDataResponse {
  /**
   *
   * @type {boolean}
   * @memberof DeleteContextDataResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof DeleteContextDataResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof DeleteContextDataResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface DeleteContextResponse
 */
export interface DeleteContextResponse {
  /**
   *
   * @type {boolean}
   * @memberof DeleteContextResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof DeleteContextResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof DeleteContextResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface DeleteContextsResponse
 */
export interface DeleteContextsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof DeleteContextsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof DeleteContextsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface DeleteCustomerGroupResponse
 */
export interface DeleteCustomerGroupResponse {
  /**
   *
   * @type {boolean}
   * @memberof DeleteCustomerGroupResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof DeleteCustomerGroupResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof DeleteCustomerGroupResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface DeleteCustomerGroupsResponse
 */
export interface DeleteCustomerGroupsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof DeleteCustomerGroupsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof DeleteCustomerGroupsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface DeleteCustomersResponse
 */
export interface DeleteCustomersResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof DeleteCustomersResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof DeleteCustomersResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface DeleteFileResponse
 */
export interface DeleteFileResponse {
  /**
   *
   * @type {string}
   * @memberof DeleteFileResponse
   */
  'id': string;
  /**
   *
   * @type {string}
   * @memberof DeleteFileResponse
   */
  'object': string;
  /**
   *
   * @type {boolean}
   * @memberof DeleteFileResponse
   */
  'deleted': boolean;
}
/**
 *
 * @export
 * @interface DeleteWorkflowResponse
 */
export interface DeleteWorkflowResponse {
  /**
   *
   * @type {boolean}
   * @memberof DeleteWorkflowResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof DeleteWorkflowResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof DeleteWorkflowResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface DeleteWorkflowsResponse
 */
export interface DeleteWorkflowsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof DeleteWorkflowsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof DeleteWorkflowsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface EntitiesBuildConfigInner
 */
export interface EntitiesBuildConfigInner {
  /**
   *
   * @type {Array<string>}
   * @memberof EntitiesBuildConfigInner
   */
  'entities'?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof EntitiesBuildConfigInner
   */
  'entity'?: string;
  /**
   *
   * @type {string}
   * @memberof EntitiesBuildConfigInner
   */
  'id'?: string;
  /**
   *
   * @type {Array<EntityBuildConfigDefinitionsInner>}
   * @memberof EntitiesBuildConfigInner
   */
  'definitions'?: Array<EntityBuildConfigDefinitionsInner>;
  /**
   *
   * @type {Array<EntityBuildConfigTrainingInner>}
   * @memberof EntitiesBuildConfigInner
   */
  'training'?: Array<EntityBuildConfigTrainingInner>;
  /**
   *
   * @type {Array<EntityBuildConfigTestsInner>}
   * @memberof EntitiesBuildConfigInner
   */
  'tests'?: Array<EntityBuildConfigTestsInner>;
}
/**
 *
 * @export
 * @interface EntityBuildConfig
 */
export interface EntityBuildConfig {
  /**
   *
   * @type {Array<EntityBuildConfigDefinitionsInner>}
   * @memberof EntityBuildConfig
   */
  'definitions'?: Array<EntityBuildConfigDefinitionsInner>;
  /**
   *
   * @type {Array<EntityBuildConfigTrainingInner>}
   * @memberof EntityBuildConfig
   */
  'training'?: Array<EntityBuildConfigTrainingInner>;
  /**
   *
   * @type {Array<EntityBuildConfigTestsInner>}
   * @memberof EntityBuildConfig
   */
  'tests'?: Array<EntityBuildConfigTestsInner>;
}
/**
 *
 * @export
 * @interface EntityBuildConfigDefinitionsInner
 */
export interface EntityBuildConfigDefinitionsInner {
  /**
   *
   * @type {string}
   * @memberof EntityBuildConfigDefinitionsInner
   */
  'utterance'?: string;
  /**
   *
   * @type {string}
   * @memberof EntityBuildConfigDefinitionsInner
   */
  'value'?: string;
  /**
   *
   * @type {Array<string>}
   * @memberof EntityBuildConfigDefinitionsInner
   */
  'text'?: Array<string>;
}
/**
 *
 * @export
 * @interface EntityBuildConfigTestsInner
 */
export interface EntityBuildConfigTestsInner {
  /**
   *
   * @type {string}
   * @memberof EntityBuildConfigTestsInner
   */
  'text'?: string;
  /**
   *
   * @type {EntityBuildConfigTestsInnerExpected}
   * @memberof EntityBuildConfigTestsInner
   */
  'expected'?: EntityBuildConfigTestsInnerExpected;
}
/**
 *
 * @export
 * @interface EntityBuildConfigTestsInnerExpected
 */
export interface EntityBuildConfigTestsInnerExpected {
  /**
   *
   * @type {string}
   * @memberof EntityBuildConfigTestsInnerExpected
   */
  'intent'?: string;
  /**
   *
   * @type {object}
   * @memberof EntityBuildConfigTestsInnerExpected
   */
  'context'?: object;
}
/**
 *
 * @export
 * @interface EntityBuildConfigTrainingInner
 */
export interface EntityBuildConfigTrainingInner {
  /**
   *
   * @type {string}
   * @memberof EntityBuildConfigTrainingInner
   */
  'text'?: string;
  /**
   *
   * @type {string}
   * @memberof EntityBuildConfigTrainingInner
   */
  'intent'?: string;
}
/**
 *
 * @export
 * @interface EqualityCondition
 */
export interface EqualityCondition {
  /**
   *
   * @type {string}
   * @memberof EqualityCondition
   */
  'path': string;
  /**
   *
   * @type {EqualityOperator}
   * @memberof EqualityCondition
   */
  'operator': EqualityOperator;
  /**
   *
   * @type {any}
   * @memberof EqualityCondition
   */
  'value': any;
  /**
   *
   * @type {boolean}
   * @memberof EqualityCondition
   */
  'external'?: boolean;
}


/**
 *
 * @export
 * @interface EqualityConditionAllOf
 */
export interface EqualityConditionAllOf {
  /**
   *
   * @type {EqualityOperator}
   * @memberof EqualityConditionAllOf
   */
  'operator': EqualityOperator;
  /**
   *
   * @type {any}
   * @memberof EqualityConditionAllOf
   */
  'value': any;
}


/**
 *
 * @export
 * @enum {string}
 */

export const EqualityOperator = {
  Eq: 'eq',
  Neq: 'neq',
  Gt: 'gt',
  Gte: 'gte',
  Lt: 'lt',
  Lte: 'lte',
  In: 'in',
  Nin: 'nin',
  Contains: 'contains',
  NotContains: 'notContains',
  StartsWith: 'startsWith',
  EndsWith: 'endsWith',
  ArrayContainsAny: 'arrayContainsAny',
  ArrayContains: 'arrayContains'
} as const;

export type EqualityOperator = typeof EqualityOperator[keyof typeof EqualityOperator];


/**
 *
 * @export
 * @interface ErrorResponse
 */
export interface ErrorResponse {
  /**
   *
   * @type {Error}
   * @memberof ErrorResponse
   */
  'error': Error;
}
/**
 *
 * @export
 * @enum {string}
 */

export const ExistenceOperator = {
  Exists: 'exists',
  NotExists: 'notExists'
} as const;

export type ExistenceOperator = typeof ExistenceOperator[keyof typeof ExistenceOperator];


/**
 *
 * @export
 * @interface ExistsCondition
 */
export interface ExistsCondition {
  /**
   *
   * @type {string}
   * @memberof ExistsCondition
   */
  'path': string;
  /**
   *
   * @type {ExistenceOperator}
   * @memberof ExistsCondition
   */
  'operator': ExistenceOperator;
  /**
   *
   * @type {any}
   * @memberof ExistsCondition
   */
  'value'?: any;
  /**
   *
   * @type {boolean}
   * @memberof ExistsCondition
   */
  'external'?: boolean;
}


/**
 *
 * @export
 * @interface ExistsConditionAllOf
 */
export interface ExistsConditionAllOf {
  /**
   *
   * @type {ExistenceOperator}
   * @memberof ExistsConditionAllOf
   */
  'operator': ExistenceOperator;
}


/**
 * Forward a conversation to the corresponding agent. .convo can be overwritten with a Conversation object, .latestMessage overrides the given conversations latest user messages (typically only used in development). If \".forward\" is provided, it will override the default agent to forward to.
 * @export
 * @interface ForwardRequest
 */
export interface ForwardRequest {
  /**
   *
   * @type {ForwardRequestConvo}
   * @memberof ForwardRequest
   */
  'convo'?: ForwardRequestConvo;
  /**
   *
   * @type {ForwardRequestForward}
   * @memberof ForwardRequest
   */
  'forward'?: ForwardRequestForward;
  /**
   *
   * @type {ForwardRequestLatestMessage}
   * @memberof ForwardRequest
   */
  'latestMessage'?: ForwardRequestLatestMessage;
}
/**
 * @type ForwardRequestConvo
 * @export
 */
export type ForwardRequestConvo = ConversationWithId | string;

/**
 * @type ForwardRequestForward
 * Forward information, if \"true\", it will automatically forward to the corresponding agent of the given conversation, \"string\" or \"object\" will override the default agent.
 * @export
 */
export type ForwardRequestForward = ForwardRequestForwardOneOf | boolean | string;

/**
 * The agent to forward to
 * @export
 * @interface ForwardRequestForwardOneOf
 */
export interface ForwardRequestForwardOneOf {
  /**
   * The ID, email or phone number to forward to
   * @type {string}
   * @memberof ForwardRequestForwardOneOf
   */
  'to': string;
  /**
   * The mode to forward the conversation (defaults to immediately)
   * @type {string}
   * @memberof ForwardRequestForwardOneOf
   */
  'mode'?: ForwardRequestForwardOneOfModeEnum;
}

export const ForwardRequestForwardOneOfModeEnum = {
  AfterReply: 'after-reply',
  Immediately: 'immediately'
} as const;

export type ForwardRequestForwardOneOfModeEnum = typeof ForwardRequestForwardOneOfModeEnum[keyof typeof ForwardRequestForwardOneOfModeEnum];

/**
 *
 * @export
 * @interface ForwardRequestLatestMessage
 */
export interface ForwardRequestLatestMessage {
  /**
   * The role of the message (customer, agent, or business)
   * @type {string}
   * @memberof ForwardRequestLatestMessage
   */
  'role': ForwardRequestLatestMessageRoleEnum;
  /**
   * The content of the message
   * @type {string}
   * @memberof ForwardRequestLatestMessage
   */
  'content': string;
  /**
   * The name of the sender
   * @type {string}
   * @memberof ForwardRequestLatestMessage
   */
  'name'?: string;
  /**
   * The time the message was sent
   * @type {string}
   * @memberof ForwardRequestLatestMessage
   */
  'time': string;
}

export const ForwardRequestLatestMessageRoleEnum = {
  Customer: 'customer',
  Agent: 'agent',
  Context: 'context'
} as const;

export type ForwardRequestLatestMessageRoleEnum = typeof ForwardRequestLatestMessageRoleEnum[keyof typeof ForwardRequestLatestMessageRoleEnum];

/**
 *
 * @export
 * @interface ForwardResponse
 */
export interface ForwardResponse {
  /**
   * The time it took to forward the message in milliseconds
   * @type {number}
   * @memberof ForwardResponse
   */
  'ms': number;
}
/**
 * @type GenerateRequest
 * Either a conversation ID or a conversation object with messages and context metadata to generate from
 * @export
 */
export type GenerateRequest = GenerateRequestOneOf | string;

/**
 *
 * @export
 * @interface GenerateRequestOneOf
 */
export interface GenerateRequestOneOf {
  /**
   *
   * @type {ConversationCreateRequest}
   * @memberof GenerateRequestOneOf
   */
  'convo'?: ConversationCreateRequest;
  /**
   * Conversation messages and context to generate message from
   * @type {Array<Message>}
   * @memberof GenerateRequestOneOf
   */
  'messages': Array<Message>;
  /**
   * Any key,value information about the conversation, customer, or offer goes here
   * @type {{ [key: string]: any; }}
   * @memberof GenerateRequestOneOf
   */
  'context'?: { [key: string]: any; };
  /**
   *
   * @type {GenerateRequestOneOfPersona}
   * @memberof GenerateRequestOneOf
   */
  'persona': GenerateRequestOneOfPersona;
  /**
   *
   * @type {LlmConfig}
   * @memberof GenerateRequestOneOf
   */
  'llm'?: LlmConfig;
  /**
   *
   * @type {PmtConfig}
   * @memberof GenerateRequestOneOf
   */
  'pmt'?: PmtConfig;
}
/**
 * @type GenerateRequestOneOfPersona
 * @export
 */
export type GenerateRequestOneOfPersona = Agent | string;

/**
 *
 * @export
 * @interface GenerateResponse
 */
export interface GenerateResponse {
  /**
   * The generated message
   * @type {string}
   * @memberof GenerateResponse
   */
  'message': string;
  /**
   * The time it took to generate the message in milliseconds
   * @type {number}
   * @memberof GenerateResponse
   */
  'ms': number;
}
/**
 *
 * @export
 * @interface GetAgentResponse
 */
export interface GetAgentResponse {
  /**
   * Agent first name
   * @type {string}
   * @memberof GetAgentResponse
   */
  'firstName': string;
  /**
   * Agent last name
   * @type {string}
   * @memberof GetAgentResponse
   */
  'lastName': string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof GetAgentResponse
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof GetAgentResponse
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof GetAgentResponse
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof GetAgentResponse
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof GetAgentResponse
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof GetAgentResponse
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof GetAgentResponse
   */
  'title'?: string;
  /**
   *
   * @type {AgentContext}
   * @memberof GetAgentResponse
   */
  'context'?: AgentContext;
  /**
   * Transcripts of the agent
   * @type {Array<string>}
   * @memberof GetAgentResponse
   */
  'transcripts'?: Array<string>;
  /**
   * Audios of the agent
   * @type {Array<string>}
   * @memberof GetAgentResponse
   */
  'audios'?: Array<string>;
  /**
   * Locations ids the agent is included in
   * @type {Array<string>}
   * @memberof GetAgentResponse
   */
  'includedLocations'?: Array<string>;
  /**
   * Locations id the agent is excluded from
   * @type {Array<string>}
   * @memberof GetAgentResponse
   */
  'excludedLocations'?: Array<string>;
  /**
   * The ID of the agent
   * @type {string}
   * @memberof GetAgentResponse
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface GetAgentResponseAllOf
 */
export interface GetAgentResponseAllOf {
  /**
   * The ID of the agent
   * @type {string}
   * @memberof GetAgentResponseAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface GetApiOperationResponse
 */
export interface GetApiOperationResponse {
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof GetApiOperationResponse
   */
  'time': string;
  /**
   * The model that was created, updated, or deleted
   * @type {string}
   * @memberof GetApiOperationResponse
   */
  'model': string;
  /**
   * The method that was called
   * @type {string}
   * @memberof GetApiOperationResponse
   */
  'method': GetApiOperationResponseMethodEnum;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof GetApiOperationResponse
   */
  'results': { [key: string]: any; };
  /**
   * The ID of the operation
   * @type {string}
   * @memberof GetApiOperationResponse
   */
  '$id': string;
}

export const GetApiOperationResponseMethodEnum = {
  Get: 'get',
  Post: 'post',
  Put: 'put',
  Delete: 'delete',
  Patch: 'patch'
} as const;

export type GetApiOperationResponseMethodEnum = typeof GetApiOperationResponseMethodEnum[keyof typeof GetApiOperationResponseMethodEnum];

/**
 *
 * @export
 * @interface GetApiOperationResponseAllOf
 */
export interface GetApiOperationResponseAllOf {
  /**
   * The ID of the operation
   * @type {string}
   * @memberof GetApiOperationResponseAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface GetContextDataResponse
 */
export interface GetContextDataResponse {
  /**
   * The ID of the context
   * @type {string}
   * @memberof GetContextDataResponse
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface GetContextResponse
 */
export interface GetContextResponse {
  /**
   * The name of the context
   * @type {string}
   * @memberof GetContextResponse
   */
  'name': string;
  /**
   * Whether or not the context is modifiable
   * @type {boolean}
   * @memberof GetContextResponse
   */
  'modifiable'?: boolean;
  /**
   * The description of the context
   * @type {string}
   * @memberof GetContextResponse
   */
  'description'?: string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof GetContextResponse
   */
  'detection'?: ContextDetectionParams;
  /**
   * The API to use for context detection
   * @type {string}
   * @memberof GetContextResponse
   */
  'detectionApi'?: string;
  /**
   * The ID column of the context
   * @type {string}
   * @memberof GetContextResponse
   */
  'idColumn'?: string;
  /**
   * The columns of the context
   * @type {Array<string>}
   * @memberof GetContextResponse
   */
  'columns'?: Array<string>;
  /**
   * The required columns of the context
   * @type {Array<string>}
   * @memberof GetContextResponse
   */
  'requiredColumns'?: Array<string>;
  /**
   * Whether or not to force NER
   * @type {boolean}
   * @memberof GetContextResponse
   */
  'forceNER'?: boolean;
  /**
   *
   * @type {ContextModel}
   * @memberof GetContextResponse
   */
  'model'?: ContextModel;
  /**
   * The ID of the context
   * @type {string}
   * @memberof GetContextResponse
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface GetContextResponseAllOf
 */
export interface GetContextResponseAllOf {
  /**
   * The ID of the context
   * @type {string}
   * @memberof GetContextResponseAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface GetCustomerGroupResponse
 */
export interface GetCustomerGroupResponse {
  /**
   * The name of the customer group
   * @type {string}
   * @memberof GetCustomerGroupResponse
   */
  'name': string;
  /**
   * The description of the customer group
   * @type {string}
   * @memberof GetCustomerGroupResponse
   */
  'description'?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof GetCustomerGroupResponse
   */
  'metadata'?: { [key: string]: any; };
  /**
   *
   * @type {Array<CustomerGroupRecord>}
   * @memberof GetCustomerGroupResponse
   */
  'customers': Array<CustomerGroupRecord>;
  /**
   * The ID of the CustomerGroup
   * @type {string}
   * @memberof GetCustomerGroupResponse
   */
  '$id'?: string;
}
/**
 *
 * @export
 * @interface GetCustomerGroupResponseAllOf
 */
export interface GetCustomerGroupResponseAllOf {
  /**
   * The ID of the CustomerGroup
   * @type {string}
   * @memberof GetCustomerGroupResponseAllOf
   */
  '$id'?: string;
}
/**
 *
 * @export
 * @interface GetCustomerResponse
 */
export interface GetCustomerResponse {
  /**
   * The customers first name
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'firstName'?: string;
  /**
   * The customers last name
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'lastName'?: string;
  /**
   * The customers full name
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'name': string;
  /**
   * The customers email address
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'email'?: string | null;
  /**
   * The customers phone number
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'phone'?: string | null;
  /**
   * The customers profile image
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'img'?: string | null;
  /**
   * The customers neighborhood
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'neighborhood'?: string | null;
  /**
   * The customers city
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'city'?: string | null;
  /**
   * The customers 2-letter country code
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'country'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'line1'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'line2'?: string | null;
  /**
   * The customers postal code
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'postal_code'?: string | null;
  /**
   * The customers state, county, province, or region
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'state'?: string | null;
  /**
   * The customers town (only used in Japan)
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'town'?: string | null;
  /**
   *
   * @type {BlockInfo}
   * @memberof GetCustomerResponse
   */
  'blocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof GetCustomerResponse
   */
  'phoneBlocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof GetCustomerResponse
   */
  'emailBlocked'?: BlockInfo;
  /**
   * The date the customer joined the business
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'joined'?: string | null;
  /**
   * The customers stripe ID
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'stripe'?: string | null;
  /**
   * The customers stripe ID in the dev environment
   * @type {string}
   * @memberof GetCustomerResponse
   */
  'stripeDev'?: string | null;
  /**
   * The ID of the customer
   * @type {string}
   * @memberof GetCustomerResponse
   */
  '$id'?: string;
}
/**
 *
 * @export
 * @interface GetCustomerResponseAllOf
 */
export interface GetCustomerResponseAllOf {
  /**
   * The ID of the customer
   * @type {string}
   * @memberof GetCustomerResponseAllOf
   */
  '$id'?: string;
}
/**
 *
 * @export
 * @interface GetWorkflowResponse
 */
export interface GetWorkflowResponse {
  /**
   *
   * @type {PurposeEnum}
   * @memberof GetWorkflowResponse
   */
  'purpose'?: PurposeEnum;
  /**
   * The name of the workflow
   * @type {string}
   * @memberof GetWorkflowResponse
   */
  'name': string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof GetWorkflowResponse
   */
  'initiators': ContextDetectionParams;
  /**
   * The fields of the workflow
   * @type {Array<ConversationContextField>}
   * @memberof GetWorkflowResponse
   */
  'fields': Array<ConversationContextField>;
  /**
   * About this conversation - used as initial context
   * @type {string}
   * @memberof GetWorkflowResponse
   */
  'context': string;
  /**
   * The webhook to call when a workflow is created
   * @type {string}
   * @memberof GetWorkflowResponse
   */
  'onCreated'?: string;
  /**
   * The webhook to call when a workflow is updated
   * @type {string}
   * @memberof GetWorkflowResponse
   */
  'onUpdated'?: string;
  /**
   * The webhook to call when a workflow is deleted
   * @type {string}
   * @memberof GetWorkflowResponse
   */
  'onDeleted'?: string;
  /**
   * The webhook to call when a workflow has an error
   * @type {string}
   * @memberof GetWorkflowResponse
   */
  'onError'?: string;
  /**
   * The priority of the workflow in relation to other workflows (determines activation order)
   * @type {number}
   * @memberof GetWorkflowResponse
   */
  'priority': number;
  /**
   * The ID of the workflow
   * @type {string}
   * @memberof GetWorkflowResponse
   */
  '$id': string;
}


/**
 *
 * @export
 * @interface GetWorkflowResponseAllOf
 */
export interface GetWorkflowResponseAllOf {
  /**
   * The ID of the workflow
   * @type {string}
   * @memberof GetWorkflowResponseAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface Instruction
 */
export interface Instruction {
  /**
   *
   * @type {string}
   * @memberof Instruction
   */
  'id': string;
  /**
   *
   * @type {string}
   * @memberof Instruction
   */
  'content': string;
}
/**
 *
 * @export
 * @interface ListAgentsResponseInner
 */
export interface ListAgentsResponseInner {
  /**
   * Agent first name
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'firstName'?: string;
  /**
   * Agent last name
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'lastName'?: string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof ListAgentsResponseInner
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  'title'?: string;
  /**
   *
   * @type {AgentContext}
   * @memberof ListAgentsResponseInner
   */
  'context'?: AgentContext;
  /**
   * Transcripts of the agent
   * @type {Array<string>}
   * @memberof ListAgentsResponseInner
   */
  'transcripts'?: Array<string>;
  /**
   * Audios of the agent
   * @type {Array<string>}
   * @memberof ListAgentsResponseInner
   */
  'audios'?: Array<string>;
  /**
   * Locations ids the agent is included in
   * @type {Array<string>}
   * @memberof ListAgentsResponseInner
   */
  'includedLocations'?: Array<string>;
  /**
   * Locations id the agent is excluded from
   * @type {Array<string>}
   * @memberof ListAgentsResponseInner
   */
  'excludedLocations'?: Array<string>;
  /**
   * The ID of the agent
   * @type {string}
   * @memberof ListAgentsResponseInner
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListAgentsResponseInnerAllOf
 */
export interface ListAgentsResponseInnerAllOf {
  /**
   * The ID of the agent
   * @type {string}
   * @memberof ListAgentsResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListApiOperationsResponseInner
 */
export interface ListApiOperationsResponseInner {
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ListApiOperationsResponseInner
   */
  'time': string;
  /**
   * The model that was created, updated, or deleted
   * @type {string}
   * @memberof ListApiOperationsResponseInner
   */
  'model': string;
  /**
   * The method that was called
   * @type {string}
   * @memberof ListApiOperationsResponseInner
   */
  'method': ListApiOperationsResponseInnerMethodEnum;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof ListApiOperationsResponseInner
   */
  'results': { [key: string]: any; };
  /**
   * The ID of the operation
   * @type {string}
   * @memberof ListApiOperationsResponseInner
   */
  '$id': string;
}

export const ListApiOperationsResponseInnerMethodEnum = {
  Get: 'get',
  Post: 'post',
  Put: 'put',
  Delete: 'delete',
  Patch: 'patch'
} as const;

export type ListApiOperationsResponseInnerMethodEnum = typeof ListApiOperationsResponseInnerMethodEnum[keyof typeof ListApiOperationsResponseInnerMethodEnum];

/**
 *
 * @export
 * @interface ListApiOperationsResponseInnerAllOf
 */
export interface ListApiOperationsResponseInnerAllOf {
  /**
   * The ID of the operation
   * @type {string}
   * @memberof ListApiOperationsResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListContextsResponseInner
 */
export interface ListContextsResponseInner {
  /**
   * The name of the context
   * @type {string}
   * @memberof ListContextsResponseInner
   */
  'name': string;
  /**
   * Whether or not the context is modifiable
   * @type {boolean}
   * @memberof ListContextsResponseInner
   */
  'modifiable'?: boolean;
  /**
   * The description of the context
   * @type {string}
   * @memberof ListContextsResponseInner
   */
  'description'?: string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof ListContextsResponseInner
   */
  'detection'?: ContextDetectionParams;
  /**
   * The API to use for context detection
   * @type {string}
   * @memberof ListContextsResponseInner
   */
  'detectionApi'?: string;
  /**
   * The ID column of the context
   * @type {string}
   * @memberof ListContextsResponseInner
   */
  'idColumn'?: string;
  /**
   * The columns of the context
   * @type {Array<string>}
   * @memberof ListContextsResponseInner
   */
  'columns'?: Array<string>;
  /**
   * The required columns of the context
   * @type {Array<string>}
   * @memberof ListContextsResponseInner
   */
  'requiredColumns'?: Array<string>;
  /**
   * Whether or not to force NER
   * @type {boolean}
   * @memberof ListContextsResponseInner
   */
  'forceNER'?: boolean;
  /**
   *
   * @type {ContextModel}
   * @memberof ListContextsResponseInner
   */
  'model'?: ContextModel;
  /**
   * The ID of the context
   * @type {string}
   * @memberof ListContextsResponseInner
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListContextsResponseInnerAllOf
 */
export interface ListContextsResponseInnerAllOf {
  /**
   * The ID of the context
   * @type {string}
   * @memberof ListContextsResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListConversationsResponseInner
 */
export interface ListConversationsResponseInner {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ListConversationsResponseInner
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ListConversationsResponseInner
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ListConversationsResponseInner
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof ListConversationsResponseInner
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ListConversationsResponseInner
   */
  'environment': ConversationEnvironment;
  /**
   * The client web url of the conversation
   * @type {string}
   * @memberof ListConversationsResponseInner
   */
  'clientWebUrl'?: string;
  /**
   * The agent web url of the conversation (requires phone two-factor authentication)
   * @type {string}
   * @memberof ListConversationsResponseInner
   */
  'agentWebUrl'?: string;
  /**
   * The agent test web url of the conversation, used for testing the conversation without notifying the customer
   * @type {string}
   * @memberof ListConversationsResponseInner
   */
  'agentTestWebUrl'?: string;
  /**
   * The ID of the workflow used for this conversation
   * @type {string}
   * @memberof ListConversationsResponseInner
   */
  '$workflow': string;
  /**
   * ISO 8601 date string of when the conversation was initiated
   * @type {string}
   * @memberof ListConversationsResponseInner
   */
  'initiated': string;
  /**
   * The ID of the conversation
   * @type {string}
   * @memberof ListConversationsResponseInner
   */
  '$id': string;
}


/**
 *
 * @export
 * @interface ListConversationsResponseInnerAllOf
 */
export interface ListConversationsResponseInnerAllOf {
  /**
   * The ID of the conversation
   * @type {string}
   * @memberof ListConversationsResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListCustomerGroupsResponseInner
 */
export interface ListCustomerGroupsResponseInner {
  /**
   * The name of the customer group
   * @type {string}
   * @memberof ListCustomerGroupsResponseInner
   */
  'name': string;
  /**
   * The description of the customer group
   * @type {string}
   * @memberof ListCustomerGroupsResponseInner
   */
  'description'?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof ListCustomerGroupsResponseInner
   */
  'metadata'?: { [key: string]: any; };
  /**
   *
   * @type {Array<CustomerGroupRecord>}
   * @memberof ListCustomerGroupsResponseInner
   */
  'customers': Array<CustomerGroupRecord>;
  /**
   * The ID of the CustomerGroup
   * @type {string}
   * @memberof ListCustomerGroupsResponseInner
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListCustomerGroupsResponseInnerAllOf
 */
export interface ListCustomerGroupsResponseInnerAllOf {
  /**
   * The ID of the CustomerGroup
   * @type {string}
   * @memberof ListCustomerGroupsResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListCustomersResponseInner
 */
export interface ListCustomersResponseInner {
  /**
   * The customers first name
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'firstName'?: string;
  /**
   * The customers last name
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'lastName'?: string;
  /**
   * The customers full name
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'name': string;
  /**
   * The customers email address
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'email'?: string | null;
  /**
   * The customers phone number
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'phone'?: string | null;
  /**
   * The customers profile image
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'img'?: string | null;
  /**
   * The customers neighborhood
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'neighborhood'?: string | null;
  /**
   * The customers city
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'city'?: string | null;
  /**
   * The customers 2-letter country code
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'country'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'line1'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'line2'?: string | null;
  /**
   * The customers postal code
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'postal_code'?: string | null;
  /**
   * The customers state, county, province, or region
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'state'?: string | null;
  /**
   * The customers town (only used in Japan)
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'town'?: string | null;
  /**
   *
   * @type {BlockInfo}
   * @memberof ListCustomersResponseInner
   */
  'blocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof ListCustomersResponseInner
   */
  'phoneBlocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof ListCustomersResponseInner
   */
  'emailBlocked'?: BlockInfo;
  /**
   * The date the customer joined the business
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'joined'?: string | null;
  /**
   * The customers stripe ID
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'stripe'?: string | null;
  /**
   * The customers stripe ID in the dev environment
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  'stripeDev'?: string | null;
  /**
   * The ID of the customer
   * @type {string}
   * @memberof ListCustomersResponseInner
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListCustomersResponseInnerAllOf
 */
export interface ListCustomersResponseInnerAllOf {
  /**
   * The ID of the customer
   * @type {string}
   * @memberof ListCustomersResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ListFilesResponseInner
 */
export interface ListFilesResponseInner {
  /**
   * The file identifier, which can be referenced in the API endpoints.
   * @type {string}
   * @memberof ListFilesResponseInner
   */
  '$id'?: string;
  /**
   * The name of the file.
   * @type {string}
   * @memberof ListFilesResponseInner
   */
  'name'?: string;
  /**
   * The path of the file.
   * @type {string}
   * @memberof ListFilesResponseInner
   */
  'path'?: string;
}
/**
 *
 * @export
 * @interface ListQuery
 */
export interface ListQuery {
  /**
   *
   * @type {ListQueryId}
   * @memberof ListQuery
   */
  'id'?: ListQueryId;
  /**
   *
   * @type {Array<ListQueryOperationsInner>}
   * @memberof ListQuery
   */
  'operations'?: Array<ListQueryOperationsInner>;
}
/**
 * @type ListQueryId
 * @export
 */
export type ListQueryId = Array<string> | string;

/**
 *
 * @export
 * @interface ListQueryOperationsInner
 */
export interface ListQueryOperationsInner {
  /**
   * The field path to filter on
   * @type {string}
   * @memberof ListQueryOperationsInner
   */
  'fieldPath': string;
  /**
   *
   * @type {Operator}
   * @memberof ListQueryOperationsInner
   */
  'operator': Operator;
  /**
   *
   * @type {AnyValue}
   * @memberof ListQueryOperationsInner
   */
  'value': AnyValue;
}
/**
 *
 * @export
 * @interface ListWorkflowsResponseInner
 */
export interface ListWorkflowsResponseInner {
  /**
   *
   * @type {PurposeEnum}
   * @memberof ListWorkflowsResponseInner
   */
  'purpose'?: PurposeEnum;
  /**
   * The name of the workflow
   * @type {string}
   * @memberof ListWorkflowsResponseInner
   */
  'name': string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof ListWorkflowsResponseInner
   */
  'initiators': ContextDetectionParams;
  /**
   * The fields of the workflow
   * @type {Array<ConversationContextField>}
   * @memberof ListWorkflowsResponseInner
   */
  'fields': Array<ConversationContextField>;
  /**
   * About this conversation - used as initial context
   * @type {string}
   * @memberof ListWorkflowsResponseInner
   */
  'context': string;
  /**
   * The webhook to call when a workflow is created
   * @type {string}
   * @memberof ListWorkflowsResponseInner
   */
  'onCreated'?: string;
  /**
   * The webhook to call when a workflow is updated
   * @type {string}
   * @memberof ListWorkflowsResponseInner
   */
  'onUpdated'?: string;
  /**
   * The webhook to call when a workflow is deleted
   * @type {string}
   * @memberof ListWorkflowsResponseInner
   */
  'onDeleted'?: string;
  /**
   * The webhook to call when a workflow has an error
   * @type {string}
   * @memberof ListWorkflowsResponseInner
   */
  'onError'?: string;
  /**
   * The priority of the workflow in relation to other workflows (determines activation order)
   * @type {number}
   * @memberof ListWorkflowsResponseInner
   */
  'priority': number;
  /**
   * The ID of the workflow
   * @type {string}
   * @memberof ListWorkflowsResponseInner
   */
  '$id': string;
}


/**
 *
 * @export
 * @interface ListWorkflowsResponseInnerAllOf
 */
export interface ListWorkflowsResponseInnerAllOf {
  /**
   * The ID of the workflow
   * @type {string}
   * @memberof ListWorkflowsResponseInnerAllOf
   */
  '$id': string;
}
/**
 * @type LlmConfig
 * @export
 */
export type LlmConfig = LlmConfigOneOf | LlmConfigOneOf1 | LlmConfigOneOf2;

/**
 *
 * @export
 * @interface LlmConfigOneOf
 */
export interface LlmConfigOneOf {
  /**
   *
   * @type {string}
   * @memberof LlmConfigOneOf
   */
  'engine'?: LlmConfigOneOfEngineEnum;
  /**
   *
   * @type {string}
   * @memberof LlmConfigOneOf
   */
  'model'?: LlmConfigOneOfModelEnum;
}

export const LlmConfigOneOfEngineEnum = {
  Openai: 'openai'
} as const;

export type LlmConfigOneOfEngineEnum = typeof LlmConfigOneOfEngineEnum[keyof typeof LlmConfigOneOfEngineEnum];
export const LlmConfigOneOfModelEnum = {
  _41106Preview: 'gpt-4-1106-preview',
  _4VisionPreview: 'gpt-4-vision-preview',
  _4: 'gpt-4',
  _40314: 'gpt-4-0314',
  _40613: 'gpt-4-0613',
  _432k: 'gpt-4-32k',
  _432k0314: 'gpt-4-32k-0314',
  _432k0613: 'gpt-4-32k-0613',
  _35Turbo: 'gpt-3.5-turbo',
  _35Turbo16k: 'gpt-3.5-turbo-16k',
  _35Turbo0301: 'gpt-3.5-turbo-0301',
  _35Turbo0613: 'gpt-3.5-turbo-0613',
  _35Turbo16k0613: 'gpt-3.5-turbo-16k-0613'
} as const;

export type LlmConfigOneOfModelEnum = typeof LlmConfigOneOfModelEnum[keyof typeof LlmConfigOneOfModelEnum];

/**
 *
 * @export
 * @interface LlmConfigOneOf1
 */
export interface LlmConfigOneOf1 {
  /**
   *
   * @type {string}
   * @memberof LlmConfigOneOf1
   */
  'engine'?: LlmConfigOneOf1EngineEnum;
  /**
   *
   * @type {string}
   * @memberof LlmConfigOneOf1
   */
  'model'?: string;
}

export const LlmConfigOneOf1EngineEnum = {
  Llama: 'llama'
} as const;

export type LlmConfigOneOf1EngineEnum = typeof LlmConfigOneOf1EngineEnum[keyof typeof LlmConfigOneOf1EngineEnum];

/**
 *
 * @export
 * @interface LlmConfigOneOf2
 */
export interface LlmConfigOneOf2 {
  /**
   *
   * @type {string}
   * @memberof LlmConfigOneOf2
   */
  'engine'?: LlmConfigOneOf2EngineEnum;
  /**
   *
   * @type {string}
   * @memberof LlmConfigOneOf2
   */
  'model'?: string;
}

export const LlmConfigOneOf2EngineEnum = {
  Bard: 'bard'
} as const;

export type LlmConfigOneOf2EngineEnum = typeof LlmConfigOneOf2EngineEnum[keyof typeof LlmConfigOneOf2EngineEnum];

/**
 * @type Logic
 * @export
 */
export type Logic = AndLogic | ConditionLogic | NotLogic | OrLogic;

/**
 *
 * @export
 * @interface Message
 */
export interface Message {
  /**
   * The role of the message (customer, agent, or business)
   * @type {string}
   * @memberof Message
   */
  'role': MessageRoleEnum;
  /**
   * The content of the message
   * @type {string}
   * @memberof Message
   */
  'content': string;
  /**
   * The name of the sender
   * @type {string}
   * @memberof Message
   */
  'name'?: string;
  /**
   * The time the message was sent
   * @type {string}
   * @memberof Message
   */
  'time': string;
}

export const MessageRoleEnum = {
  Customer: 'customer',
  Agent: 'agent',
  Context: 'context'
} as const;

export type MessageRoleEnum = typeof MessageRoleEnum[keyof typeof MessageRoleEnum];

/**
 *
 * @export
 * @interface MessageAllOf
 */
export interface MessageAllOf {
  /**
   * The time the message was sent
   * @type {string}
   * @memberof MessageAllOf
   */
  'time': string;
}
/**
 *
 * @export
 * @interface MessageBase
 */
export interface MessageBase {
  /**
   * The role of the message (customer, agent, or business)
   * @type {string}
   * @memberof MessageBase
   */
  'role': MessageBaseRoleEnum;
  /**
   * The content of the message
   * @type {string}
   * @memberof MessageBase
   */
  'content': string;
  /**
   * The name of the sender
   * @type {string}
   * @memberof MessageBase
   */
  'name'?: string;
}

export const MessageBaseRoleEnum = {
  Customer: 'customer',
  Agent: 'agent',
  Context: 'context'
} as const;

export type MessageBaseRoleEnum = typeof MessageBaseRoleEnum[keyof typeof MessageBaseRoleEnum];

/**
 *
 * @export
 * @interface MessageCreateRequest
 */
export interface MessageCreateRequest {
  /**
   *
   * @type {MessageCreateRequestConvo}
   * @memberof MessageCreateRequest
   */
  'convo': MessageCreateRequestConvo;
  /**
   * The message content to send to a user
   * @type {string}
   * @memberof MessageCreateRequest
   */
  'message': string;
  /**
   * The message content to send to a user in HTML format (only available in email)
   * @type {string}
   * @memberof MessageCreateRequest
   */
  'messageHtml'?: string;
  /**
   * Overrides the role of the user sending the message
   * @type {string}
   * @memberof MessageCreateRequest
   */
  'role'?: MessageCreateRequestRoleEnum;
}

export const MessageCreateRequestRoleEnum = {
  Agent: 'agent',
  Customer: 'customer',
  Context: 'context'
} as const;

export type MessageCreateRequestRoleEnum = typeof MessageCreateRequestRoleEnum[keyof typeof MessageCreateRequestRoleEnum];

/**
 * @type MessageCreateRequestConvo
 * @export
 */
export type MessageCreateRequestConvo = MessageCreateRequestConvoOneOf | string;

/**
 *
 * @export
 * @interface MessageCreateRequestConvoOneOf
 */
export interface MessageCreateRequestConvoOneOf {
  /**
   * The customers id, phone, or email to send to. The customer must be registered with your organization by having them reach out to you first.
   * @type {string}
   * @memberof MessageCreateRequestConvoOneOf
   */
  'customerIdOrPhoneOrEmail'?: string;
  /**
   * The agent id, phone (programmable or forward), or email this message is from. If an id is not provided and the provided value is a valid contact, the backend will resolve the agent with the corresponding agent document.
   * @type {string}
   * @memberof MessageCreateRequestConvoOneOf
   */
  'agentIdOrPhoneOrEmail': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof MessageCreateRequestConvoOneOf
   */
  'environment'?: ConversationEnvironment;
}


/**
 *
 * @export
 * @interface MessageCreateResponse
 */
export interface MessageCreateResponse {
  /**
   *
   * @type {boolean}
   * @memberof MessageCreateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof MessageCreateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof MessageCreateResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface MessageGetResponseInner
 */
export interface MessageGetResponseInner {
  /**
   * The role of the message (customer, agent, or business)
   * @type {string}
   * @memberof MessageGetResponseInner
   */
  'role': MessageGetResponseInnerRoleEnum;
  /**
   * The content of the message
   * @type {string}
   * @memberof MessageGetResponseInner
   */
  'content': string;
  /**
   * The name of the sender
   * @type {string}
   * @memberof MessageGetResponseInner
   */
  'name'?: string;
  /**
   * The time the message was sent
   * @type {string}
   * @memberof MessageGetResponseInner
   */
  'time': string;
  /**
   * The ID of the message to get
   * @type {string}
   * @memberof MessageGetResponseInner
   */
  '$id': string;
}

export const MessageGetResponseInnerRoleEnum = {
  Customer: 'customer',
  Agent: 'agent',
  Context: 'context'
} as const;

export type MessageGetResponseInnerRoleEnum = typeof MessageGetResponseInnerRoleEnum[keyof typeof MessageGetResponseInnerRoleEnum];

/**
 *
 * @export
 * @interface MessageGetResponseInnerAllOf
 */
export interface MessageGetResponseInnerAllOf {
  /**
   * The ID of the message to get
   * @type {string}
   * @memberof MessageGetResponseInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ModelError
 */
export interface ModelError {
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  'type': string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  'message': string;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  'param': string | null;
  /**
   *
   * @type {string}
   * @memberof ModelError
   */
  'code': string | null;
}
/**
 *
 * @export
 * @interface NotLogic
 */
export interface NotLogic {
  /**
   *
   * @type {Logic}
   * @memberof NotLogic
   */
  'not': Logic;
}
/**
 *
 * @export
 * @interface OperationBulkResponse
 */
export interface OperationBulkResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof OperationBulkResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof OperationBulkResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface OperationDocResponse
 */
export interface OperationDocResponse {
  /**
   *
   * @type {boolean}
   * @memberof OperationDocResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof OperationDocResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof OperationDocResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface OperationDocResponseAllOf
 */
export interface OperationDocResponseAllOf {
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof OperationDocResponseAllOf
   */
  'id': string;
}
/**
 *
 * @export
 * @interface OperationResponse
 */
export interface OperationResponse {
  /**
   *
   * @type {boolean}
   * @memberof OperationResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof OperationResponse
   */
  'error'?: Error;
}
/**
 * @type Operator
 * @export
 */
export type Operator = EqualityOperator | ExistenceOperator;

/**
 *
 * @export
 * @interface OrLogic
 */
export interface OrLogic {
  /**
   *
   * @type {Array<Logic>}
   * @memberof OrLogic
   */
  'or': Array<Logic>;
}
/**
 * The message to parse
 * @export
 * @interface ParseRequest
 */
export interface ParseRequest {
  /**
   * The message to parse
   * @type {string}
   * @memberof ParseRequest
   */
  'message': string;
  /**
   * The language of the message
   * @type {string}
   * @memberof ParseRequest
   */
  'language'?: string;
  /**
   * If provided, this will override the organizations saved entities (used for app development)
   * @type {Array<Array<EntitiesBuildConfigInner>>}
   * @memberof ParseRequest
   */
  'entities'?: Array<Array<EntitiesBuildConfigInner>>;
}
/**
 * The parsed message
 * @export
 * @interface ParseResponse
 */
export interface ParseResponse {
  /**
   * Context that is derived from the message
   * @type {{ [key: string]: any; }}
   * @memberof ParseResponse
   */
  'context': { [key: string]: any; };
  /**
   * The time it took to parse the message in milliseconds
   * @type {number}
   * @memberof ParseResponse
   */
  'ms': number;
  /**
   * the fields that were parsed
   * @type {Array<string>}
   * @memberof ParseResponse
   */
  'parsed': Array<string>;
}
/**
 * @type ParsedContextEntity
 * @export
 */
export type ParsedContextEntity = string | { [key: string]: any; };

/**
 *
 * @export
 * @interface PmtConfig
 */
export interface PmtConfig {
  /**
   *
   * @type {string}
   * @memberof PmtConfig
   */
  'engine'?: PmtConfigEngineEnum;
  /**
   *
   * @type {string}
   * @memberof PmtConfig
   */
  'model'?: PmtConfigModelEnum;
}

export const PmtConfigEngineEnum = {
  Scout9: 'scout9'
} as const;

export type PmtConfigEngineEnum = typeof PmtConfigEngineEnum[keyof typeof PmtConfigEngineEnum];
export const PmtConfigModelEnum = {
  _10: 'orin-1.0',
  _20Preview: 'orin-2.0-preview'
} as const;

export type PmtConfigModelEnum = typeof PmtConfigModelEnum[keyof typeof PmtConfigModelEnum];

/**
 * Purchase a phone number subscription for an agent
 * @export
 * @interface PurchasePhoneRequest
 */
export interface PurchasePhoneRequest {
  /**
   * The agent\'s id
   * @type {string}
   * @memberof PurchasePhoneRequest
   */
  '$agent'?: string;
  /**
   * If true, the phone number will be purchased for an annual subscription
   * @type {boolean}
   * @memberof PurchasePhoneRequest
   */
  'annual'?: boolean;
  /**
   * The area code of the phone number to purchase
   * @type {number}
   * @memberof PurchasePhoneRequest
   */
  'areaCode'?: number;
}
/**
 *
 * @export
 * @interface PurchasePhoneResponse
 */
export interface PurchasePhoneResponse {
  /**
   * the phone number that was purchased
   * @type {string}
   * @memberof PurchasePhoneResponse
   */
  'phoneNumber'?: string;
  /**
   * Internal identifier for the phone number
   * @type {string}
   * @memberof PurchasePhoneResponse
   */
  'sid'?: string;
}
/**
 *
 * @export
 * @enum {string}
 */

export const PurposeEnum = {
  Context: 'context',
  AgentAudio: 'agent-audio',
  AgentTranscript: 'agent-transcript'
} as const;

export type PurposeEnum = typeof PurposeEnum[keyof typeof PurposeEnum];


/**
 *
 * @export
 * @interface RegexCondition
 */
export interface RegexCondition {
  /**
   *
   * @type {string}
   * @memberof RegexCondition
   */
  'path': string;
  /**
   *
   * @type {string}
   * @memberof RegexCondition
   */
  'regex': string;
  /**
   *
   * @type {boolean}
   * @memberof RegexCondition
   */
  'external'?: boolean;
}
/**
 *
 * @export
 * @interface ScheduleCreateRequest
 */
export interface ScheduleCreateRequest {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduleCreateRequest
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduleCreateRequest
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduleCreateRequest
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof ScheduleCreateRequest
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ScheduleCreateRequest
   */
  'environment': ConversationEnvironment;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduleCreateRequest
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduleCreateRequest
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduleCreateRequest
   */
  'initialMessageHtml'?: string | null;
  /**
   * Group this conversation is in
   * @type {string}
   * @memberof ScheduleCreateRequest
   */
  '$group'?: string;
  /**
   *
   * @type {ConversationCreateRequestBaseWorkflow}
   * @memberof ScheduleCreateRequest
   */
  '$workflow'?: ConversationCreateRequestBaseWorkflow;
}


/**
 *
 * @export
 * @interface ScheduleCreateResponse
 */
export interface ScheduleCreateResponse {
  /**
   *
   * @type {boolean}
   * @memberof ScheduleCreateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ScheduleCreateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ScheduleCreateResponse
   */
  'id': string;
  /**
   * ISO Time the initial message has been sent
   * @type {string}
   * @memberof ScheduleCreateResponse
   */
  'sent'?: string;
}
/**
 *
 * @export
 * @interface ScheduleCreateResponseAllOf
 */
export interface ScheduleCreateResponseAllOf {
  /**
   * ISO Time the initial message has been sent
   * @type {string}
   * @memberof ScheduleCreateResponseAllOf
   */
  'sent'?: string;
}
/**
 *
 * @export
 * @interface ScheduleGetResponse
 */
export interface ScheduleGetResponse {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduleGetResponse
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduleGetResponse
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ScheduleGetResponse
   */
  'environment': ConversationEnvironment;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  'initialMessageHtml'?: string | null;
  /**
   * Group this conversation is in
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  '$group'?: string;
  /**
   * The ID of the workflow used for this conversation
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  '$workflow': string;
  /**
   * The client web url of the conversation
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  'clientWebUrl'?: string;
  /**
   * The agent web url of the conversation (requires phone two-factor authentication)
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  'agentWebUrl'?: string;
  /**
   * The agent test web url of the conversation, used for testing the conversation without notifying the customer
   * @type {string}
   * @memberof ScheduleGetResponse
   */
  'agentTestWebUrl'?: string;
}


/**
 *
 * @export
 * @interface ScheduleGroupCreateRequest
 */
export interface ScheduleGroupCreateRequest {
  /**
   *
   * @type {ConversationCreateRequestBaseWorkflow}
   * @memberof ScheduleGroupCreateRequest
   */
  '$workflow'?: ConversationCreateRequestBaseWorkflow;
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduleGroupCreateRequest
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduleGroupCreateRequest
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduleGroupCreateRequest
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduleGroupCreateRequest
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduleGroupCreateRequest
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduleGroupCreateRequest
   */
  'initialMessageHtml'?: string | null;
  /**
   * The delay in milliseconds between each customer, defaults to 15000 (15 seconds)
   * @type {number}
   * @memberof ScheduleGroupCreateRequest
   */
  'delay'?: number;
  /**
   *
   * @type {ScheduleGroupCreateRequestAllOfCGroup}
   * @memberof ScheduleGroupCreateRequest
   */
  '$cGroup': ScheduleGroupCreateRequestAllOfCGroup;
}
/**
 *
 * @export
 * @interface ScheduleGroupCreateRequestAllOf
 */
export interface ScheduleGroupCreateRequestAllOf {
  /**
   *
   * @type {ScheduleGroupCreateRequestAllOfCGroup}
   * @memberof ScheduleGroupCreateRequestAllOf
   */
  '$cGroup': ScheduleGroupCreateRequestAllOfCGroup;
}
/**
 * @type ScheduleGroupCreateRequestAllOfCGroup
 * @export
 */
export type ScheduleGroupCreateRequestAllOfCGroup = CustomerGroup | string;

/**
 *
 * @export
 * @interface ScheduleGroupCreateResponse
 */
export interface ScheduleGroupCreateResponse {
  /**
   *
   * @type {boolean}
   * @memberof ScheduleGroupCreateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ScheduleGroupCreateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ScheduleGroupCreateResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface ScheduleGroupGetResponse
 */
export interface ScheduleGroupGetResponse {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduleGroupGetResponse
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduleGroupGetResponse
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  'initialMessageHtml'?: string | null;
  /**
   * The delay in milliseconds between each customer, defaults to 15000 (15 seconds)
   * @type {number}
   * @memberof ScheduleGroupGetResponse
   */
  'delay'?: number;
  /**
   * The ID of the workflow used for this conversation
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  '$workflow': string;
  /**
   * The ID of the scheduled conversation group
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  '$id': string;
  /**
   * ISO Time the initial message has been sent
   * @type {boolean}
   * @memberof ScheduleGroupGetResponse
   */
  'sent'?: boolean;
  /**
   * The ID of the group the customers belong to
   * @type {string}
   * @memberof ScheduleGroupGetResponse
   */
  '$cGroup'?: string;
}
/**
 *
 * @export
 * @interface ScheduleGroupGetResponseAllOf
 */
export interface ScheduleGroupGetResponseAllOf {
  /**
   * The ID of the scheduled conversation group
   * @type {string}
   * @memberof ScheduleGroupGetResponseAllOf
   */
  '$id': string;
  /**
   * ISO Time the initial message has been sent
   * @type {boolean}
   * @memberof ScheduleGroupGetResponseAllOf
   */
  'sent'?: boolean;
  /**
   * The ID of the group the customers belong to
   * @type {string}
   * @memberof ScheduleGroupGetResponseAllOf
   */
  '$cGroup'?: string;
}
/**
 *
 * @export
 * @interface ScheduleGroupRemoveResponse
 */
export interface ScheduleGroupRemoveResponse {
  /**
   *
   * @type {boolean}
   * @memberof ScheduleGroupRemoveResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ScheduleGroupRemoveResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ScheduleGroupRemoveResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface ScheduleGroupUpdateRequest
 */
export interface ScheduleGroupUpdateRequest {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduleGroupUpdateRequest
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduleGroupUpdateRequest
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduleGroupUpdateRequest
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduleGroupUpdateRequest
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduleGroupUpdateRequest
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduleGroupUpdateRequest
   */
  'initialMessageHtml'?: string | null;
  /**
   * The delay in milliseconds between each customer, defaults to 15000 (15 seconds)
   * @type {number}
   * @memberof ScheduleGroupUpdateRequest
   */
  'delay'?: number;
  /**
   *
   * @type {ConversationUpdateRequestBaseWorkflow}
   * @memberof ScheduleGroupUpdateRequest
   * @deprecated
   */
  '$workflow'?: ConversationUpdateRequestBaseWorkflow;
  /**
   *
   * @type {ScheduleGroupCreateRequestAllOfCGroup}
   * @memberof ScheduleGroupUpdateRequest
   */
  '$cGroup'?: ScheduleGroupCreateRequestAllOfCGroup;
  /**
   * The ID of the scheduled conversation group to update
   * @type {string}
   * @memberof ScheduleGroupUpdateRequest
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ScheduleGroupUpdateRequestAllOf
 */
export interface ScheduleGroupUpdateRequestAllOf {
  /**
   *
   * @type {ScheduleGroupCreateRequestAllOfCGroup}
   * @memberof ScheduleGroupUpdateRequestAllOf
   */
  '$cGroup'?: ScheduleGroupCreateRequestAllOfCGroup;
  /**
   * The ID of the scheduled conversation group to update
   * @type {string}
   * @memberof ScheduleGroupUpdateRequestAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface ScheduleGroupUpdateResponse
 */
export interface ScheduleGroupUpdateResponse {
  /**
   *
   * @type {boolean}
   * @memberof ScheduleGroupUpdateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ScheduleGroupUpdateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ScheduleGroupUpdateResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface ScheduleRemoveResponse
 */
export interface ScheduleRemoveResponse {
  /**
   *
   * @type {boolean}
   * @memberof ScheduleRemoveResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ScheduleRemoveResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ScheduleRemoveResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface ScheduleUpdateRequest
 */
export interface ScheduleUpdateRequest {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduleUpdateRequest
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduleUpdateRequest
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ScheduleUpdateRequest
   */
  'environment': ConversationEnvironment;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  'initialMessageHtml'?: string | null;
  /**
   * Group this conversation is in
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  '$group'?: string;
  /**
   *
   * @type {ConversationUpdateRequestBaseWorkflow}
   * @memberof ScheduleUpdateRequest
   * @deprecated
   */
  '$workflow'?: ConversationUpdateRequestBaseWorkflow;
  /**
   * The ID of the scheduled conversation to update
   * @type {string}
   * @memberof ScheduleUpdateRequest
   */
  '$id'?: string;
}


/**
 *
 * @export
 * @interface ScheduleUpdateRequestAllOf
 */
export interface ScheduleUpdateRequestAllOf {
  /**
   * The ID of the scheduled conversation to update
   * @type {string}
   * @memberof ScheduleUpdateRequestAllOf
   */
  '$id'?: string;
}
/**
 *
 * @export
 * @interface ScheduleUpdateResponse
 */
export interface ScheduleUpdateResponse {
  /**
   *
   * @type {boolean}
   * @memberof ScheduleUpdateResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof ScheduleUpdateResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof ScheduleUpdateResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface ScheduledConversation
 */
export interface ScheduledConversation {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduledConversation
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduledConversation
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduledConversation
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * Customer this conversation is with
   * @type {string}
   * @memberof ScheduledConversation
   */
  '$customer': string;
  /**
   *
   * @type {ConversationEnvironment}
   * @memberof ScheduledConversation
   */
  'environment': ConversationEnvironment;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduledConversation
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduledConversation
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduledConversation
   */
  'initialMessageHtml'?: string | null;
  /**
   * Group this conversation is in
   * @type {string}
   * @memberof ScheduledConversation
   */
  '$group'?: string;
}


/**
 *
 * @export
 * @interface ScheduledConversationAllOf
 */
export interface ScheduledConversationAllOf {
  /**
   * Group this conversation is in
   * @type {string}
   * @memberof ScheduledConversationAllOf
   */
  '$group'?: string;
}
/**
 *
 * @export
 * @interface ScheduledConversationGroup
 */
export interface ScheduledConversationGroup {
  /**
   * Default agent persona id assigned to the conversation(s)
   * @type {string}
   * @memberof ScheduledConversationGroup
   */
  '$agent': string;
  /**
   * Initial contexts to load when starting the conversation
   * @type {Array<string>}
   * @memberof ScheduledConversationGroup
   */
  'initialContexts'?: Array<string>;
  /**
   *
   * @type {ConversationBaseEnvironmentProps}
   * @memberof ScheduledConversationGroup
   */
  'environmentProps'?: ConversationBaseEnvironmentProps;
  /**
   * ISO 8601 datetime string
   * @type {string}
   * @memberof ScheduledConversationGroup
   */
  'scheduled': string;
  /**
   * The initial message to send to the customer
   * @type {string}
   * @memberof ScheduledConversationGroup
   */
  'initialMessage': string;
  /**
   * The initial message to send to the customer in HTML
   * @type {string}
   * @memberof ScheduledConversationGroup
   */
  'initialMessageHtml'?: string | null;
  /**
   * The delay in milliseconds between each customer, defaults to 15000 (15 seconds)
   * @type {number}
   * @memberof ScheduledConversationGroup
   */
  'delay'?: number;
}
/**
 *
 * @export
 * @interface ScheduledConversationGroupAllOf
 */
export interface ScheduledConversationGroupAllOf {
  /**
   * The delay in milliseconds between each customer, defaults to 15000 (15 seconds)
   * @type {number}
   * @memberof ScheduledConversationGroupAllOf
   */
  'delay'?: number;
}
/**
 * The `File` object represents a document that has been uploaded to Scout9.
 * @export
 * @interface Scout9File
 */
export interface Scout9File {
  /**
   * The file identifier, which can be referenced in the API endpoints.
   * @type {string}
   * @memberof Scout9File
   */
  'id': string;
  /**
   * The object type, which is always \"file\".
   * @type {string}
   * @memberof Scout9File
   */
  'object': string;
  /**
   * The size of the file in bytes.
   * @type {number}
   * @memberof Scout9File
   */
  'bytes': number;
  /**
   * The unix timestamp for when the file was created.
   * @type {number}
   * @memberof Scout9File
   */
  'created_at': number;
  /**
   * The name of the file.
   * @type {string}
   * @memberof Scout9File
   */
  'filename': string;
  /**
   * The intended purpose of the file. Currently, only \"fine-tune\" is supported.
   * @type {string}
   * @memberof Scout9File
   */
  'purpose': string;
  /**
   * The current status of the file, which can be either `uploaded`, `processed`, `pending`, `error`, `deleting` or `deleted`.
   * @type {string}
   * @memberof Scout9File
   */
  'status'?: string;
  /**
   * Additional details about the status of the file. If the file is in the `error` state, this will include a message describing the error.
   * @type {string}
   * @memberof Scout9File
   */
  'status_details'?: string | null;
}
/**
 *
 * @export
 * @interface Scout9ProjectConfig
 */
export interface Scout9ProjectConfig {
  /**
   *
   * @type {LlmConfig}
   * @memberof Scout9ProjectConfig
   */
  'llm': LlmConfig;
  /**
   *
   * @type {PmtConfig}
   * @memberof Scout9ProjectConfig
   */
  'pmt': PmtConfig;
}
/**
 *
 * @export
 * @interface UpdateAgentRequest
 */
export interface UpdateAgentRequest {
  /**
   * The ID of the agent to update
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  '$id': string;
  /**
   * Sample conversations that help build out your agent to mimic your responses
   * @type {Array<CreateAgentRequestAllOfConversationsInner>}
   * @memberof UpdateAgentRequest
   */
  'conversations'?: Array<CreateAgentRequestAllOfConversationsInner>;
  /**
   * Sample audio files that help build out your agent to mimic your voice
   * @type {Array<string>}
   * @memberof UpdateAgentRequest
   */
  'audio'?: Array<string>;
  /**
   * Agent first name
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'firstName'?: string;
  /**
   * Agent last name
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'lastName'?: string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof UpdateAgentRequest
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof UpdateAgentRequest
   */
  'title'?: string;
  /**
   *
   * @type {AgentContext}
   * @memberof UpdateAgentRequest
   */
  'context'?: AgentContext;
  /**
   * Transcripts of the agent
   * @type {Array<string>}
   * @memberof UpdateAgentRequest
   */
  'transcripts'?: Array<string>;
  /**
   * Audios of the agent
   * @type {Array<string>}
   * @memberof UpdateAgentRequest
   */
  'audios'?: Array<string>;
  /**
   * Locations ids the agent is included in
   * @type {Array<string>}
   * @memberof UpdateAgentRequest
   */
  'includedLocations'?: Array<string>;
  /**
   * Locations id the agent is excluded from
   * @type {Array<string>}
   * @memberof UpdateAgentRequest
   */
  'excludedLocations'?: Array<string>;
}
/**
 *
 * @export
 * @interface UpdateAgentRequestAllOf
 */
export interface UpdateAgentRequestAllOf {
  /**
   * The ID of the agent to update
   * @type {string}
   * @memberof UpdateAgentRequestAllOf
   */
  '$id': string;
  /**
   * Sample conversations that help build out your agent to mimic your responses
   * @type {Array<CreateAgentRequestAllOfConversationsInner>}
   * @memberof UpdateAgentRequestAllOf
   */
  'conversations'?: Array<CreateAgentRequestAllOfConversationsInner>;
  /**
   * Sample audio files that help build out your agent to mimic your voice
   * @type {Array<string>}
   * @memberof UpdateAgentRequestAllOf
   */
  'audio'?: Array<string>;
}
/**
 *
 * @export
 * @interface UpdateAgentResponse
 */
export interface UpdateAgentResponse {
  /**
   *
   * @type {boolean}
   * @memberof UpdateAgentResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof UpdateAgentResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof UpdateAgentResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface UpdateAgentsRequest
 */
export interface UpdateAgentsRequest {
  /**
   *
   * @type {Array<UpdateAgentsRequestAgentsInner>}
   * @memberof UpdateAgentsRequest
   */
  'agents'?: Array<UpdateAgentsRequestAgentsInner>;
}
/**
 *
 * @export
 * @interface UpdateAgentsRequestAgentsInner
 */
export interface UpdateAgentsRequestAgentsInner {
  /**
   * Agent first name
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'firstName': string;
  /**
   * Agent last name
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'lastName': string;
  /**
   * Agent is inactive
   * @type {boolean}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'inactive'?: boolean;
  /**
   * Programmable phone number
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'programmablePhoneNumber'?: string;
  /**
   * Programmable phone number SID
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'programmablePhoneNumberSid'?: string;
  /**
   * Email address from Scout9 gmail subdomain
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'programmableEmail'?: string;
  /**
   * Forward email
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'forwardEmail'?: string;
  /**
   * Forward phone
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'forwardPhone'?: string;
  /**
   * Title of the agent, defaults to \"Agent\"
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'title'?: string;
  /**
   *
   * @type {AgentContext}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'context'?: AgentContext;
  /**
   * Transcripts of the agent
   * @type {Array<string>}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'transcripts'?: Array<string>;
  /**
   * Audios of the agent
   * @type {Array<string>}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'audios'?: Array<string>;
  /**
   * Locations ids the agent is included in
   * @type {Array<string>}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'includedLocations'?: Array<string>;
  /**
   * Locations id the agent is excluded from
   * @type {Array<string>}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  'excludedLocations'?: Array<string>;
  /**
   * The ID of the agent
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInner
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateAgentsRequestAgentsInnerAllOf
 */
export interface UpdateAgentsRequestAgentsInnerAllOf {
  /**
   * The ID of the agent
   * @type {string}
   * @memberof UpdateAgentsRequestAgentsInnerAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateAgentsResponse
 */
export interface UpdateAgentsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof UpdateAgentsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof UpdateAgentsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface UpdateContextDataRequest
 */
export interface UpdateContextDataRequest {
  /**
   * The context id to create data for
   * @type {string}
   * @memberof UpdateContextDataRequest
   */
  'context': string;
  /**
   *
   * @type {Array<{ [key: string]: ContextRowValue; }>}
   * @memberof UpdateContextDataRequest
   */
  'data': Array<{ [key: string]: ContextRowValue; }>;
}
/**
 *
 * @export
 * @interface UpdateContextDataResponse
 */
export interface UpdateContextDataResponse {
  /**
   *
   * @type {boolean}
   * @memberof UpdateContextDataResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof UpdateContextDataResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof UpdateContextDataResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface UpdateContextRequest
 */
export interface UpdateContextRequest {
  /**
   * The name of the context
   * @type {string}
   * @memberof UpdateContextRequest
   */
  'name': string;
  /**
   * Whether or not the context is modifiable
   * @type {boolean}
   * @memberof UpdateContextRequest
   */
  'modifiable'?: boolean;
  /**
   * The description of the context
   * @type {string}
   * @memberof UpdateContextRequest
   */
  'description'?: string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof UpdateContextRequest
   */
  'detection'?: ContextDetectionParams;
  /**
   * The API to use for context detection
   * @type {string}
   * @memberof UpdateContextRequest
   */
  'detectionApi'?: string;
  /**
   * The ID column of the context
   * @type {string}
   * @memberof UpdateContextRequest
   */
  'idColumn'?: string;
  /**
   * The columns of the context
   * @type {Array<string>}
   * @memberof UpdateContextRequest
   */
  'columns'?: Array<string>;
  /**
   * The required columns of the context
   * @type {Array<string>}
   * @memberof UpdateContextRequest
   */
  'requiredColumns'?: Array<string>;
  /**
   * Whether or not to force NER
   * @type {boolean}
   * @memberof UpdateContextRequest
   */
  'forceNER'?: boolean;
  /**
   *
   * @type {ContextModel}
   * @memberof UpdateContextRequest
   */
  'model'?: ContextModel;
  /**
   * The ID of the context to update
   * @type {string}
   * @memberof UpdateContextRequest
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateContextRequestAllOf
 */
export interface UpdateContextRequestAllOf {
  /**
   * The ID of the context to update
   * @type {string}
   * @memberof UpdateContextRequestAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateContextResponse
 */
export interface UpdateContextResponse {
  /**
   *
   * @type {boolean}
   * @memberof UpdateContextResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof UpdateContextResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof UpdateContextResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface UpdateContextsRequest
 */
export interface UpdateContextsRequest {
  /**
   *
   * @type {Array<ListContextsResponseInner>}
   * @memberof UpdateContextsRequest
   */
  'contexts'?: Array<ListContextsResponseInner>;
}
/**
 *
 * @export
 * @interface UpdateContextsResponse
 */
export interface UpdateContextsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof UpdateContextsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof UpdateContextsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerGroupRequest
 */
export interface UpdateCustomerGroupRequest {
  /**
   * The name of the customer group
   * @type {string}
   * @memberof UpdateCustomerGroupRequest
   */
  'name': string;
  /**
   * The description of the customer group
   * @type {string}
   * @memberof UpdateCustomerGroupRequest
   */
  'description'?: string;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof UpdateCustomerGroupRequest
   */
  'metadata'?: { [key: string]: any; };
  /**
   *
   * @type {Array<CustomerGroupRecord>}
   * @memberof UpdateCustomerGroupRequest
   */
  'customers': Array<CustomerGroupRecord>;
  /**
   * The ID of the CustomerGroup
   * @type {string}
   * @memberof UpdateCustomerGroupRequest
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerGroupRequestAllOf
 */
export interface UpdateCustomerGroupRequestAllOf {
  /**
   * The ID of the CustomerGroup
   * @type {string}
   * @memberof UpdateCustomerGroupRequestAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerGroupResponse
 */
export interface UpdateCustomerGroupResponse {
  /**
   *
   * @type {boolean}
   * @memberof UpdateCustomerGroupResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof UpdateCustomerGroupResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof UpdateCustomerGroupResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerGroupsRequest
 */
export interface UpdateCustomerGroupsRequest {
  /**
   *
   * @type {Array<ListCustomerGroupsResponseInner>}
   * @memberof UpdateCustomerGroupsRequest
   */
  'CustomerGroups'?: Array<ListCustomerGroupsResponseInner>;
}
/**
 *
 * @export
 * @interface UpdateCustomerGroupsResponse
 */
export interface UpdateCustomerGroupsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof UpdateCustomerGroupsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof UpdateCustomerGroupsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerRequest
 */
export interface UpdateCustomerRequest {
  /**
   * The customers first name
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'firstName'?: string;
  /**
   * The customers last name
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'lastName'?: string;
  /**
   * The customers full name
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'name': string;
  /**
   * The customers email address
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'email'?: string | null;
  /**
   * The customers phone number
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'phone'?: string | null;
  /**
   * The customers profile image
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'img'?: string | null;
  /**
   * The customers neighborhood
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'neighborhood'?: string | null;
  /**
   * The customers city
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'city'?: string | null;
  /**
   * The customers 2-letter country code
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'country'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'line1'?: string | null;
  /**
   * The customers street address
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'line2'?: string | null;
  /**
   * The customers postal code
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'postal_code'?: string | null;
  /**
   * The customers state, county, province, or region
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'state'?: string | null;
  /**
   * The customers town (only used in Japan)
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'town'?: string | null;
  /**
   *
   * @type {BlockInfo}
   * @memberof UpdateCustomerRequest
   */
  'blocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof UpdateCustomerRequest
   */
  'phoneBlocked'?: BlockInfo;
  /**
   *
   * @type {BlockInfo}
   * @memberof UpdateCustomerRequest
   */
  'emailBlocked'?: BlockInfo;
  /**
   * The date the customer joined the business
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'joined'?: string | null;
  /**
   * The customers stripe ID
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'stripe'?: string | null;
  /**
   * The customers stripe ID in the dev environment
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  'stripeDev'?: string | null;
  /**
   * The ID of the customer
   * @type {string}
   * @memberof UpdateCustomerRequest
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateCustomerRequestAllOf
 */
export interface UpdateCustomerRequestAllOf {
  /**
   * The ID of the customer
   * @type {string}
   * @memberof UpdateCustomerRequestAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateCustomersRequest
 */
export interface UpdateCustomersRequest {
  /**
   *
   * @type {Array<ListCustomersResponseInner>}
   * @memberof UpdateCustomersRequest
   */
  'customers': Array<ListCustomersResponseInner>;
}
/**
 *
 * @export
 * @interface UpdateCustomersResponse
 */
export interface UpdateCustomersResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof UpdateCustomersResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof UpdateCustomersResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface UpdateWorkflowRequest
 */
export interface UpdateWorkflowRequest {
  /**
   * The ID of the workflow to update
   * @type {string}
   * @memberof UpdateWorkflowRequest
   */
  '$id': string;
  /**
   *
   * @type {PurposeEnum}
   * @memberof UpdateWorkflowRequest
   */
  'purpose'?: PurposeEnum;
  /**
   * The name of the workflow
   * @type {string}
   * @memberof UpdateWorkflowRequest
   */
  'name'?: string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof UpdateWorkflowRequest
   */
  'initiators'?: ContextDetectionParams;
  /**
   * The fields of the workflow
   * @type {Array<ConversationContextField>}
   * @memberof UpdateWorkflowRequest
   */
  'fields'?: Array<ConversationContextField>;
  /**
   * About this conversation - used as initial context
   * @type {string}
   * @memberof UpdateWorkflowRequest
   */
  'context'?: string;
  /**
   * The webhook to call when a workflow is created
   * @type {string}
   * @memberof UpdateWorkflowRequest
   */
  'onCreated'?: string;
  /**
   * The webhook to call when a workflow is updated
   * @type {string}
   * @memberof UpdateWorkflowRequest
   */
  'onUpdated'?: string;
  /**
   * The webhook to call when a workflow is deleted
   * @type {string}
   * @memberof UpdateWorkflowRequest
   */
  'onDeleted'?: string;
  /**
   * The webhook to call when a workflow has an error
   * @type {string}
   * @memberof UpdateWorkflowRequest
   */
  'onError'?: string;
  /**
   * The priority of the workflow in relation to other workflows (determines activation order)
   * @type {number}
   * @memberof UpdateWorkflowRequest
   */
  'priority'?: number;
}


/**
 *
 * @export
 * @interface UpdateWorkflowRequestAllOf
 */
export interface UpdateWorkflowRequestAllOf {
  /**
   * The ID of the workflow to update
   * @type {string}
   * @memberof UpdateWorkflowRequestAllOf
   */
  '$id': string;
}
/**
 *
 * @export
 * @interface UpdateWorkflowResponse
 */
export interface UpdateWorkflowResponse {
  /**
   *
   * @type {boolean}
   * @memberof UpdateWorkflowResponse
   */
  'success': boolean;
  /**
   *
   * @type {Error}
   * @memberof UpdateWorkflowResponse
   */
  'error'?: Error;
  /**
   * The id of the document that was created, updated, or deleted
   * @type {string}
   * @memberof UpdateWorkflowResponse
   */
  'id': string;
}
/**
 *
 * @export
 * @interface UpdateWorkflowsRequest
 */
export interface UpdateWorkflowsRequest {
  /**
   *
   * @type {Array<ListWorkflowsResponseInner>}
   * @memberof UpdateWorkflowsRequest
   */
  'workflows'?: Array<ListWorkflowsResponseInner>;
}
/**
 *
 * @export
 * @interface UpdateWorkflowsResponse
 */
export interface UpdateWorkflowsResponse {
  /**
   * ISO 8601 datetime string of when the operation was queued
   * @type {string}
   * @memberof UpdateWorkflowsResponse
   */
  'queued': string;
  /**
   * The operation id to view the operation end results
   * @type {string}
   * @memberof UpdateWorkflowsResponse
   */
  '$operation': string;
}
/**
 *
 * @export
 * @interface Workflow
 */
export interface Workflow {
  /**
   *
   * @type {PurposeEnum}
   * @memberof Workflow
   */
  'purpose'?: PurposeEnum;
  /**
   * The name of the workflow
   * @type {string}
   * @memberof Workflow
   */
  'name': string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof Workflow
   */
  'initiators': ContextDetectionParams;
  /**
   * The fields of the workflow
   * @type {Array<ConversationContextField>}
   * @memberof Workflow
   */
  'fields': Array<ConversationContextField>;
  /**
   * About this conversation - used as initial context
   * @type {string}
   * @memberof Workflow
   */
  'context': string;
  /**
   * The webhook to call when a workflow is created
   * @type {string}
   * @memberof Workflow
   */
  'onCreated'?: string;
  /**
   * The webhook to call when a workflow is updated
   * @type {string}
   * @memberof Workflow
   */
  'onUpdated'?: string;
  /**
   * The webhook to call when a workflow is deleted
   * @type {string}
   * @memberof Workflow
   */
  'onDeleted'?: string;
  /**
   * The webhook to call when a workflow has an error
   * @type {string}
   * @memberof Workflow
   */
  'onError'?: string;
  /**
   * The priority of the workflow in relation to other workflows (determines activation order)
   * @type {number}
   * @memberof Workflow
   */
  'priority': number;
}


/**
 *
 * @export
 * @interface WorkflowEvent
 */
export interface WorkflowEvent {
  /**
   *
   * @type {Array<Message>}
   * @memberof WorkflowEvent
   */
  'messages': Array<Message>;
  /**
   *
   * @type {Message}
   * @memberof WorkflowEvent
   */
  'message'?: Message;
  /**
   *
   * @type {Conversation}
   * @memberof WorkflowEvent
   */
  'conversation': Conversation;
  /**
   *
   * @type {{ [key: string]: any; }}
   * @memberof WorkflowEvent
   */
  'context': { [key: string]: any; };
  /**
   *
   * @type {Agent}
   * @memberof WorkflowEvent
   */
  'agent': Agent;
  /**
   *
   * @type {Customer}
   * @memberof WorkflowEvent
   */
  'customer': Customer;
  /**
   * The intent of the message
   * @type {string}
   * @memberof WorkflowEvent
   */
  'intent': string;
  /**
   * The number of times the workflow has been triggered without a response
   * @type {number}
   * @memberof WorkflowEvent
   */
  'stagnationCount': number;
}
/**
 *
 * @export
 * @interface WorkflowPartial
 */
export interface WorkflowPartial {
  /**
   *
   * @type {PurposeEnum}
   * @memberof WorkflowPartial
   */
  'purpose'?: PurposeEnum;
  /**
   * The name of the workflow
   * @type {string}
   * @memberof WorkflowPartial
   */
  'name'?: string;
  /**
   *
   * @type {ContextDetectionParams}
   * @memberof WorkflowPartial
   */
  'initiators'?: ContextDetectionParams;
  /**
   * The fields of the workflow
   * @type {Array<ConversationContextField>}
   * @memberof WorkflowPartial
   */
  'fields'?: Array<ConversationContextField>;
  /**
   * About this conversation - used as initial context
   * @type {string}
   * @memberof WorkflowPartial
   */
  'context'?: string;
  /**
   * The webhook to call when a workflow is created
   * @type {string}
   * @memberof WorkflowPartial
   */
  'onCreated'?: string;
  /**
   * The webhook to call when a workflow is updated
   * @type {string}
   * @memberof WorkflowPartial
   */
  'onUpdated'?: string;
  /**
   * The webhook to call when a workflow is deleted
   * @type {string}
   * @memberof WorkflowPartial
   */
  'onDeleted'?: string;
  /**
   * The webhook to call when a workflow has an error
   * @type {string}
   * @memberof WorkflowPartial
   */
  'onError'?: string;
  /**
   * The priority of the workflow in relation to other workflows (determines activation order)
   * @type {number}
   * @memberof WorkflowPartial
   */
  'priority'?: number;
}


/**
 * @type WorkflowResponse
 * @export
 */
export type WorkflowResponse = Array<WorkflowResponseSlot> | WorkflowResponseSlot;

/**
 *
 * @export
 * @interface WorkflowResponseSlot
 */
export interface WorkflowResponseSlot {
  /**
   *
   * @type {WorkflowResponseSlotForward}
   * @memberof WorkflowResponseSlot
   */
  'forward'?: WorkflowResponseSlotForward;
  /**
   *
   * @type {WorkflowResponseSlotInstructions}
   * @memberof WorkflowResponseSlot
   */
  'instructions'?: WorkflowResponseSlotInstructions;
  /**
   *
   * @type {Array<string>}
   * @memberof WorkflowResponseSlot
   */
  'removeInstructions'?: Array<string>;
  /**
   *
   * @type {string}
   * @memberof WorkflowResponseSlot
   */
  'message'?: string;
  /**
   *
   * @type {number}
   * @memberof WorkflowResponseSlot
   */
  'secondsDelay'?: number;
  /**
   *
   * @type {number}
   * @memberof WorkflowResponseSlot
   */
  'scheduled'?: number;
  /**
   *
   * @type {object}
   * @memberof WorkflowResponseSlot
   */
  'contextUpsert'?: object;
  /**
   *
   * @type {boolean}
   * @memberof WorkflowResponseSlot
   */
  'resetIntent'?: boolean;
}
/**
 * @type WorkflowResponseSlotForward
 * @export
 */
export type WorkflowResponseSlotForward = WorkflowResponseSlotForwardOneOf | boolean | string;

/**
 *
 * @export
 * @interface WorkflowResponseSlotForwardOneOf
 */
export interface WorkflowResponseSlotForwardOneOf {
  /**
   *
   * @type {string}
   * @memberof WorkflowResponseSlotForwardOneOf
   */
  'to'?: string;
  /**
   *
   * @type {string}
   * @memberof WorkflowResponseSlotForwardOneOf
   */
  'mode'?: WorkflowResponseSlotForwardOneOfModeEnum;
}

export const WorkflowResponseSlotForwardOneOfModeEnum = {
  AfterReply: 'after-reply',
  Immediately: 'immediately'
} as const;

export type WorkflowResponseSlotForwardOneOfModeEnum = typeof WorkflowResponseSlotForwardOneOfModeEnum[keyof typeof WorkflowResponseSlotForwardOneOfModeEnum];

/**
 * @type WorkflowResponseSlotInstructions
 * @export
 */
export type WorkflowResponseSlotInstructions = Array<Instruction> | Array<string> | Instruction | string;


/**
 * CustomContextApi - axios parameter creator
 * @export
 */
export const CustomContextApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Test a custom context before training
     * @param {ContextTestRequest} contextTestRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextTest: async (contextTestRequest: ContextTestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'contextTestRequest' is not null or undefined
      assertParamExists('contextTest', 'contextTestRequest', contextTestRequest)
      const localVarPath = `/v1-contextTest`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(contextTestRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  }
};

/**
 * CustomContextApi - functional programming interface
 * @export
 */
export const CustomContextApiFp = function(configuration?: Configuration) {
  const localVarAxiosParamCreator = CustomContextApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Test a custom context before training
     * @param {ContextTestRequest} contextTestRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contextTest(contextTestRequest: ContextTestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextTestResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contextTest(contextTestRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  }
};

/**
 * CustomContextApi - factory interface
 * @export
 */
export const CustomContextApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = CustomContextApiFp(configuration)
  return {
    /**
     *
     * @summary Test a custom context before training
     * @param {ContextTestRequest} contextTestRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextTest(contextTestRequest: ContextTestRequest, options?: any): AxiosPromise<ContextTestResponse> {
      return localVarFp.contextTest(contextTestRequest, options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * CustomContextApi - object-oriented interface
 * @export
 * @class CustomContextApi
 * @extends {BaseAPI}
 */
export class CustomContextApi extends BaseAPI {
  /**
   *
   * @summary Test a custom context before training
   * @param {ContextTestRequest} contextTestRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CustomContextApi
   */
  public contextTest(contextTestRequest: ContextTestRequest, options?: AxiosRequestConfig) {
    return CustomContextApiFp(this.configuration).contextTest(contextTestRequest, options).then((request) => request(this.axios, this.basePath));
  }
}


/**
 * Scout9Api - axios parameter creator
 * @export
 */
export const Scout9ApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     *
     * @summary Gets a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agent: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('agent', 'id', id)
      const localVarPath = `/v1-agent`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('agentDelete', 'id', id)
      const localVarPath = `/v1-agent`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Registers a new agent
     * @param {CreateAgentRequest} createAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentRegister: async (createAgentRequest: CreateAgentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createAgentRequest' is not null or undefined
      assertParamExists('agentRegister', 'createAgentRequest', createAgentRequest)
      const localVarPath = `/v1-agent`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createAgentRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a agent
     * @param {UpdateAgentRequest} updateAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentUpdate: async (updateAgentRequest: UpdateAgentRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateAgentRequest' is not null or undefined
      assertParamExists('agentUpdate', 'updateAgentRequest', updateAgentRequest)
      const localVarPath = `/v1-agent`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateAgentRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all or specific set of agents
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agents: async (q?: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-agents`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates new agents
     * @param {CreateAgentsRequest} createAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentsCreate: async (createAgentsRequest: CreateAgentsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createAgentsRequest' is not null or undefined
      assertParamExists('agentsCreate', 'createAgentsRequest', createAgentsRequest)
      const localVarPath = `/v1-agents`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createAgentsRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes multiple agents
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentsDelete: async (id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-agents`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates multiple agents
     * @param {UpdateAgentsRequest} updateAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentsUpdate: async (updateAgentsRequest: UpdateAgentsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateAgentsRequest' is not null or undefined
      assertParamExists('agentsUpdate', 'updateAgentsRequest', updateAgentsRequest)
      const localVarPath = `/v1-agents`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateAgentsRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a context. Don\'t use, create your context entities within your Scout9 application.
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    context: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('context', 'id', id)
      const localVarPath = `/v1-context`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a new context. Don\'t use, create your context entities within your Scout9 application.
     * @param {CreateContextRequest} createContextRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    contextCreate: async (createContextRequest: CreateContextRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createContextRequest' is not null or undefined
      assertParamExists('contextCreate', 'createContextRequest', createContextRequest)
      const localVarPath = `/v1-context`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createContextRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets context data
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextData: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('contextData', 'id', id)
      const localVarPath = `/v1-contextDatas`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a new context data
     * @param {CreateContextDataRequest} createContextDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextDataCreate: async (createContextDataRequest: CreateContextDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createContextDataRequest' is not null or undefined
      assertParamExists('contextDataCreate', 'createContextDataRequest', createContextDataRequest)
      const localVarPath = `/v1-contextDatas`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createContextDataRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextDataDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('contextDataDelete', 'id', id)
      const localVarPath = `/v1-contextDatas`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a context data
     * @param {UpdateContextDataRequest} updateContextDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextDataUpdate: async (updateContextDataRequest: UpdateContextDataRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateContextDataRequest' is not null or undefined
      assertParamExists('contextDataUpdate', 'updateContextDataRequest', updateContextDataRequest)
      const localVarPath = `/v1-contextDatas`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateContextDataRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a context entity. Don\'t use, create your context entities within your Scout9 application.
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    contextDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('contextDelete', 'id', id)
      const localVarPath = `/v1-context`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Test a custom context before training
     * @param {ContextTestRequest} contextTestRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextTest: async (contextTestRequest: ContextTestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'contextTestRequest' is not null or undefined
      assertParamExists('contextTest', 'contextTestRequest', contextTestRequest)
      const localVarPath = `/v1-contextTest`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(contextTestRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Update a context. . Don\'t use, create your context entities within your Scout9 application.
     * @summary Update a context
     * @param {UpdateContextRequest} updateContextRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    contextUpdate: async (updateContextRequest: UpdateContextRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateContextRequest' is not null or undefined
      assertParamExists('contextUpdate', 'updateContextRequest', updateContextRequest)
      const localVarPath = `/v1-context`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateContextRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all or specific set of contexts. Don\'t use, create your context entities within your Scout9 application.
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    contexts: async (q?: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-contexts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates new contexts. Don\'t use, create your context entities within your Scout9 application.
     * @param {CreateContextsRequest} createContextsRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    contextsCreate: async (createContextsRequest: CreateContextsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createContextsRequest' is not null or undefined
      assertParamExists('contextsCreate', 'createContextsRequest', createContextsRequest)
      const localVarPath = `/v1-contexts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createContextsRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes multiple contexts. Don\'t use, create your context entities within your Scout9 application.
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    contextsDelete: async (id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-contexts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates multiple contexts. Don\'t use, create your context entities within your Scout9 application.
     * @param {UpdateContextRequest} updateContextRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    contextsUpdate: async (updateContextRequest: UpdateContextRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateContextRequest' is not null or undefined
      assertParamExists('contextsUpdate', 'updateContextRequest', updateContextRequest)
      const localVarPath = `/v1-contexts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateContextRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a conversation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversation: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('conversation', 'id', id)
      const localVarPath = `/v1-conversation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Create a new conversation
     * @param {ConversationCreateRequest} conversationCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationCreate: async (conversationCreateRequest: ConversationCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'conversationCreateRequest' is not null or undefined
      assertParamExists('conversationCreate', 'conversationCreateRequest', conversationCreateRequest)
      const localVarPath = `/v1-conversation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(conversationCreateRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('conversationDelete', 'id', id)
      const localVarPath = `/v1-conversation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Update a conversation
     * @param {ConversationUpdateRequest} conversationUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationUpdate: async (conversationUpdateRequest: ConversationUpdateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'conversationUpdateRequest' is not null or undefined
      assertParamExists('conversationUpdate', 'conversationUpdateRequest', conversationUpdateRequest)
      const localVarPath = `/v1-conversation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(conversationUpdateRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all or specific set of conversations
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversations: async (q?: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-conversations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a customer
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customer: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('customer', 'id', id)
      const localVarPath = `/v1-customer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates a new customer
     * @param {Customer} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerCreate: async (body: Customer, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      assertParamExists('customerCreate', 'body', body)
      const localVarPath = `/v1-customer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a customer
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('customerDelete', 'id', id)
      const localVarPath = `/v1-customer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroup: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('customerGroup', 'id', id)
      const localVarPath = `/v1-customerGroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates a new customer group
     * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupCreate: async (createCustomerGroupRequest: CreateCustomerGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createCustomerGroupRequest' is not null or undefined
      assertParamExists('customerGroupCreate', 'createCustomerGroupRequest', createCustomerGroupRequest)
      const localVarPath = `/v1-customerGroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createCustomerGroupRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupDelete: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('customerGroupDelete', 'id', id)
      const localVarPath = `/v1-customerGroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates a customer group
     * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupUpdate: async (updateCustomerGroupRequest: UpdateCustomerGroupRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateCustomerGroupRequest' is not null or undefined
      assertParamExists('customerGroupUpdate', 'updateCustomerGroupRequest', updateCustomerGroupRequest)
      const localVarPath = `/v1-customerGroup`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerGroupRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all or specific set of customer groups
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroups: async (q?: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-customerGroups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates new customer groups
     * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupsCreate: async (createCustomerGroupsRequest: CreateCustomerGroupsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createCustomerGroupsRequest' is not null or undefined
      assertParamExists('customerGroupsCreate', 'createCustomerGroupsRequest', createCustomerGroupsRequest)
      const localVarPath = `/v1-customerGroups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createCustomerGroupsRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes multiple customer groups
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupsDelete: async (id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-customerGroups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates multiple customer groups
     * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupsUpdate: async (updateCustomerGroupsRequest: UpdateCustomerGroupsRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateCustomerGroupsRequest' is not null or undefined
      assertParamExists('customerGroupsUpdate', 'updateCustomerGroupsRequest', updateCustomerGroupsRequest)
      const localVarPath = `/v1-customerGroups`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerGroupsRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates a customer
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerUpdate: async (updateCustomerRequest: UpdateCustomerRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateCustomerRequest' is not null or undefined
      assertParamExists('customerUpdate', 'updateCustomerRequest', updateCustomerRequest)
      const localVarPath = `/v1-customer`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateCustomerRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all or specific set of customers
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customers: async (q?: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-customers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Creates new customers
     * @param {CreateCustomersRequest} createCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCreate: async (createCustomersRequest: CreateCustomersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'createCustomersRequest' is not null or undefined
      assertParamExists('customersCreate', 'createCustomersRequest', createCustomersRequest)
      const localVarPath = `/v1-customers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(createCustomersRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Deletes multiple customers
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersDelete: async (id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-customers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Updates multiple customers
     * @param {UpdateCustomersRequest} updateCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersUpdate: async (updateCustomersRequest: UpdateCustomersRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'updateCustomersRequest' is not null or undefined
      assertParamExists('customersUpdate', 'updateCustomersRequest', updateCustomersRequest)
      const localVarPath = `/v1-customers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(updateCustomersRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns a file
     * @param {string} purpose File categorical purpose
     * @param {string} [entity] File entity id
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    file: async (purpose: string, entity?: string, agent?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'purpose' is not null or undefined
      assertParamExists('file', 'purpose', purpose)
      const localVarPath = `/v1-utils-file`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (purpose !== undefined) {
        localVarQueryParameter['purpose'] = purpose;
      }

      if (entity !== undefined) {
        localVarQueryParameter['entity'] = entity;
      }

      if (agent !== undefined) {
        localVarQueryParameter['agent'] = agent;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Remove a file
     * @param {string} purpose File categorical purpose
     * @param {string} entity File entity id
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileRemove: async (purpose: string, entity: string, agent?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'purpose' is not null or undefined
      assertParamExists('fileRemove', 'purpose', purpose)
      // verify required parameter 'entity' is not null or undefined
      assertParamExists('fileRemove', 'entity', entity)
      const localVarPath = `/v1-utils-file`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (purpose !== undefined) {
        localVarQueryParameter['purpose'] = purpose;
      }

      if (entity !== undefined) {
        localVarQueryParameter['entity'] = entity;
      }

      if (agent !== undefined) {
        localVarQueryParameter['agent'] = agent;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
     * @param {File} file
     * @param {PurposeEnum} [purpose]
     * @param {string} [entity] The entity id, if not provided the entity id becomes the provided file name
     * @param {string} [$agent] The agent that this file belongs to. Only used for entity.audio and entity.transcript files.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileUpload: async (file: File | Buffer | Blob, purpose?: PurposeEnum, entity?: string, $agent?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'file' is not null or undefined
      assertParamExists('fileUpload', 'file', file)
      const localVarPath = `/v1-utils-file`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();


      if (file !== undefined) {
        localVarFormParams.append('file', file as any);
      }

      if (purpose !== undefined) {
        localVarFormParams.append('purpose', new Blob([JSON.stringify(purpose)], { type: "application/json", }));
      }

      if (entity !== undefined) {
        localVarFormParams.append('entity', entity as any);
      }

      if ($agent !== undefined) {
        localVarFormParams.append('$agent', $agent as any);
      }


      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns a list of files that belong to the user\'s organization.
     * @param {string} purpose File categorical purpose
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    files: async (purpose: string, agent?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'purpose' is not null or undefined
      assertParamExists('files', 'purpose', purpose)
      const localVarPath = `/v1-utils-files`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (purpose !== undefined) {
        localVarQueryParameter['purpose'] = purpose;
      }

      if (agent !== undefined) {
        localVarQueryParameter['agent'] = agent;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Forwards a locked conversation to agent
     * @summary forwards a locked conversation to agent
     * @param {ForwardRequest} forwardRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forward: async (forwardRequest: ForwardRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'forwardRequest' is not null or undefined
      assertParamExists('forward', 'forwardRequest', forwardRequest)
      const localVarPath = `/v1-forward`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(forwardRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
     * @summary Generate a message from conversation
     * @param {GenerateRequest} generateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generate: async (generateRequest: GenerateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'generateRequest' is not null or undefined
      assertParamExists('generate', 'generateRequest', generateRequest)
      const localVarPath = `/v1-generate`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(generateRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
     * @summary Create and send message
     * @param {MessageCreateRequest} messageCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    message: async (messageCreateRequest: MessageCreateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'messageCreateRequest' is not null or undefined
      assertParamExists('message', 'messageCreateRequest', messageCreateRequest)
      const localVarPath = `/v1-messages`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(messageCreateRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get all messages from a conversation
     * @param {string} id id of entity to query
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    messages: async (id: string, q?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('messages', 'id', id)
      const localVarPath = `/v1-messages`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Get the results of a bulk API operation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operation: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'id' is not null or undefined
      assertParamExists('operation', 'id', id)
      const localVarPath = `/v1-utils-operation`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (id !== undefined) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Gets all or specific set of bulk API operations
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operations: async (q?: string, id?: Array<string>, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-utils-operations`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (q !== undefined) {
        localVarQueryParameter['q'] = q;
      }

      if (id) {
        localVarQueryParameter['id'] = id;
      }



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Parses a message\'s custom context relevant to your organization. This is useful for extracting information from a message to drive your auto reply workflows.
     * @summary Parse a message\'s custom context relevant to your organization
     * @param {ParseRequest} parseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parse: async (parseRequest: ParseRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'parseRequest' is not null or undefined
      assertParamExists('parse', 'parseRequest', parseRequest)
      const localVarPath = `/v1-parse`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(parseRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Purchase phone for a given agent.
     * @param {PurchasePhoneRequest} [purchasePhoneRequest] If no agent id is provided, the phone will be purchased for the owner of the API key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchasePhone: async (purchasePhoneRequest?: PurchasePhoneRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-purchases-phone`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(purchasePhoneRequest, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Runs your auto-reply app on the Scout9 platform.
     * @param {WorkflowEvent} workflowEvent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPlatform: async (workflowEvent: WorkflowEvent, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      // verify required parameter 'workflowEvent' is not null or undefined
      assertParamExists('runPlatform', 'workflowEvent', workflowEvent)
      const localVarPath = `/v1-utils-platform-run`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      localVarHeaderParameter['Content-Type'] = 'application/json';

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
      localVarRequestOptions.data = serializeDataIfNeeded(workflowEvent, localVarRequestOptions, configuration)

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     *
     * @summary Returns the platform run config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPlatformConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v1-utils-platform-run`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;



      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  }
};

/**
 * Scout9Api - functional programming interface
 * @export
 */
export const Scout9ApiFp = function(configuration?: Configuration) {
  const localVarAxiosParamCreator = Scout9ApiAxiosParamCreator(configuration)
  return {
    /**
     *
     * @summary Gets a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agent(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAgentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agent(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentDeleteResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agentDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Registers a new agent
     * @param {CreateAgentRequest} createAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentRegister(createAgentRequest: CreateAgentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAgentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agentRegister(createAgentRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update a agent
     * @param {UpdateAgentRequest} updateAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentUpdate(updateAgentRequest: UpdateAgentRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAgentResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agentUpdate(updateAgentRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets all or specific set of agents
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agents(q?: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListAgentsResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agents(q, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates new agents
     * @param {CreateAgentsRequest} createAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentsCreate(createAgentsRequest: CreateAgentsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAgentsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agentsCreate(createAgentsRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes multiple agents
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentsDelete(id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentsDeleteResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agentsDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates multiple agents
     * @param {UpdateAgentsRequest} updateAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async agentsUpdate(updateAgentsRequest: UpdateAgentsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateAgentsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.agentsUpdate(updateAgentsRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a context. Don\'t use, create your context entities within your Scout9 application.
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async context(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContextResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.context(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Create a new context. Don\'t use, create your context entities within your Scout9 application.
     * @param {CreateContextRequest} createContextRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async contextCreate(createContextRequest: CreateContextRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateContextResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contextCreate(createContextRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets context data
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contextData(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetContextDataResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contextData(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Create a new context data
     * @param {CreateContextDataRequest} createContextDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contextDataCreate(createContextDataRequest: CreateContextDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateContextDataResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contextDataCreate(createContextDataRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contextDataDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteContextDataResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contextDataDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update a context data
     * @param {UpdateContextDataRequest} updateContextDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contextDataUpdate(updateContextDataRequest: UpdateContextDataRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateContextDataResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contextDataUpdate(updateContextDataRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes a context entity. Don\'t use, create your context entities within your Scout9 application.
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async contextDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteContextResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contextDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Test a custom context before training
     * @param {ContextTestRequest} contextTestRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async contextTest(contextTestRequest: ContextTestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ContextTestResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contextTest(contextTestRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Update a context. . Don\'t use, create your context entities within your Scout9 application.
     * @summary Update a context
     * @param {UpdateContextRequest} updateContextRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async contextUpdate(updateContextRequest: UpdateContextRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateContextResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contextUpdate(updateContextRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets all or specific set of contexts. Don\'t use, create your context entities within your Scout9 application.
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async contexts(q?: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListContextsResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contexts(q, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates new contexts. Don\'t use, create your context entities within your Scout9 application.
     * @param {CreateContextsRequest} createContextsRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async contextsCreate(createContextsRequest: CreateContextsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateContextsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contextsCreate(createContextsRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes multiple contexts. Don\'t use, create your context entities within your Scout9 application.
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async contextsDelete(id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteContextsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contextsDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates multiple contexts. Don\'t use, create your context entities within your Scout9 application.
     * @param {UpdateContextRequest} updateContextRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    async contextsUpdate(updateContextRequest: UpdateContextRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateContextsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.contextsUpdate(updateContextRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a conversation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async conversation(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationGetResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.conversation(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Create a new conversation
     * @param {ConversationCreateRequest} conversationCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async conversationCreate(conversationCreateRequest: ConversationCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationCreateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.conversationCreate(conversationCreateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async conversationDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationRemoveResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.conversationDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Update a conversation
     * @param {ConversationUpdateRequest} conversationUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async conversationUpdate(conversationUpdateRequest: ConversationUpdateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ConversationUpdateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.conversationUpdate(conversationUpdateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets all or specific set of conversations
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async conversations(q?: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListConversationsResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.conversations(q, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a customer
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customer(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomerResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customer(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates a new customer
     * @param {Customer} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerCreate(body: Customer, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerCreateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerCreate(body, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes a customer
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerDeleteResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroup(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCustomerGroupResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroup(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates a new customer group
     * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroupCreate(createCustomerGroupRequest: CreateCustomerGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomerGroupResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupCreate(createCustomerGroupRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroupDelete(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCustomerGroupResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates a customer group
     * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroupUpdate(updateCustomerGroupRequest: UpdateCustomerGroupRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCustomerGroupResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupUpdate(updateCustomerGroupRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets all or specific set of customer groups
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroups(q?: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListCustomerGroupsResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroups(q, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates new customer groups
     * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroupsCreate(createCustomerGroupsRequest: CreateCustomerGroupsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomerGroupsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupsCreate(createCustomerGroupsRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes multiple customer groups
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroupsDelete(id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCustomerGroupsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupsDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates multiple customer groups
     * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerGroupsUpdate(updateCustomerGroupsRequest: UpdateCustomerGroupsRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCustomerGroupsResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupsUpdate(updateCustomerGroupsRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates a customer
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customerUpdate(updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerUpdateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customerUpdate(updateCustomerRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets all or specific set of customers
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customers(q?: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListCustomersResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customers(q, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Creates new customers
     * @param {CreateCustomersRequest} createCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customersCreate(createCustomersRequest: CreateCustomersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateCustomersResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customersCreate(createCustomersRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Deletes multiple customers
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customersDelete(id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeleteCustomersResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customersDelete(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Updates multiple customers
     * @param {UpdateCustomersRequest} updateCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async customersUpdate(updateCustomersRequest: UpdateCustomersRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateCustomersResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.customersUpdate(updateCustomersRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Returns a file
     * @param {string} purpose File categorical purpose
     * @param {string} [entity] File entity id
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async file(purpose: string, entity?: string, agent?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.file(purpose, entity, agent, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Remove a file
     * @param {string} purpose File categorical purpose
     * @param {string} entity File entity id
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fileRemove(purpose: string, entity: string, agent?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OperationDocResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.fileRemove(purpose, entity, agent, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
     * @param {File} file
     * @param {PurposeEnum} [purpose]
     * @param {string} [entity] The entity id, if not provided the entity id becomes the provided file name
     * @param {string} [$agent] The agent that this file belongs to. Only used for entity.audio and entity.transcript files.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async fileUpload(file: File | Buffer | Blob, purpose?: PurposeEnum, entity?: string, $agent?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Scout9File>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.fileUpload(file, purpose, entity, $agent, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Returns a list of files that belong to the user\'s organization.
     * @param {string} purpose File categorical purpose
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async files(purpose: string, agent?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListFilesResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.files(purpose, agent, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Forwards a locked conversation to agent
     * @summary forwards a locked conversation to agent
     * @param {ForwardRequest} forwardRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async forward(forwardRequest: ForwardRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ForwardResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.forward(forwardRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
     * @summary Generate a message from conversation
     * @param {GenerateRequest} generateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async generate(generateRequest: GenerateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GenerateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.generate(generateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
     * @summary Create and send message
     * @param {MessageCreateRequest} messageCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async message(messageCreateRequest: MessageCreateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MessageCreateResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.message(messageCreateRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get all messages from a conversation
     * @param {string} id id of entity to query
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async messages(id: string, q?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<MessageGetResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.messages(id, q, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Get the results of a bulk API operation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async operation(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetApiOperationResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.operation(id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Gets all or specific set of bulk API operations
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async operations(q?: string, id?: Array<string>, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ListApiOperationsResponseInner>>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.operations(q, id, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Parses a message\'s custom context relevant to your organization. This is useful for extracting information from a message to drive your auto reply workflows.
     * @summary Parse a message\'s custom context relevant to your organization
     * @param {ParseRequest} parseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async parse(parseRequest: ParseRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ParseResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.parse(parseRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Purchase phone for a given agent.
     * @param {PurchasePhoneRequest} [purchasePhoneRequest] If no agent id is provided, the phone will be purchased for the owner of the API key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async purchasePhone(purchasePhoneRequest?: PurchasePhoneRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PurchasePhoneResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.purchasePhone(purchasePhoneRequest, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Runs your auto-reply app on the Scout9 platform.
     * @param {WorkflowEvent} workflowEvent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPlatform(workflowEvent: WorkflowEvent, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<WorkflowResponse>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPlatform(workflowEvent, options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     *
     * @summary Returns the platform run config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async runPlatformConfig(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.runPlatformConfig(options);
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  }
};

/**
 * Scout9Api - factory interface
 * @export
 */
export const Scout9ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = Scout9ApiFp(configuration)
  return {
    /**
     *
     * @summary Gets a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agent(id: string, options?: any): AxiosPromise<GetAgentResponse> {
      return localVarFp.agent(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentDelete(id: string, options?: any): AxiosPromise<AgentDeleteResponse> {
      return localVarFp.agentDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Registers a new agent
     * @param {CreateAgentRequest} createAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentRegister(createAgentRequest: CreateAgentRequest, options?: any): AxiosPromise<CreateAgentResponse> {
      return localVarFp.agentRegister(createAgentRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a agent
     * @param {UpdateAgentRequest} updateAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentUpdate(updateAgentRequest: UpdateAgentRequest, options?: any): AxiosPromise<UpdateAgentResponse> {
      return localVarFp.agentUpdate(updateAgentRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all or specific set of agents
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agents(q?: string, id?: Array<string>, options?: any): AxiosPromise<Array<ListAgentsResponseInner>> {
      return localVarFp.agents(q, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates new agents
     * @param {CreateAgentsRequest} createAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentsCreate(createAgentsRequest: CreateAgentsRequest, options?: any): AxiosPromise<CreateAgentsResponse> {
      return localVarFp.agentsCreate(createAgentsRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes multiple agents
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentsDelete(id?: Array<string>, options?: any): AxiosPromise<AgentsDeleteResponse> {
      return localVarFp.agentsDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates multiple agents
     * @param {UpdateAgentsRequest} updateAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    agentsUpdate(updateAgentsRequest: UpdateAgentsRequest, options?: any): AxiosPromise<UpdateAgentsResponse> {
      return localVarFp.agentsUpdate(updateAgentsRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a context. Don\'t use, create your context entities within your Scout9 application.
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    context(id: string, options?: any): AxiosPromise<GetContextResponse> {
      return localVarFp.context(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a new context. Don\'t use, create your context entities within your Scout9 application.
     * @param {CreateContextRequest} createContextRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    contextCreate(createContextRequest: CreateContextRequest, options?: any): AxiosPromise<CreateContextResponse> {
      return localVarFp.contextCreate(createContextRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets context data
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextData(id: string, options?: any): AxiosPromise<GetContextDataResponse> {
      return localVarFp.contextData(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a new context data
     * @param {CreateContextDataRequest} createContextDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextDataCreate(createContextDataRequest: CreateContextDataRequest, options?: any): AxiosPromise<CreateContextDataResponse> {
      return localVarFp.contextDataCreate(createContextDataRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextDataDelete(id: string, options?: any): AxiosPromise<DeleteContextDataResponse> {
      return localVarFp.contextDataDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a context data
     * @param {UpdateContextDataRequest} updateContextDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextDataUpdate(updateContextDataRequest: UpdateContextDataRequest, options?: any): AxiosPromise<UpdateContextDataResponse> {
      return localVarFp.contextDataUpdate(updateContextDataRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes a context entity. Don\'t use, create your context entities within your Scout9 application.
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    contextDelete(id: string, options?: any): AxiosPromise<DeleteContextResponse> {
      return localVarFp.contextDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Test a custom context before training
     * @param {ContextTestRequest} contextTestRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    contextTest(contextTestRequest: ContextTestRequest, options?: any): AxiosPromise<ContextTestResponse> {
      return localVarFp.contextTest(contextTestRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Update a context. . Don\'t use, create your context entities within your Scout9 application.
     * @summary Update a context
     * @param {UpdateContextRequest} updateContextRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    contextUpdate(updateContextRequest: UpdateContextRequest, options?: any): AxiosPromise<UpdateContextResponse> {
      return localVarFp.contextUpdate(updateContextRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all or specific set of contexts. Don\'t use, create your context entities within your Scout9 application.
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    contexts(q?: string, id?: Array<string>, options?: any): AxiosPromise<Array<ListContextsResponseInner>> {
      return localVarFp.contexts(q, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates new contexts. Don\'t use, create your context entities within your Scout9 application.
     * @param {CreateContextsRequest} createContextsRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    contextsCreate(createContextsRequest: CreateContextsRequest, options?: any): AxiosPromise<CreateContextsResponse> {
      return localVarFp.contextsCreate(createContextsRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes multiple contexts. Don\'t use, create your context entities within your Scout9 application.
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    contextsDelete(id?: Array<string>, options?: any): AxiosPromise<DeleteContextsResponse> {
      return localVarFp.contextsDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates multiple contexts. Don\'t use, create your context entities within your Scout9 application.
     * @param {UpdateContextRequest} updateContextRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     */
    contextsUpdate(updateContextRequest: UpdateContextRequest, options?: any): AxiosPromise<UpdateContextsResponse> {
      return localVarFp.contextsUpdate(updateContextRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a conversation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversation(id: string, options?: any): AxiosPromise<ConversationGetResponse> {
      return localVarFp.conversation(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Create a new conversation
     * @param {ConversationCreateRequest} conversationCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationCreate(conversationCreateRequest: ConversationCreateRequest, options?: any): AxiosPromise<ConversationCreateResponse> {
      return localVarFp.conversationCreate(conversationCreateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationDelete(id: string, options?: any): AxiosPromise<ConversationRemoveResponse> {
      return localVarFp.conversationDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Update a conversation
     * @param {ConversationUpdateRequest} conversationUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversationUpdate(conversationUpdateRequest: ConversationUpdateRequest, options?: any): AxiosPromise<ConversationUpdateResponse> {
      return localVarFp.conversationUpdate(conversationUpdateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all or specific set of conversations
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    conversations(q?: string, id?: Array<string>, options?: any): AxiosPromise<Array<ListConversationsResponseInner>> {
      return localVarFp.conversations(q, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a customer
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customer(id: string, options?: any): AxiosPromise<GetCustomerResponse> {
      return localVarFp.customer(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates a new customer
     * @param {Customer} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerCreate(body: Customer, options?: any): AxiosPromise<CustomerCreateResponse> {
      return localVarFp.customerCreate(body, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes a customer
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerDelete(id: string, options?: any): AxiosPromise<CustomerDeleteResponse> {
      return localVarFp.customerDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroup(id: string, options?: any): AxiosPromise<GetCustomerGroupResponse> {
      return localVarFp.customerGroup(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates a new customer group
     * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupCreate(createCustomerGroupRequest: CreateCustomerGroupRequest, options?: any): AxiosPromise<CreateCustomerGroupResponse> {
      return localVarFp.customerGroupCreate(createCustomerGroupRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupDelete(id: string, options?: any): AxiosPromise<DeleteCustomerGroupResponse> {
      return localVarFp.customerGroupDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates a customer group
     * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupUpdate(updateCustomerGroupRequest: UpdateCustomerGroupRequest, options?: any): AxiosPromise<UpdateCustomerGroupResponse> {
      return localVarFp.customerGroupUpdate(updateCustomerGroupRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all or specific set of customer groups
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroups(q?: string, id?: Array<string>, options?: any): AxiosPromise<Array<ListCustomerGroupsResponseInner>> {
      return localVarFp.customerGroups(q, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates new customer groups
     * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupsCreate(createCustomerGroupsRequest: CreateCustomerGroupsRequest, options?: any): AxiosPromise<CreateCustomerGroupsResponse> {
      return localVarFp.customerGroupsCreate(createCustomerGroupsRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes multiple customer groups
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupsDelete(id?: Array<string>, options?: any): AxiosPromise<DeleteCustomerGroupsResponse> {
      return localVarFp.customerGroupsDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates multiple customer groups
     * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerGroupsUpdate(updateCustomerGroupsRequest: UpdateCustomerGroupsRequest, options?: any): AxiosPromise<UpdateCustomerGroupsResponse> {
      return localVarFp.customerGroupsUpdate(updateCustomerGroupsRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates a customer
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customerUpdate(updateCustomerRequest: UpdateCustomerRequest, options?: any): AxiosPromise<CustomerUpdateResponse> {
      return localVarFp.customerUpdate(updateCustomerRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all or specific set of customers
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customers(q?: string, id?: Array<string>, options?: any): AxiosPromise<Array<ListCustomersResponseInner>> {
      return localVarFp.customers(q, id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Creates new customers
     * @param {CreateCustomersRequest} createCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersCreate(createCustomersRequest: CreateCustomersRequest, options?: any): AxiosPromise<CreateCustomersResponse> {
      return localVarFp.customersCreate(createCustomersRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Deletes multiple customers
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersDelete(id?: Array<string>, options?: any): AxiosPromise<DeleteCustomersResponse> {
      return localVarFp.customersDelete(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Updates multiple customers
     * @param {UpdateCustomersRequest} updateCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    customersUpdate(updateCustomersRequest: UpdateCustomersRequest, options?: any): AxiosPromise<UpdateCustomersResponse> {
      return localVarFp.customersUpdate(updateCustomersRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns a file
     * @param {string} purpose File categorical purpose
     * @param {string} [entity] File entity id
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    file(purpose: string, entity?: string, agent?: string, options?: any): AxiosPromise<File> {
      return localVarFp.file(purpose, entity, agent, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Remove a file
     * @param {string} purpose File categorical purpose
     * @param {string} entity File entity id
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileRemove(purpose: string, entity: string, agent?: string, options?: any): AxiosPromise<OperationDocResponse> {
      return localVarFp.fileRemove(purpose, entity, agent, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
     * @param {File} file
     * @param {PurposeEnum} [purpose]
     * @param {string} [entity] The entity id, if not provided the entity id becomes the provided file name
     * @param {string} [$agent] The agent that this file belongs to. Only used for entity.audio and entity.transcript files.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    fileUpload(file: File | Buffer | Blob, purpose?: PurposeEnum, entity?: string, $agent?: string, options?: any): AxiosPromise<Scout9File> {
      return localVarFp.fileUpload(file, purpose, entity, $agent, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns a list of files that belong to the user\'s organization.
     * @param {string} purpose File categorical purpose
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    files(purpose: string, agent?: string, options?: any): AxiosPromise<Array<ListFilesResponseInner>> {
      return localVarFp.files(purpose, agent, options).then((request) => request(axios, basePath));
    },
    /**
     * Forwards a locked conversation to agent
     * @summary forwards a locked conversation to agent
     * @param {ForwardRequest} forwardRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    forward(forwardRequest: ForwardRequest, options?: any): AxiosPromise<ForwardResponse> {
      return localVarFp.forward(forwardRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
     * @summary Generate a message from conversation
     * @param {GenerateRequest} generateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    generate(generateRequest: GenerateRequest, options?: any): AxiosPromise<GenerateResponse> {
      return localVarFp.generate(generateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
     * @summary Create and send message
     * @param {MessageCreateRequest} messageCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    message(messageCreateRequest: MessageCreateRequest, options?: any): AxiosPromise<MessageCreateResponse> {
      return localVarFp.message(messageCreateRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get all messages from a conversation
     * @param {string} id id of entity to query
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    messages(id: string, q?: string, options?: any): AxiosPromise<Array<MessageGetResponseInner>> {
      return localVarFp.messages(id, q, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Get the results of a bulk API operation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operation(id: string, options?: any): AxiosPromise<GetApiOperationResponse> {
      return localVarFp.operation(id, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Gets all or specific set of bulk API operations
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    operations(q?: string, id?: Array<string>, options?: any): AxiosPromise<Array<ListApiOperationsResponseInner>> {
      return localVarFp.operations(q, id, options).then((request) => request(axios, basePath));
    },
    /**
     * Parses a message\'s custom context relevant to your organization. This is useful for extracting information from a message to drive your auto reply workflows.
     * @summary Parse a message\'s custom context relevant to your organization
     * @param {ParseRequest} parseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    parse(parseRequest: ParseRequest, options?: any): AxiosPromise<ParseResponse> {
      return localVarFp.parse(parseRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Purchase phone for a given agent.
     * @param {PurchasePhoneRequest} [purchasePhoneRequest] If no agent id is provided, the phone will be purchased for the owner of the API key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    purchasePhone(purchasePhoneRequest?: PurchasePhoneRequest, options?: any): AxiosPromise<PurchasePhoneResponse> {
      return localVarFp.purchasePhone(purchasePhoneRequest, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Runs your auto-reply app on the Scout9 platform.
     * @param {WorkflowEvent} workflowEvent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPlatform(workflowEvent: WorkflowEvent, options?: any): AxiosPromise<WorkflowResponse> {
      return localVarFp.runPlatform(workflowEvent, options).then((request) => request(axios, basePath));
    },
    /**
     *
     * @summary Returns the platform run config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    runPlatformConfig(options?: any): AxiosPromise<{ [key: string]: any; }> {
      return localVarFp.runPlatformConfig(options).then((request) => request(axios, basePath));
    },
  };
};

/**
 * Scout9Api - object-oriented interface
 * @export
 * @class Scout9Api
 * @extends {BaseAPI}
 */
export class Scout9Api extends BaseAPI {
  /**
   *
   * @summary Gets a agent
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agent(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agent(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes a agent
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agentDelete(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agentDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Registers a new agent
   * @param {CreateAgentRequest} createAgentRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agentRegister(createAgentRequest: CreateAgentRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agentRegister(createAgentRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a agent
   * @param {UpdateAgentRequest} updateAgentRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agentUpdate(updateAgentRequest: UpdateAgentRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agentUpdate(updateAgentRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets all or specific set of agents
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agents(q?: string, id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agents(q, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates new agents
   * @param {CreateAgentsRequest} createAgentsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agentsCreate(createAgentsRequest: CreateAgentsRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agentsCreate(createAgentsRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes multiple agents
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agentsDelete(id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agentsDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates multiple agents
   * @param {UpdateAgentsRequest} updateAgentsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public agentsUpdate(updateAgentsRequest: UpdateAgentsRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).agentsUpdate(updateAgentsRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a context. Don\'t use, create your context entities within your Scout9 application.
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public context(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).context(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a new context. Don\'t use, create your context entities within your Scout9 application.
   * @param {CreateContextRequest} createContextRequest
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contextCreate(createContextRequest: CreateContextRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contextCreate(createContextRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets context data
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contextData(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contextData(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a new context data
   * @param {CreateContextDataRequest} createContextDataRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contextDataCreate(createContextDataRequest: CreateContextDataRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contextDataCreate(createContextDataRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes a schedule
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contextDataDelete(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contextDataDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a context data
   * @param {UpdateContextDataRequest} updateContextDataRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contextDataUpdate(updateContextDataRequest: UpdateContextDataRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contextDataUpdate(updateContextDataRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes a context entity. Don\'t use, create your context entities within your Scout9 application.
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contextDelete(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contextDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Test a custom context before training
   * @param {ContextTestRequest} contextTestRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contextTest(contextTestRequest: ContextTestRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contextTest(contextTestRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Update a context. . Don\'t use, create your context entities within your Scout9 application.
   * @summary Update a context
   * @param {UpdateContextRequest} updateContextRequest
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contextUpdate(updateContextRequest: UpdateContextRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contextUpdate(updateContextRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets all or specific set of contexts. Don\'t use, create your context entities within your Scout9 application.
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contexts(q?: string, id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contexts(q, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates new contexts. Don\'t use, create your context entities within your Scout9 application.
   * @param {CreateContextsRequest} createContextsRequest
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contextsCreate(createContextsRequest: CreateContextsRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contextsCreate(createContextsRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes multiple contexts. Don\'t use, create your context entities within your Scout9 application.
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contextsDelete(id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contextsDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates multiple contexts. Don\'t use, create your context entities within your Scout9 application.
   * @param {UpdateContextRequest} updateContextRequest
   * @param {*} [options] Override http request option.
   * @deprecated
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public contextsUpdate(updateContextRequest: UpdateContextRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).contextsUpdate(updateContextRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a conversation
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public conversation(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).conversation(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Create a new conversation
   * @param {ConversationCreateRequest} conversationCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public conversationCreate(conversationCreateRequest: ConversationCreateRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).conversationCreate(conversationCreateRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes a schedule
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public conversationDelete(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).conversationDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Update a conversation
   * @param {ConversationUpdateRequest} conversationUpdateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public conversationUpdate(conversationUpdateRequest: ConversationUpdateRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).conversationUpdate(conversationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets all or specific set of conversations
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public conversations(q?: string, id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).conversations(q, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a customer
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customer(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customer(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates a new customer
   * @param {Customer} body
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerCreate(body: Customer, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerCreate(body, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes a customer
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerDelete(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets a customer group
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroup(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroup(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates a new customer group
   * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroupCreate(createCustomerGroupRequest: CreateCustomerGroupRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroupCreate(createCustomerGroupRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes a customer group
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroupDelete(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroupDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates a customer group
   * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroupUpdate(updateCustomerGroupRequest: UpdateCustomerGroupRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroupUpdate(updateCustomerGroupRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets all or specific set of customer groups
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroups(q?: string, id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroups(q, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates new customer groups
   * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroupsCreate(createCustomerGroupsRequest: CreateCustomerGroupsRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroupsCreate(createCustomerGroupsRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes multiple customer groups
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroupsDelete(id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroupsDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates multiple customer groups
   * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerGroupsUpdate(updateCustomerGroupsRequest: UpdateCustomerGroupsRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerGroupsUpdate(updateCustomerGroupsRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates a customer
   * @param {UpdateCustomerRequest} updateCustomerRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customerUpdate(updateCustomerRequest: UpdateCustomerRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customerUpdate(updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets all or specific set of customers
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customers(q?: string, id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customers(q, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Creates new customers
   * @param {CreateCustomersRequest} createCustomersRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customersCreate(createCustomersRequest: CreateCustomersRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customersCreate(createCustomersRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Deletes multiple customers
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customersDelete(id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customersDelete(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Updates multiple customers
   * @param {UpdateCustomersRequest} updateCustomersRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public customersUpdate(updateCustomersRequest: UpdateCustomersRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).customersUpdate(updateCustomersRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Returns a file
   * @param {string} purpose File categorical purpose
   * @param {string} [entity] File entity id
   * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public file(purpose: string, entity?: string, agent?: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).file(purpose, entity, agent, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Remove a file
   * @param {string} purpose File categorical purpose
   * @param {string} entity File entity id
   * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public fileRemove(purpose: string, entity: string, agent?: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).fileRemove(purpose, entity, agent, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
   * @param {File} file
   * @param {PurposeEnum} [purpose]
   * @param {string} [entity] The entity id, if not provided the entity id becomes the provided file name
   * @param {string} [$agent] The agent that this file belongs to. Only used for entity.audio and entity.transcript files.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public fileUpload(file: File | Buffer | Blob, purpose?: PurposeEnum, entity?: string, $agent?: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).fileUpload(file, purpose, entity, $agent, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Returns a list of files that belong to the user\'s organization.
   * @param {string} purpose File categorical purpose
   * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public files(purpose: string, agent?: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).files(purpose, agent, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Forwards a locked conversation to agent
   * @summary forwards a locked conversation to agent
   * @param {ForwardRequest} forwardRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public forward(forwardRequest: ForwardRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).forward(forwardRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
   * @summary Generate a message from conversation
   * @param {GenerateRequest} generateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public generate(generateRequest: GenerateRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).generate(generateRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
   * @summary Create and send message
   * @param {MessageCreateRequest} messageCreateRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public message(messageCreateRequest: MessageCreateRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).message(messageCreateRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get all messages from a conversation
   * @param {string} id id of entity to query
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public messages(id: string, q?: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).messages(id, q, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Get the results of a bulk API operation
   * @param {string} id id of entity to query
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public operation(id: string, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).operation(id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Gets all or specific set of bulk API operations
   * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
   * @param {Array<string>} [id] ids for the entities this id belongs to
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public operations(q?: string, id?: Array<string>, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).operations(q, id, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   * Parses a message\'s custom context relevant to your organization. This is useful for extracting information from a message to drive your auto reply workflows.
   * @summary Parse a message\'s custom context relevant to your organization
   * @param {ParseRequest} parseRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public parse(parseRequest: ParseRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).parse(parseRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Purchase phone for a given agent.
   * @param {PurchasePhoneRequest} [purchasePhoneRequest] If no agent id is provided, the phone will be purchased for the owner of the API key.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public purchasePhone(purchasePhoneRequest?: PurchasePhoneRequest, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).purchasePhone(purchasePhoneRequest, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Runs your auto-reply app on the Scout9 platform.
   * @param {WorkflowEvent} workflowEvent
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public runPlatform(workflowEvent: WorkflowEvent, options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).runPlatform(workflowEvent, options).then((request) => request(this.axios, this.basePath));
  }

  /**
   *
   * @summary Returns the platform run config
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof Scout9Api
   */
  public runPlatformConfig(options?: AxiosRequestConfig) {
    return Scout9ApiFp(this.configuration).runPlatformConfig(options).then((request) => request(this.axios, this.basePath));
  }
}


