"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Scout9 API
 * Scout9 APIs for managing Scout9 users and conversations with your Scout9 agents
 *
 * The version of the OpenAPI document: 1.0.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scout9Api = exports.Scout9ApiFactory = exports.Scout9ApiFp = exports.Scout9ApiAxiosParamCreator = exports.CustomContextApi = exports.CustomContextApiFactory = exports.CustomContextApiFp = exports.CustomContextApiAxiosParamCreator = exports.UpdateAgentsRequestAgentsInnerModelEnum = exports.UpdateAgentRequestModelEnum = exports.MessageGetResponseInnerRoleEnum = exports.MessageCreateRequestRoleEnum = exports.MessageBaseRoleEnum = exports.MessageRoleEnum = exports.ListApiOperationsResponseInnerMethodEnum = exports.ListAgentsResponseInnerModelEnum = exports.GetApiOperationResponseMethodEnum = exports.GetAgentResponseModelEnum = exports.GenerateResponseRoleEnum = exports.ExistenceOperator = exports.EqualityOperator = exports.CreateAgentsRequestAgentsInnerModelEnum = exports.CreateAgentRequestModelEnum = exports.ConversationEnvironment = exports.ConversationContextFieldConditionOperatorEnum = exports.ApiOperationMethodEnum = exports.AgentModelEnum = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
exports.AgentModelEnum = {
    Scout9: 'Scout9',
    Bard: 'bard',
    Null: 'null'
};
exports.ApiOperationMethodEnum = {
    Get: 'get',
    Post: 'post',
    Put: 'put',
    Delete: 'delete',
    Patch: 'patch'
};
exports.ConversationContextFieldConditionOperatorEnum = {
    Eq: 'eq',
    Equal: 'equal',
    Ne: 'ne',
    NotEquals: 'not-equals',
    Gt: 'gt',
    GreaterThan: 'greater-than',
    Gte: 'gte',
    GreaterThanEquals: 'greater-than-equals',
    Lt: 'lt',
    LessThan: 'less-than',
    Lte: 'lte',
    LessThanEquals: 'less-than-equals',
    ArrayContains: 'array-contains',
    In: 'in',
    ArrayContainsAny: 'array-contains-any',
    NotIn: 'not-in',
    Exists: 'exists',
    NotExists: 'notExists',
    Contains: 'contains',
    NotContains: 'notContains',
    StartsWith: 'startsWith',
    EndsWith: 'endsWith'
};
/**
 * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
 * @export
 * @enum {string}
 */
exports.ConversationEnvironment = {
    Phone: 'phone',
    Web: 'web',
    Email: 'email'
};
exports.CreateAgentRequestModelEnum = {
    Scout9: 'Scout9',
    Bard: 'bard',
    Null: 'null'
};
exports.CreateAgentsRequestAgentsInnerModelEnum = {
    Scout9: 'Scout9',
    Bard: 'bard',
    Null: 'null'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.EqualityOperator = {
    Eq: 'eq',
    Neq: 'neq',
    Gt: 'gt',
    Gte: 'gte',
    Lt: 'lt',
    Lte: 'lte',
    In: 'in',
    Nin: 'nin',
    Contains: 'contains',
    NotContains: 'notContains',
    StartsWith: 'startsWith',
    EndsWith: 'endsWith',
    ArrayContainsAny: 'arrayContainsAny',
    ArrayContains: 'arrayContains'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ExistenceOperator = {
    Exists: 'exists',
    NotExists: 'notExists'
};
exports.GenerateResponseRoleEnum = {
    Customer: 'customer',
    Agent: 'agent',
    Context: 'context'
};
exports.GetAgentResponseModelEnum = {
    Scout9: 'Scout9',
    Bard: 'bard',
    Null: 'null'
};
exports.GetApiOperationResponseMethodEnum = {
    Get: 'get',
    Post: 'post',
    Put: 'put',
    Delete: 'delete',
    Patch: 'patch'
};
exports.ListAgentsResponseInnerModelEnum = {
    Scout9: 'Scout9',
    Bard: 'bard',
    Null: 'null'
};
exports.ListApiOperationsResponseInnerMethodEnum = {
    Get: 'get',
    Post: 'post',
    Put: 'put',
    Delete: 'delete',
    Patch: 'patch'
};
exports.MessageRoleEnum = {
    Customer: 'customer',
    Agent: 'agent',
    Context: 'context'
};
exports.MessageBaseRoleEnum = {
    Customer: 'customer',
    Agent: 'agent',
    Context: 'context'
};
exports.MessageCreateRequestRoleEnum = {
    Agent: 'agent',
    Customer: 'customer',
    Context: 'context'
};
exports.MessageGetResponseInnerRoleEnum = {
    Customer: 'customer',
    Agent: 'agent',
    Context: 'context'
};
exports.UpdateAgentRequestModelEnum = {
    Scout9: 'Scout9',
    Bard: 'bard',
    Null: 'null'
};
exports.UpdateAgentsRequestAgentsInnerModelEnum = {
    Scout9: 'Scout9',
    Bard: 'bard',
    Null: 'null'
};
/**
 * CustomContextApi - axios parameter creator
 * @export
 */
const CustomContextApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Test a custom context before training
         * @param {ContextTestRequest} contextTestRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextTest: async (contextTestRequest, options = {}) => {
            // verify required parameter 'contextTestRequest' is not null or undefined
            (0, common_1.assertParamExists)('contextTest', 'contextTestRequest', contextTestRequest);
            const localVarPath = `/v1-contextTest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(contextTestRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.CustomContextApiAxiosParamCreator = CustomContextApiAxiosParamCreator;
/**
 * CustomContextApi - functional programming interface
 * @export
 */
const CustomContextApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CustomContextApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Test a custom context before training
         * @param {ContextTestRequest} contextTestRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextTest(contextTestRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextTest(contextTestRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.CustomContextApiFp = CustomContextApiFp;
/**
 * CustomContextApi - factory interface
 * @export
 */
const CustomContextApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CustomContextApiFp)(configuration);
    return {
        /**
         *
         * @summary Test a custom context before training
         * @param {ContextTestRequest} contextTestRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextTest(contextTestRequest, options) {
            return localVarFp.contextTest(contextTestRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CustomContextApiFactory = CustomContextApiFactory;
/**
 * CustomContextApi - object-oriented interface
 * @export
 * @class CustomContextApi
 * @extends {BaseAPI}
 */
class CustomContextApi extends base_1.BaseAPI {
    /**
     *
     * @summary Test a custom context before training
     * @param {ContextTestRequest} contextTestRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomContextApi
     */
    contextTest(contextTestRequest, options) {
        return (0, exports.CustomContextApiFp)(this.configuration).contextTest(contextTestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CustomContextApi = CustomContextApi;
/**
 * Scout9Api - axios parameter creator
 * @export
 */
const Scout9ApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Gets a agent
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agent: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('agent', 'id', id);
            const localVarPath = `/v1-agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a agent
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentDelete: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('agentDelete', 'id', id);
            const localVarPath = `/v1-agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Registers a new agent
         * @param {CreateAgentRequest} createAgentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentRegister: async (createAgentRequest, options = {}) => {
            // verify required parameter 'createAgentRequest' is not null or undefined
            (0, common_1.assertParamExists)('agentRegister', 'createAgentRequest', createAgentRequest);
            const localVarPath = `/v1-agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createAgentRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a agent
         * @param {UpdateAgentRequest} updateAgentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentUpdate: async (updateAgentRequest, options = {}) => {
            // verify required parameter 'updateAgentRequest' is not null or undefined
            (0, common_1.assertParamExists)('agentUpdate', 'updateAgentRequest', updateAgentRequest);
            const localVarPath = `/v1-agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateAgentRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all or specific set of agents
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agents: async (q, id, options = {}) => {
            const localVarPath = `/v1-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates new agents
         * @param {CreateAgentsRequest} createAgentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsCreate: async (createAgentsRequest, options = {}) => {
            // verify required parameter 'createAgentsRequest' is not null or undefined
            (0, common_1.assertParamExists)('agentsCreate', 'createAgentsRequest', createAgentsRequest);
            const localVarPath = `/v1-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createAgentsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes multiple agents
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsDelete: async (id, options = {}) => {
            const localVarPath = `/v1-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates multiple agents
         * @param {UpdateAgentsRequest} updateAgentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsUpdate: async (updateAgentsRequest, options = {}) => {
            // verify required parameter 'updateAgentsRequest' is not null or undefined
            (0, common_1.assertParamExists)('agentsUpdate', 'updateAgentsRequest', updateAgentsRequest);
            const localVarPath = `/v1-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateAgentsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a context
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        context: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('context', 'id', id);
            const localVarPath = `/v1-context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a new context
         * @param {CreateContextRequest} createContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextCreate: async (createContextRequest, options = {}) => {
            // verify required parameter 'createContextRequest' is not null or undefined
            (0, common_1.assertParamExists)('contextCreate', 'createContextRequest', createContextRequest);
            const localVarPath = `/v1-context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createContextRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets context data
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextData: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('contextData', 'id', id);
            const localVarPath = `/v1-contextDatas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a new context data
         * @param {CreateContextDataRequest} createContextDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDataCreate: async (createContextDataRequest, options = {}) => {
            // verify required parameter 'createContextDataRequest' is not null or undefined
            (0, common_1.assertParamExists)('contextDataCreate', 'createContextDataRequest', createContextDataRequest);
            const localVarPath = `/v1-contextDatas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createContextDataRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDataDelete: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('contextDataDelete', 'id', id);
            const localVarPath = `/v1-contextDatas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a context data
         * @param {UpdateContextDataRequest} updateContextDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDataUpdate: async (updateContextDataRequest, options = {}) => {
            // verify required parameter 'updateContextDataRequest' is not null or undefined
            (0, common_1.assertParamExists)('contextDataUpdate', 'updateContextDataRequest', updateContextDataRequest);
            const localVarPath = `/v1-contextDatas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateContextDataRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDelete: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('contextDelete', 'id', id);
            const localVarPath = `/v1-context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Test a custom context before training
         * @param {ContextTestRequest} contextTestRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextTest: async (contextTestRequest, options = {}) => {
            // verify required parameter 'contextTestRequest' is not null or undefined
            (0, common_1.assertParamExists)('contextTest', 'contextTestRequest', contextTestRequest);
            const localVarPath = `/v1-contextTest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(contextTestRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a context
         * @param {UpdateContextRequest} updateContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextUpdate: async (updateContextRequest, options = {}) => {
            // verify required parameter 'updateContextRequest' is not null or undefined
            (0, common_1.assertParamExists)('contextUpdate', 'updateContextRequest', updateContextRequest);
            const localVarPath = `/v1-context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateContextRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all or specific set of contexts
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contexts: async (q, id, options = {}) => {
            const localVarPath = `/v1-contexts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates new contexts
         * @param {CreateContextsRequest} createContextsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextsCreate: async (createContextsRequest, options = {}) => {
            // verify required parameter 'createContextsRequest' is not null or undefined
            (0, common_1.assertParamExists)('contextsCreate', 'createContextsRequest', createContextsRequest);
            const localVarPath = `/v1-contexts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createContextsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes multiple contexts
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextsDelete: async (id, options = {}) => {
            const localVarPath = `/v1-contexts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates multiple contexts
         * @param {UpdateContextRequest} updateContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextsUpdate: async (updateContextRequest, options = {}) => {
            // verify required parameter 'updateContextRequest' is not null or undefined
            (0, common_1.assertParamExists)('contextsUpdate', 'updateContextRequest', updateContextRequest);
            const localVarPath = `/v1-contexts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateContextRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a conversation
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversation: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('conversation', 'id', id);
            const localVarPath = `/v1-conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a new conversation
         * @param {ConversationCreateRequest} conversationCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationCreate: async (conversationCreateRequest, options = {}) => {
            // verify required parameter 'conversationCreateRequest' is not null or undefined
            (0, common_1.assertParamExists)('conversationCreate', 'conversationCreateRequest', conversationCreateRequest);
            const localVarPath = `/v1-conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(conversationCreateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationDelete: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('conversationDelete', 'id', id);
            const localVarPath = `/v1-conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a conversation
         * @param {ConversationUpdateRequest} conversationUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationUpdate: async (conversationUpdateRequest, options = {}) => {
            // verify required parameter 'conversationUpdateRequest' is not null or undefined
            (0, common_1.assertParamExists)('conversationUpdate', 'conversationUpdateRequest', conversationUpdateRequest);
            const localVarPath = `/v1-conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(conversationUpdateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a customer
         * @param {string} idOrEmailOrPhone id of customer or their registered phone or registered email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customer: async (idOrEmailOrPhone, options = {}) => {
            // verify required parameter 'idOrEmailOrPhone' is not null or undefined
            (0, common_1.assertParamExists)('customer', 'idOrEmailOrPhone', idOrEmailOrPhone);
            const localVarPath = `/v1-customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (idOrEmailOrPhone !== undefined) {
                localVarQueryParameter['idOrEmailOrPhone'] = idOrEmailOrPhone;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new customer
         * @param {CreateCustomerRequest} createCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCreate: async (createCustomerRequest, options = {}) => {
            // verify required parameter 'createCustomerRequest' is not null or undefined
            (0, common_1.assertParamExists)('customerCreate', 'createCustomerRequest', createCustomerRequest);
            const localVarPath = `/v1-customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createCustomerRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a customer
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDelete: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('customerDelete', 'id', id);
            const localVarPath = `/v1-customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a customer group
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroup: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('customerGroup', 'id', id);
            const localVarPath = `/v1-customerGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new customer group
         * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupCreate: async (createCustomerGroupRequest, options = {}) => {
            // verify required parameter 'createCustomerGroupRequest' is not null or undefined
            (0, common_1.assertParamExists)('customerGroupCreate', 'createCustomerGroupRequest', createCustomerGroupRequest);
            const localVarPath = `/v1-customerGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createCustomerGroupRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a customer group
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupDelete: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('customerGroupDelete', 'id', id);
            const localVarPath = `/v1-customerGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates a customer group
         * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupUpdate: async (updateCustomerGroupRequest, options = {}) => {
            // verify required parameter 'updateCustomerGroupRequest' is not null or undefined
            (0, common_1.assertParamExists)('customerGroupUpdate', 'updateCustomerGroupRequest', updateCustomerGroupRequest);
            const localVarPath = `/v1-customerGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateCustomerGroupRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all or specific set of customer groups
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroups: async (q, id, options = {}) => {
            const localVarPath = `/v1-customerGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates new customer groups
         * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupsCreate: async (createCustomerGroupsRequest, options = {}) => {
            // verify required parameter 'createCustomerGroupsRequest' is not null or undefined
            (0, common_1.assertParamExists)('customerGroupsCreate', 'createCustomerGroupsRequest', createCustomerGroupsRequest);
            const localVarPath = `/v1-customerGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createCustomerGroupsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes multiple customer groups
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupsDelete: async (id, options = {}) => {
            const localVarPath = `/v1-customerGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates multiple customer groups
         * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupsUpdate: async (updateCustomerGroupsRequest, options = {}) => {
            // verify required parameter 'updateCustomerGroupsRequest' is not null or undefined
            (0, common_1.assertParamExists)('customerGroupsUpdate', 'updateCustomerGroupsRequest', updateCustomerGroupsRequest);
            const localVarPath = `/v1-customerGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateCustomerGroupsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates a customer
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerUpdate: async (updateCustomerRequest, options = {}) => {
            // verify required parameter 'updateCustomerRequest' is not null or undefined
            (0, common_1.assertParamExists)('customerUpdate', 'updateCustomerRequest', updateCustomerRequest);
            const localVarPath = `/v1-customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateCustomerRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all or specific set of customers
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customers: async (q, id, options = {}) => {
            const localVarPath = `/v1-customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates new customers
         * @param {CreateCustomersRequest} createCustomersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCreate: async (createCustomersRequest, options = {}) => {
            // verify required parameter 'createCustomersRequest' is not null or undefined
            (0, common_1.assertParamExists)('customersCreate', 'createCustomersRequest', createCustomersRequest);
            const localVarPath = `/v1-customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createCustomersRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes multiple customers
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersDelete: async (id, options = {}) => {
            const localVarPath = `/v1-customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates multiple customers
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersUpdate: async (updateCustomerRequest, options = {}) => {
            // verify required parameter 'updateCustomerRequest' is not null or undefined
            (0, common_1.assertParamExists)('customersUpdate', 'updateCustomerRequest', updateCustomerRequest);
            const localVarPath = `/v1-customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateCustomerRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns information about a specific file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        file: async (fileId, options = {}) => {
            // verify required parameter 'fileId' is not null or undefined
            (0, common_1.assertParamExists)('file', 'fileId', fileId);
            const localVarPath = `/files/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
         * @param {File} file
         * @param {string} [purpose] The intended purpose of the uploaded documents.  This allows us to validate the format of the uploaded file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileCreate: async (file, purpose, options = {}) => {
            // verify required parameter 'file' is not null or undefined
            (0, common_1.assertParamExists)('fileCreate', 'file', file);
            const localVarPath = `/v1-utils-files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            if (purpose !== undefined) {
                localVarFormParams.append('purpose', purpose);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Delete a file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileDelete: async (fileId, options = {}) => {
            // verify required parameter 'fileId' is not null or undefined
            (0, common_1.assertParamExists)('fileDelete', 'fileId', fileId);
            const localVarPath = `/files/{file_id}`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns the contents of the specified file
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileDownload: async (fileId, options = {}) => {
            // verify required parameter 'fileId' is not null or undefined
            (0, common_1.assertParamExists)('fileDownload', 'fileId', fileId);
            const localVarPath = `/files/{file_id}/content`
                .replace(`{${"file_id"}}`, encodeURIComponent(String(fileId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns a list of files that belong to the user\'s organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        files: async (options = {}) => {
            const localVarPath = `/v1-utils-files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
         * @summary Generate a message from conversation
         * @param {GenerateRequest} generateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate: async (generateRequest, options = {}) => {
            // verify required parameter 'generateRequest' is not null or undefined
            (0, common_1.assertParamExists)('generate', 'generateRequest', generateRequest);
            const localVarPath = `/v1-generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(generateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
         * @summary Create and send message
         * @param {MessageCreateRequest} messageCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        message: async (messageCreateRequest, options = {}) => {
            // verify required parameter 'messageCreateRequest' is not null or undefined
            (0, common_1.assertParamExists)('message', 'messageCreateRequest', messageCreateRequest);
            const localVarPath = `/v1-messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(messageCreateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all messages from a conversation
         * @param {string} id id of entity to query
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messages: async (id, q, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('messages', 'id', id);
            const localVarPath = `/v1-messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get the results of a bulk API operation
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operation: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('operation', 'id', id);
            const localVarPath = `/v1-utils-operation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all or specific set of bulk API operations
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operations: async (q, id, options = {}) => {
            const localVarPath = `/v1-utils-operations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new scheduled conversation
         * @param {ScheduleCreateRequest} scheduleCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleConversation: async (scheduleCreateRequest, options = {}) => {
            // verify required parameter 'scheduleCreateRequest' is not null or undefined
            (0, common_1.assertParamExists)('scheduleConversation', 'scheduleCreateRequest', scheduleCreateRequest);
            const localVarPath = `/v1-schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(scheduleCreateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleDelete: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('scheduleDelete', 'id', id);
            const localVarPath = `/v1-schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new schedule group
         * @param {ScheduleGroupCreateRequest} scheduleGroupCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleGroupCreate: async (scheduleGroupCreateRequest, options = {}) => {
            // verify required parameter 'scheduleGroupCreateRequest' is not null or undefined
            (0, common_1.assertParamExists)('scheduleGroupCreate', 'scheduleGroupCreateRequest', scheduleGroupCreateRequest);
            const localVarPath = `/v1-scheduleGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(scheduleGroupCreateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes and cancels a schedule group
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleGroupDelete: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('scheduleGroupDelete', 'id', id);
            const localVarPath = `/v1-scheduleGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a schedule group
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleGroupRetrieve: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('scheduleGroupRetrieve', 'id', id);
            const localVarPath = `/v1-scheduleGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates a schedule group
         * @param {ScheduleGroupUpdateRequest} scheduleGroupUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleGroupUpdate: async (scheduleGroupUpdateRequest, options = {}) => {
            // verify required parameter 'scheduleGroupUpdateRequest' is not null or undefined
            (0, common_1.assertParamExists)('scheduleGroupUpdate', 'scheduleGroupUpdateRequest', scheduleGroupUpdateRequest);
            const localVarPath = `/v1-scheduleGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(scheduleGroupUpdateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleRetrieve: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('scheduleRetrieve', 'id', id);
            const localVarPath = `/v1-schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates a schedule
         * @param {ScheduleUpdateRequest} scheduleUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleUpdate: async (scheduleUpdateRequest, options = {}) => {
            // verify required parameter 'scheduleUpdateRequest' is not null or undefined
            (0, common_1.assertParamExists)('scheduleUpdate', 'scheduleUpdateRequest', scheduleUpdateRequest);
            const localVarPath = `/v1-schedule`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(scheduleUpdateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a workflow
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflow: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('workflow', 'id', id);
            const localVarPath = `/v1-workflow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a new workflow
         * @param {CreateWorkflowRequest} createWorkflowRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowCreate: async (createWorkflowRequest, options = {}) => {
            // verify required parameter 'createWorkflowRequest' is not null or undefined
            (0, common_1.assertParamExists)('workflowCreate', 'createWorkflowRequest', createWorkflowRequest);
            const localVarPath = `/v1-workflow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWorkflowRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a workflow
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowDelete: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('workflowDelete', 'id', id);
            const localVarPath = `/v1-workflow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a workflow
         * @param {UpdateWorkflowRequest} updateWorkflowRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowUpdate: async (updateWorkflowRequest, options = {}) => {
            // verify required parameter 'updateWorkflowRequest' is not null or undefined
            (0, common_1.assertParamExists)('workflowUpdate', 'updateWorkflowRequest', updateWorkflowRequest);
            const localVarPath = `/v1-workflow`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateWorkflowRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all or specific set of workflows
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflows: async (q, id, options = {}) => {
            const localVarPath = `/v1-workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates new workflows
         * @param {CreateWorkflowsRequest} createWorkflowsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsCreate: async (createWorkflowsRequest, options = {}) => {
            // verify required parameter 'createWorkflowsRequest' is not null or undefined
            (0, common_1.assertParamExists)('workflowsCreate', 'createWorkflowsRequest', createWorkflowsRequest);
            const localVarPath = `/v1-workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createWorkflowsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes multiple workflows
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsDelete: async (id, options = {}) => {
            const localVarPath = `/v1-workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates multiple workflows
         * @param {UpdateWorkflowRequest} updateWorkflowRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsUpdate: async (updateWorkflowRequest, options = {}) => {
            // verify required parameter 'updateWorkflowRequest' is not null or undefined
            (0, common_1.assertParamExists)('workflowsUpdate', 'updateWorkflowRequest', updateWorkflowRequest);
            const localVarPath = `/v1-workflows`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateWorkflowRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.Scout9ApiAxiosParamCreator = Scout9ApiAxiosParamCreator;
/**
 * Scout9Api - functional programming interface
 * @export
 */
const Scout9ApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.Scout9ApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Gets a agent
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agent(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agent(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a agent
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Registers a new agent
         * @param {CreateAgentRequest} createAgentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentRegister(createAgentRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentRegister(createAgentRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update a agent
         * @param {UpdateAgentRequest} updateAgentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentUpdate(updateAgentRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentUpdate(updateAgentRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets all or specific set of agents
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agents(q, id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agents(q, id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates new agents
         * @param {CreateAgentsRequest} createAgentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsCreate(createAgentsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsCreate(createAgentsRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes multiple agents
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates multiple agents
         * @param {UpdateAgentsRequest} updateAgentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsUpdate(updateAgentsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsUpdate(updateAgentsRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a context
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async context(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.context(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create a new context
         * @param {CreateContextRequest} createContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextCreate(createContextRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextCreate(createContextRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets context data
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextData(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextData(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create a new context data
         * @param {CreateContextDataRequest} createContextDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextDataCreate(createContextDataRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextDataCreate(createContextDataRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextDataDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextDataDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update a context data
         * @param {UpdateContextDataRequest} updateContextDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextDataUpdate(updateContextDataRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextDataUpdate(updateContextDataRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Test a custom context before training
         * @param {ContextTestRequest} contextTestRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextTest(contextTestRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextTest(contextTestRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update a context
         * @param {UpdateContextRequest} updateContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextUpdate(updateContextRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextUpdate(updateContextRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets all or specific set of contexts
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contexts(q, id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contexts(q, id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates new contexts
         * @param {CreateContextsRequest} createContextsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextsCreate(createContextsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextsCreate(createContextsRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes multiple contexts
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextsDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextsDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates multiple contexts
         * @param {UpdateContextRequest} updateContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextsUpdate(updateContextRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextsUpdate(updateContextRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a conversation
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversation(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conversation(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create a new conversation
         * @param {ConversationCreateRequest} conversationCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversationCreate(conversationCreateRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conversationCreate(conversationCreateRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversationDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conversationDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update a conversation
         * @param {ConversationUpdateRequest} conversationUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversationUpdate(conversationUpdateRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conversationUpdate(conversationUpdateRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a customer
         * @param {string} idOrEmailOrPhone id of customer or their registered phone or registered email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customer(idOrEmailOrPhone, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customer(idOrEmailOrPhone, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a new customer
         * @param {CreateCustomerRequest} createCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerCreate(createCustomerRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerCreate(createCustomerRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a customer
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a customer group
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGroup(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroup(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a new customer group
         * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGroupCreate(createCustomerGroupRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupCreate(createCustomerGroupRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a customer group
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGroupDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates a customer group
         * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGroupUpdate(updateCustomerGroupRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupUpdate(updateCustomerGroupRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets all or specific set of customer groups
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGroups(q, id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroups(q, id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates new customer groups
         * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGroupsCreate(createCustomerGroupsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupsCreate(createCustomerGroupsRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes multiple customer groups
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGroupsDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupsDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates multiple customer groups
         * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGroupsUpdate(updateCustomerGroupsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupsUpdate(updateCustomerGroupsRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates a customer
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerUpdate(updateCustomerRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerUpdate(updateCustomerRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets all or specific set of customers
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customers(q, id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customers(q, id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates new customers
         * @param {CreateCustomersRequest} createCustomersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersCreate(createCustomersRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersCreate(createCustomersRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes multiple customers
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates multiple customers
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersUpdate(updateCustomerRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersUpdate(updateCustomerRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns information about a specific file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async file(fileId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.file(fileId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
         * @param {File} file
         * @param {string} [purpose] The intended purpose of the uploaded documents.  This allows us to validate the format of the uploaded file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileCreate(file, purpose, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileCreate(file, purpose, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Delete a file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileDelete(fileId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileDelete(fileId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns the contents of the specified file
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileDownload(fileId, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileDownload(fileId, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns a list of files that belong to the user\'s organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async files(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.files(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
         * @summary Generate a message from conversation
         * @param {GenerateRequest} generateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generate(generateRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generate(generateRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
         * @summary Create and send message
         * @param {MessageCreateRequest} messageCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async message(messageCreateRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.message(messageCreateRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all messages from a conversation
         * @param {string} id id of entity to query
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messages(id, q, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messages(id, q, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get the results of a bulk API operation
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operation(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operation(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets all or specific set of bulk API operations
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operations(q, id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operations(q, id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a new scheduled conversation
         * @param {ScheduleCreateRequest} scheduleCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleConversation(scheduleCreateRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleConversation(scheduleCreateRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a new schedule group
         * @param {ScheduleGroupCreateRequest} scheduleGroupCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleGroupCreate(scheduleGroupCreateRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleGroupCreate(scheduleGroupCreateRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes and cancels a schedule group
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleGroupDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleGroupDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a schedule group
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleGroupRetrieve(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleGroupRetrieve(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates a schedule group
         * @param {ScheduleGroupUpdateRequest} scheduleGroupUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleGroupUpdate(scheduleGroupUpdateRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleGroupUpdate(scheduleGroupUpdateRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleRetrieve(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleRetrieve(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates a schedule
         * @param {ScheduleUpdateRequest} scheduleUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async scheduleUpdate(scheduleUpdateRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.scheduleUpdate(scheduleUpdateRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a workflow
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflow(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflow(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create a new workflow
         * @param {CreateWorkflowRequest} createWorkflowRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowCreate(createWorkflowRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowCreate(createWorkflowRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a workflow
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update a workflow
         * @param {UpdateWorkflowRequest} updateWorkflowRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowUpdate(updateWorkflowRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowUpdate(updateWorkflowRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets all or specific set of workflows
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflows(q, id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflows(q, id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates new workflows
         * @param {CreateWorkflowsRequest} createWorkflowsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowsCreate(createWorkflowsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsCreate(createWorkflowsRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes multiple workflows
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowsDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates multiple workflows
         * @param {UpdateWorkflowRequest} updateWorkflowRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async workflowsUpdate(updateWorkflowRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.workflowsUpdate(updateWorkflowRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.Scout9ApiFp = Scout9ApiFp;
/**
 * Scout9Api - factory interface
 * @export
 */
const Scout9ApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.Scout9ApiFp)(configuration);
    return {
        /**
         *
         * @summary Gets a agent
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agent(id, options) {
            return localVarFp.agent(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a agent
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentDelete(id, options) {
            return localVarFp.agentDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Registers a new agent
         * @param {CreateAgentRequest} createAgentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentRegister(createAgentRequest, options) {
            return localVarFp.agentRegister(createAgentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a agent
         * @param {UpdateAgentRequest} updateAgentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentUpdate(updateAgentRequest, options) {
            return localVarFp.agentUpdate(updateAgentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all or specific set of agents
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agents(q, id, options) {
            return localVarFp.agents(q, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates new agents
         * @param {CreateAgentsRequest} createAgentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsCreate(createAgentsRequest, options) {
            return localVarFp.agentsCreate(createAgentsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes multiple agents
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsDelete(id, options) {
            return localVarFp.agentsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates multiple agents
         * @param {UpdateAgentsRequest} updateAgentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsUpdate(updateAgentsRequest, options) {
            return localVarFp.agentsUpdate(updateAgentsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a context
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        context(id, options) {
            return localVarFp.context(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new context
         * @param {CreateContextRequest} createContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextCreate(createContextRequest, options) {
            return localVarFp.contextCreate(createContextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets context data
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextData(id, options) {
            return localVarFp.contextData(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new context data
         * @param {CreateContextDataRequest} createContextDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDataCreate(createContextDataRequest, options) {
            return localVarFp.contextDataCreate(createContextDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDataDelete(id, options) {
            return localVarFp.contextDataDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a context data
         * @param {UpdateContextDataRequest} updateContextDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDataUpdate(updateContextDataRequest, options) {
            return localVarFp.contextDataUpdate(updateContextDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDelete(id, options) {
            return localVarFp.contextDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Test a custom context before training
         * @param {ContextTestRequest} contextTestRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextTest(contextTestRequest, options) {
            return localVarFp.contextTest(contextTestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a context
         * @param {UpdateContextRequest} updateContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextUpdate(updateContextRequest, options) {
            return localVarFp.contextUpdate(updateContextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all or specific set of contexts
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contexts(q, id, options) {
            return localVarFp.contexts(q, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates new contexts
         * @param {CreateContextsRequest} createContextsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextsCreate(createContextsRequest, options) {
            return localVarFp.contextsCreate(createContextsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes multiple contexts
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextsDelete(id, options) {
            return localVarFp.contextsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates multiple contexts
         * @param {UpdateContextRequest} updateContextRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextsUpdate(updateContextRequest, options) {
            return localVarFp.contextsUpdate(updateContextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a conversation
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversation(id, options) {
            return localVarFp.conversation(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new conversation
         * @param {ConversationCreateRequest} conversationCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationCreate(conversationCreateRequest, options) {
            return localVarFp.conversationCreate(conversationCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationDelete(id, options) {
            return localVarFp.conversationDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a conversation
         * @param {ConversationUpdateRequest} conversationUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationUpdate(conversationUpdateRequest, options) {
            return localVarFp.conversationUpdate(conversationUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a customer
         * @param {string} idOrEmailOrPhone id of customer or their registered phone or registered email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customer(idOrEmailOrPhone, options) {
            return localVarFp.customer(idOrEmailOrPhone, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a new customer
         * @param {CreateCustomerRequest} createCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCreate(createCustomerRequest, options) {
            return localVarFp.customerCreate(createCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a customer
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDelete(id, options) {
            return localVarFp.customerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a customer group
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroup(id, options) {
            return localVarFp.customerGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a new customer group
         * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupCreate(createCustomerGroupRequest, options) {
            return localVarFp.customerGroupCreate(createCustomerGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a customer group
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupDelete(id, options) {
            return localVarFp.customerGroupDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a customer group
         * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupUpdate(updateCustomerGroupRequest, options) {
            return localVarFp.customerGroupUpdate(updateCustomerGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all or specific set of customer groups
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroups(q, id, options) {
            return localVarFp.customerGroups(q, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates new customer groups
         * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupsCreate(createCustomerGroupsRequest, options) {
            return localVarFp.customerGroupsCreate(createCustomerGroupsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes multiple customer groups
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupsDelete(id, options) {
            return localVarFp.customerGroupsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates multiple customer groups
         * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupsUpdate(updateCustomerGroupsRequest, options) {
            return localVarFp.customerGroupsUpdate(updateCustomerGroupsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a customer
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerUpdate(updateCustomerRequest, options) {
            return localVarFp.customerUpdate(updateCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all or specific set of customers
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customers(q, id, options) {
            return localVarFp.customers(q, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates new customers
         * @param {CreateCustomersRequest} createCustomersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCreate(createCustomersRequest, options) {
            return localVarFp.customersCreate(createCustomersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes multiple customers
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersDelete(id, options) {
            return localVarFp.customersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates multiple customers
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersUpdate(updateCustomerRequest, options) {
            return localVarFp.customersUpdate(updateCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns information about a specific file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        file(fileId, options) {
            return localVarFp.file(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
         * @param {File} file
         * @param {string} [purpose] The intended purpose of the uploaded documents.  This allows us to validate the format of the uploaded file.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileCreate(file, purpose, options) {
            return localVarFp.fileCreate(file, purpose, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Delete a file.
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileDelete(fileId, options) {
            return localVarFp.fileDelete(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the contents of the specified file
         * @param {string} fileId The ID of the file to use for this request
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileDownload(fileId, options) {
            return localVarFp.fileDownload(fileId, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a list of files that belong to the user\'s organization.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        files(options) {
            return localVarFp.files(options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
         * @summary Generate a message from conversation
         * @param {GenerateRequest} generateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate(generateRequest, options) {
            return localVarFp.generate(generateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
         * @summary Create and send message
         * @param {MessageCreateRequest} messageCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        message(messageCreateRequest, options) {
            return localVarFp.message(messageCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all messages from a conversation
         * @param {string} id id of entity to query
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messages(id, q, options) {
            return localVarFp.messages(id, q, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the results of a bulk API operation
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operation(id, options) {
            return localVarFp.operation(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all or specific set of bulk API operations
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operations(q, id, options) {
            return localVarFp.operations(q, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a new scheduled conversation
         * @param {ScheduleCreateRequest} scheduleCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleConversation(scheduleCreateRequest, options) {
            return localVarFp.scheduleConversation(scheduleCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleDelete(id, options) {
            return localVarFp.scheduleDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a new schedule group
         * @param {ScheduleGroupCreateRequest} scheduleGroupCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleGroupCreate(scheduleGroupCreateRequest, options) {
            return localVarFp.scheduleGroupCreate(scheduleGroupCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes and cancels a schedule group
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleGroupDelete(id, options) {
            return localVarFp.scheduleGroupDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a schedule group
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleGroupRetrieve(id, options) {
            return localVarFp.scheduleGroupRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a schedule group
         * @param {ScheduleGroupUpdateRequest} scheduleGroupUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleGroupUpdate(scheduleGroupUpdateRequest, options) {
            return localVarFp.scheduleGroupUpdate(scheduleGroupUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleRetrieve(id, options) {
            return localVarFp.scheduleRetrieve(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a schedule
         * @param {ScheduleUpdateRequest} scheduleUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        scheduleUpdate(scheduleUpdateRequest, options) {
            return localVarFp.scheduleUpdate(scheduleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a workflow
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflow(id, options) {
            return localVarFp.workflow(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new workflow
         * @param {CreateWorkflowRequest} createWorkflowRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowCreate(createWorkflowRequest, options) {
            return localVarFp.workflowCreate(createWorkflowRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a workflow
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowDelete(id, options) {
            return localVarFp.workflowDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a workflow
         * @param {UpdateWorkflowRequest} updateWorkflowRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowUpdate(updateWorkflowRequest, options) {
            return localVarFp.workflowUpdate(updateWorkflowRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all or specific set of workflows
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflows(q, id, options) {
            return localVarFp.workflows(q, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates new workflows
         * @param {CreateWorkflowsRequest} createWorkflowsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsCreate(createWorkflowsRequest, options) {
            return localVarFp.workflowsCreate(createWorkflowsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes multiple workflows
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsDelete(id, options) {
            return localVarFp.workflowsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates multiple workflows
         * @param {UpdateWorkflowRequest} updateWorkflowRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        workflowsUpdate(updateWorkflowRequest, options) {
            return localVarFp.workflowsUpdate(updateWorkflowRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.Scout9ApiFactory = Scout9ApiFactory;
/**
 * Scout9Api - object-oriented interface
 * @export
 * @class Scout9Api
 * @extends {BaseAPI}
 */
class Scout9Api extends base_1.BaseAPI {
    /**
     *
     * @summary Gets a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    agent(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).agent(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    agentDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).agentDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Registers a new agent
     * @param {CreateAgentRequest} createAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    agentRegister(createAgentRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).agentRegister(createAgentRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a agent
     * @param {UpdateAgentRequest} updateAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    agentUpdate(updateAgentRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).agentUpdate(updateAgentRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets all or specific set of agents
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    agents(q, id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).agents(q, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates new agents
     * @param {CreateAgentsRequest} createAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    agentsCreate(createAgentsRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).agentsCreate(createAgentsRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes multiple agents
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    agentsDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).agentsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates multiple agents
     * @param {UpdateAgentsRequest} updateAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    agentsUpdate(updateAgentsRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).agentsUpdate(updateAgentsRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets a context
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    context(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).context(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a new context
     * @param {CreateContextRequest} createContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextCreate(createContextRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextCreate(createContextRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets context data
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextData(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextData(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a new context data
     * @param {CreateContextDataRequest} createContextDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextDataCreate(createContextDataRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextDataCreate(createContextDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextDataDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextDataDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a context data
     * @param {UpdateContextDataRequest} updateContextDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextDataUpdate(updateContextDataRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextDataUpdate(updateContextDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Test a custom context before training
     * @param {ContextTestRequest} contextTestRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextTest(contextTestRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextTest(contextTestRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a context
     * @param {UpdateContextRequest} updateContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextUpdate(updateContextRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextUpdate(updateContextRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets all or specific set of contexts
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contexts(q, id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contexts(q, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates new contexts
     * @param {CreateContextsRequest} createContextsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextsCreate(createContextsRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextsCreate(createContextsRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes multiple contexts
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextsDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates multiple contexts
     * @param {UpdateContextRequest} updateContextRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextsUpdate(updateContextRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextsUpdate(updateContextRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets a conversation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    conversation(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).conversation(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a new conversation
     * @param {ConversationCreateRequest} conversationCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    conversationCreate(conversationCreateRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).conversationCreate(conversationCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    conversationDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).conversationDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a conversation
     * @param {ConversationUpdateRequest} conversationUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    conversationUpdate(conversationUpdateRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).conversationUpdate(conversationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets a customer
     * @param {string} idOrEmailOrPhone id of customer or their registered phone or registered email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customer(idOrEmailOrPhone, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customer(idOrEmailOrPhone, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates a new customer
     * @param {CreateCustomerRequest} createCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerCreate(createCustomerRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerCreate(createCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a customer
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerGroup(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerGroup(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates a new customer group
     * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerGroupCreate(createCustomerGroupRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerGroupCreate(createCustomerGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerGroupDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerGroupDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a customer group
     * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerGroupUpdate(updateCustomerGroupRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerGroupUpdate(updateCustomerGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets all or specific set of customer groups
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerGroups(q, id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerGroups(q, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates new customer groups
     * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerGroupsCreate(createCustomerGroupsRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerGroupsCreate(createCustomerGroupsRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes multiple customer groups
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerGroupsDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerGroupsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates multiple customer groups
     * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerGroupsUpdate(updateCustomerGroupsRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerGroupsUpdate(updateCustomerGroupsRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a customer
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerUpdate(updateCustomerRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerUpdate(updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets all or specific set of customers
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customers(q, id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customers(q, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates new customers
     * @param {CreateCustomersRequest} createCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customersCreate(createCustomersRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customersCreate(createCustomersRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes multiple customers
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customersDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customersDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates multiple customers
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customersUpdate(updateCustomerRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customersUpdate(updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns information about a specific file.
     * @param {string} fileId The ID of the file to use for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    file(fileId, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).file(fileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
     * @param {File} file
     * @param {string} [purpose] The intended purpose of the uploaded documents.  This allows us to validate the format of the uploaded file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    fileCreate(file, purpose, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).fileCreate(file, purpose, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Delete a file.
     * @param {string} fileId The ID of the file to use for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    fileDelete(fileId, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).fileDelete(fileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the contents of the specified file
     * @param {string} fileId The ID of the file to use for this request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    fileDownload(fileId, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).fileDownload(fileId, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a list of files that belong to the user\'s organization.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    files(options) {
        return (0, exports.Scout9ApiFp)(this.configuration).files(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
     * @summary Generate a message from conversation
     * @param {GenerateRequest} generateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    generate(generateRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).generate(generateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
     * @summary Create and send message
     * @param {MessageCreateRequest} messageCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    message(messageCreateRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).message(messageCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all messages from a conversation
     * @param {string} id id of entity to query
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    messages(id, q, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).messages(id, q, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the results of a bulk API operation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    operation(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).operation(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets all or specific set of bulk API operations
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    operations(q, id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).operations(q, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates a new scheduled conversation
     * @param {ScheduleCreateRequest} scheduleCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    scheduleConversation(scheduleCreateRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).scheduleConversation(scheduleCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    scheduleDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).scheduleDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates a new schedule group
     * @param {ScheduleGroupCreateRequest} scheduleGroupCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    scheduleGroupCreate(scheduleGroupCreateRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).scheduleGroupCreate(scheduleGroupCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes and cancels a schedule group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    scheduleGroupDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).scheduleGroupDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets a schedule group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    scheduleGroupRetrieve(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).scheduleGroupRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a schedule group
     * @param {ScheduleGroupUpdateRequest} scheduleGroupUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    scheduleGroupUpdate(scheduleGroupUpdateRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).scheduleGroupUpdate(scheduleGroupUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    scheduleRetrieve(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).scheduleRetrieve(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a schedule
     * @param {ScheduleUpdateRequest} scheduleUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    scheduleUpdate(scheduleUpdateRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).scheduleUpdate(scheduleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets a workflow
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    workflow(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).workflow(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a new workflow
     * @param {CreateWorkflowRequest} createWorkflowRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    workflowCreate(createWorkflowRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).workflowCreate(createWorkflowRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a workflow
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    workflowDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).workflowDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a workflow
     * @param {UpdateWorkflowRequest} updateWorkflowRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    workflowUpdate(updateWorkflowRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).workflowUpdate(updateWorkflowRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets all or specific set of workflows
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    workflows(q, id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).workflows(q, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates new workflows
     * @param {CreateWorkflowsRequest} createWorkflowsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    workflowsCreate(createWorkflowsRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).workflowsCreate(createWorkflowsRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes multiple workflows
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    workflowsDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).workflowsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates multiple workflows
     * @param {UpdateWorkflowRequest} updateWorkflowRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    workflowsUpdate(updateWorkflowRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).workflowsUpdate(updateWorkflowRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.Scout9Api = Scout9Api;
