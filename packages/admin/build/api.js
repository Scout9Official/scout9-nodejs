"use strict";
/* tslint:disable */
/* eslint-disable */
/**
 * Scout9 API
 * Scout9 APIs for managing Scout9 users and conversations with your Scout9 agents
 *
 * The version of the OpenAPI document: 1.0.0-alpha.0.0.9
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Scout9Api = exports.Scout9ApiGenerated = exports.Scout9ApiFactory = exports.Scout9ApiFp = exports.Scout9ApiAxiosParamCreator = exports.CustomContextApi = exports.CustomContextApiFactory = exports.CustomContextApiFp = exports.CustomContextApiAxiosParamCreator = exports.WorkflowResponseSlotForwardOneOfModeEnum = exports.PurposeEnum = exports.PmtConfigModelEnum = exports.PmtConfigEngineEnum = exports.MessageGetResponseInnerRoleEnum = exports.MessageCreateRequestRoleEnum = exports.MessageBaseRoleEnum = exports.MessageRoleEnum = exports.MacroResultTypeEnum = exports.MacroDidResultAllOfTypeEnum = exports.MacroDidResultTypeEnum = exports.MacroContextResultAllOfTypeEnum = exports.MacroContextResultTypeEnum = exports.LlmConfigOneOf2EngineEnum = exports.LlmConfigOneOf1EngineEnum = exports.LlmConfigOneOfModelEnum = exports.LlmConfigOneOfEngineEnum = exports.ListApiOperationsResponseInnerMethodEnum = exports.GetApiOperationResponseMethodEnum = exports.ForwardRequestLatestMessageRoleEnum = exports.ForwardRequestForwardOneOfModeEnum = exports.ExistenceOperator = exports.EqualityOperator = exports.ConversationEnvironment = exports.ConversationContextFieldConditionOperatorEnum = exports.ApiOperationMethodEnum = void 0;
const axios_1 = __importDefault(require("axios"));
// Some imports not used depending on template conditions
// @ts-ignore
const common_1 = require("./common");
// @ts-ignore
const base_1 = require("./base");
exports.ApiOperationMethodEnum = {
    Get: 'get',
    Post: 'post',
    Put: 'put',
    Delete: 'delete',
    Patch: 'patch'
};
exports.ConversationContextFieldConditionOperatorEnum = {
    Eq: 'eq',
    Equal: 'equal',
    Ne: 'ne',
    NotEquals: 'not-equals',
    Gt: 'gt',
    GreaterThan: 'greater-than',
    Gte: 'gte',
    GreaterThanEquals: 'greater-than-equals',
    Lt: 'lt',
    LessThan: 'less-than',
    Lte: 'lte',
    LessThanEquals: 'less-than-equals',
    ArrayContains: 'array-contains',
    In: 'in',
    ArrayContainsAny: 'array-contains-any',
    NotIn: 'not-in',
    Exists: 'exists',
    NotExists: 'notExists',
    Contains: 'contains',
    NotContains: 'notContains',
    StartsWith: 'startsWith',
    EndsWith: 'endsWith'
};
/**
 * Environment this conversation is in (phone, web, or email) - this determines which device to send messages to
 * @export
 * @enum {string}
 */
exports.ConversationEnvironment = {
    Phone: 'phone',
    Web: 'web',
    Email: 'email'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.EqualityOperator = {
    Eq: 'eq',
    Neq: 'neq',
    Gt: 'gt',
    Gte: 'gte',
    Lt: 'lt',
    Lte: 'lte',
    In: 'in',
    Nin: 'nin',
    Contains: 'contains',
    NotContains: 'notContains',
    StartsWith: 'startsWith',
    EndsWith: 'endsWith',
    ArrayContainsAny: 'arrayContainsAny',
    ArrayContains: 'arrayContains'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.ExistenceOperator = {
    Exists: 'exists',
    NotExists: 'notExists'
};
exports.ForwardRequestForwardOneOfModeEnum = {
    AfterReply: 'after-reply',
    Immediately: 'immediately'
};
exports.ForwardRequestLatestMessageRoleEnum = {
    Customer: 'customer',
    Agent: 'agent',
    Context: 'context'
};
exports.GetApiOperationResponseMethodEnum = {
    Get: 'get',
    Post: 'post',
    Put: 'put',
    Delete: 'delete',
    Patch: 'patch'
};
exports.ListApiOperationsResponseInnerMethodEnum = {
    Get: 'get',
    Post: 'post',
    Put: 'put',
    Delete: 'delete',
    Patch: 'patch'
};
exports.LlmConfigOneOfEngineEnum = {
    Openai: 'openai'
};
exports.LlmConfigOneOfModelEnum = {
    _41106Preview: 'gpt-4-1106-preview',
    _4VisionPreview: 'gpt-4-vision-preview',
    _4: 'gpt-4',
    _40314: 'gpt-4-0314',
    _40613: 'gpt-4-0613',
    _432k: 'gpt-4-32k',
    _432k0314: 'gpt-4-32k-0314',
    _432k0613: 'gpt-4-32k-0613',
    _35Turbo: 'gpt-3.5-turbo',
    _35Turbo16k: 'gpt-3.5-turbo-16k',
    _35Turbo0301: 'gpt-3.5-turbo-0301',
    _35Turbo0613: 'gpt-3.5-turbo-0613',
    _35Turbo16k0613: 'gpt-3.5-turbo-16k-0613'
};
exports.LlmConfigOneOf1EngineEnum = {
    Llama: 'llama'
};
exports.LlmConfigOneOf2EngineEnum = {
    Bard: 'bard'
};
exports.MacroContextResultTypeEnum = {
    Context: 'context'
};
exports.MacroContextResultAllOfTypeEnum = {
    Context: 'context'
};
exports.MacroDidResultTypeEnum = {
    Did: 'did'
};
exports.MacroDidResultAllOfTypeEnum = {
    Did: 'did'
};
exports.MacroResultTypeEnum = {
    Did: 'did',
    Context: 'context'
};
exports.MessageRoleEnum = {
    Customer: 'customer',
    Agent: 'agent',
    Context: 'context'
};
exports.MessageBaseRoleEnum = {
    Customer: 'customer',
    Agent: 'agent',
    Context: 'context'
};
exports.MessageCreateRequestRoleEnum = {
    Agent: 'agent',
    Customer: 'customer',
    Context: 'context'
};
exports.MessageGetResponseInnerRoleEnum = {
    Customer: 'customer',
    Agent: 'agent',
    Context: 'context'
};
exports.PmtConfigEngineEnum = {
    Scout9: 'scout9'
};
exports.PmtConfigModelEnum = {
    _10: 'orin-1.0',
    _20Preview: 'orin-2.0-preview'
};
/**
 *
 * @export
 * @enum {string}
 */
exports.PurposeEnum = {
    Context: 'context',
    AgentAudio: 'agent-audio',
    AgentTranscript: 'agent-transcript'
};
exports.WorkflowResponseSlotForwardOneOfModeEnum = {
    AfterReply: 'after-reply',
    Immediately: 'immediately'
};
/**
 * CustomContextApi - axios parameter creator
 * @export
 */
const CustomContextApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Test a custom context before training
         * @param {ContextTestRequest} contextTestRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextTest: async (contextTestRequest, options = {}) => {
            // verify required parameter 'contextTestRequest' is not null or undefined
            (0, common_1.assertParamExists)('contextTest', 'contextTestRequest', contextTestRequest);
            const localVarPath = `/v1-contextTest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(contextTestRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.CustomContextApiAxiosParamCreator = CustomContextApiAxiosParamCreator;
/**
 * CustomContextApi - functional programming interface
 * @export
 */
const CustomContextApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.CustomContextApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Test a custom context before training
         * @param {ContextTestRequest} contextTestRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextTest(contextTestRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextTest(contextTestRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.CustomContextApiFp = CustomContextApiFp;
/**
 * CustomContextApi - factory interface
 * @export
 */
const CustomContextApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.CustomContextApiFp)(configuration);
    return {
        /**
         *
         * @summary Test a custom context before training
         * @param {ContextTestRequest} contextTestRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextTest(contextTestRequest, options) {
            return localVarFp.contextTest(contextTestRequest, options).then((request) => request(axios, basePath));
        },
    };
};
exports.CustomContextApiFactory = CustomContextApiFactory;
/**
 * CustomContextApi - object-oriented interface
 * @export
 * @class CustomContextApi
 * @extends {BaseAPI}
 */
class CustomContextApi extends base_1.BaseAPI {
    /**
     *
     * @summary Test a custom context before training
     * @param {ContextTestRequest} contextTestRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomContextApi
     */
    contextTest(contextTestRequest, options) {
        return (0, exports.CustomContextApiFp)(this.configuration).contextTest(contextTestRequest, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.CustomContextApi = CustomContextApi;
/**
 * Scout9Api - axios parameter creator
 * @export
 */
const Scout9ApiAxiosParamCreator = function (configuration) {
    return {
        /**
         *
         * @summary Create a new entity
         * @param {string} type
         * @param {string} id The unique identifier of the entity
         * @param {EntityData} entityData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntity: async (type, id, entityData, options = {}) => {
            // verify required parameter 'type' is not null or undefined
            (0, common_1.assertParamExists)('addEntity', 'type', type);
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('addEntity', 'id', id);
            // verify required parameter 'entityData' is not null or undefined
            (0, common_1.assertParamExists)('addEntity', 'entityData', entityData);
            const localVarPath = `/v1-entity/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(entityData, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a agent
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agent: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('agent', 'id', id);
            const localVarPath = `/v1-agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a agent
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentDelete: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('agentDelete', 'id', id);
            const localVarPath = `/v1-agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Registers a new agent
         * @param {CreateAgentRequest} createAgentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentRegister: async (createAgentRequest, options = {}) => {
            // verify required parameter 'createAgentRequest' is not null or undefined
            (0, common_1.assertParamExists)('agentRegister', 'createAgentRequest', createAgentRequest);
            const localVarPath = `/v1-agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createAgentRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a agent
         * @param {UpdateAgentRequest} updateAgentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentUpdate: async (updateAgentRequest, options = {}) => {
            // verify required parameter 'updateAgentRequest' is not null or undefined
            (0, common_1.assertParamExists)('agentUpdate', 'updateAgentRequest', updateAgentRequest);
            const localVarPath = `/v1-agent`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateAgentRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all or specific set of agents
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agents: async (q, id, options = {}) => {
            const localVarPath = `/v1-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates new agents
         * @param {CreateAgentsRequest} createAgentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsCreate: async (createAgentsRequest, options = {}) => {
            // verify required parameter 'createAgentsRequest' is not null or undefined
            (0, common_1.assertParamExists)('agentsCreate', 'createAgentsRequest', createAgentsRequest);
            const localVarPath = `/v1-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createAgentsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes multiple agents
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsDelete: async (id, options = {}) => {
            const localVarPath = `/v1-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates multiple agents
         * @param {UpdateAgentsRequest} updateAgentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsUpdate: async (updateAgentsRequest, options = {}) => {
            // verify required parameter 'updateAgentsRequest' is not null or undefined
            (0, common_1.assertParamExists)('agentsUpdate', 'updateAgentsRequest', updateAgentsRequest);
            const localVarPath = `/v1-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateAgentsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Natural language prompt to resolve a context value derived from the conversation.
         * @param {MacroContextInput} macroContextInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureContext: async (macroContextInput, options = {}) => {
            // verify required parameter 'macroContextInput' is not null or undefined
            (0, common_1.assertParamExists)('captureContext', 'macroContextInput', macroContextInput);
            const localVarPath = `/v1-utils-macros-context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(macroContextInput, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get the current project configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        config: async (options = {}) => {
            const localVarPath = `/v1-config`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a context. Don\'t use, create your context entities within your Scout9 application.
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        context: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('context', 'id', id);
            const localVarPath = `/v1-context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a new context. Don\'t use, create your context entities within your Scout9 application.
         * @param {CreateContextRequest} createContextRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        contextCreate: async (createContextRequest, options = {}) => {
            // verify required parameter 'createContextRequest' is not null or undefined
            (0, common_1.assertParamExists)('contextCreate', 'createContextRequest', createContextRequest);
            const localVarPath = `/v1-context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createContextRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets context data
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextData: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('contextData', 'id', id);
            const localVarPath = `/v1-contextDatas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a new context data
         * @param {CreateContextDataRequest} createContextDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDataCreate: async (createContextDataRequest, options = {}) => {
            // verify required parameter 'createContextDataRequest' is not null or undefined
            (0, common_1.assertParamExists)('contextDataCreate', 'createContextDataRequest', createContextDataRequest);
            const localVarPath = `/v1-contextDatas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createContextDataRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDataDelete: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('contextDataDelete', 'id', id);
            const localVarPath = `/v1-contextDatas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a context data
         * @param {UpdateContextDataRequest} updateContextDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDataUpdate: async (updateContextDataRequest, options = {}) => {
            // verify required parameter 'updateContextDataRequest' is not null or undefined
            (0, common_1.assertParamExists)('contextDataUpdate', 'updateContextDataRequest', updateContextDataRequest);
            const localVarPath = `/v1-contextDatas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateContextDataRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a context entity. Don\'t use, create your context entities within your Scout9 application.
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        contextDelete: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('contextDelete', 'id', id);
            const localVarPath = `/v1-context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Test a custom context before training
         * @param {ContextTestRequest} contextTestRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextTest: async (contextTestRequest, options = {}) => {
            // verify required parameter 'contextTestRequest' is not null or undefined
            (0, common_1.assertParamExists)('contextTest', 'contextTestRequest', contextTestRequest);
            const localVarPath = `/v1-contextTest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(contextTestRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a context. . Don\'t use, create your context entities within your Scout9 application.
         * @summary Update a context
         * @param {UpdateContextRequest} updateContextRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        contextUpdate: async (updateContextRequest, options = {}) => {
            // verify required parameter 'updateContextRequest' is not null or undefined
            (0, common_1.assertParamExists)('contextUpdate', 'updateContextRequest', updateContextRequest);
            const localVarPath = `/v1-context`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateContextRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all or specific set of contexts. Don\'t use, create your context entities within your Scout9 application.
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        contexts: async (q, id, options = {}) => {
            const localVarPath = `/v1-contexts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates new contexts. Don\'t use, create your context entities within your Scout9 application.
         * @param {CreateContextsRequest} createContextsRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        contextsCreate: async (createContextsRequest, options = {}) => {
            // verify required parameter 'createContextsRequest' is not null or undefined
            (0, common_1.assertParamExists)('contextsCreate', 'createContextsRequest', createContextsRequest);
            const localVarPath = `/v1-contexts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createContextsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes multiple contexts. Don\'t use, create your context entities within your Scout9 application.
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        contextsDelete: async (id, options = {}) => {
            const localVarPath = `/v1-contexts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates multiple contexts. Don\'t use, create your context entities within your Scout9 application.
         * @param {UpdateContextRequest} updateContextRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        contextsUpdate: async (updateContextRequest, options = {}) => {
            // verify required parameter 'updateContextRequest' is not null or undefined
            (0, common_1.assertParamExists)('contextsUpdate', 'updateContextRequest', updateContextRequest);
            const localVarPath = `/v1-contexts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateContextRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a conversation
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversation: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('conversation', 'id', id);
            const localVarPath = `/v1-conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Create a new conversation
         * @param {ConversationCreateRequest} conversationCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationCreate: async (conversationCreateRequest, options = {}) => {
            // verify required parameter 'conversationCreateRequest' is not null or undefined
            (0, common_1.assertParamExists)('conversationCreate', 'conversationCreateRequest', conversationCreateRequest);
            const localVarPath = `/v1-conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(conversationCreateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationDelete: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('conversationDelete', 'id', id);
            const localVarPath = `/v1-conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Update a conversation
         * @param {ConversationUpdateRequest} conversationUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationUpdate: async (conversationUpdateRequest, options = {}) => {
            // verify required parameter 'conversationUpdateRequest' is not null or undefined
            (0, common_1.assertParamExists)('conversationUpdate', 'conversationUpdateRequest', conversationUpdateRequest);
            const localVarPath = `/v1-conversation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(conversationUpdateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all or specific set of conversations
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversations: async (q, id, options = {}) => {
            const localVarPath = `/v1-conversations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a customer
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customer: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('customer', 'id', id);
            const localVarPath = `/v1-customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new customer
         * @param {Customer} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCreate: async (body, options = {}) => {
            // verify required parameter 'body' is not null or undefined
            (0, common_1.assertParamExists)('customerCreate', 'body', body);
            const localVarPath = `/v1-customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(body, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a customer
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDelete: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('customerDelete', 'id', id);
            const localVarPath = `/v1-customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets a customer group
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroup: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('customerGroup', 'id', id);
            const localVarPath = `/v1-customerGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates a new customer group
         * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupCreate: async (createCustomerGroupRequest, options = {}) => {
            // verify required parameter 'createCustomerGroupRequest' is not null or undefined
            (0, common_1.assertParamExists)('customerGroupCreate', 'createCustomerGroupRequest', createCustomerGroupRequest);
            const localVarPath = `/v1-customerGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createCustomerGroupRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes a customer group
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupDelete: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('customerGroupDelete', 'id', id);
            const localVarPath = `/v1-customerGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates a customer group
         * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupUpdate: async (updateCustomerGroupRequest, options = {}) => {
            // verify required parameter 'updateCustomerGroupRequest' is not null or undefined
            (0, common_1.assertParamExists)('customerGroupUpdate', 'updateCustomerGroupRequest', updateCustomerGroupRequest);
            const localVarPath = `/v1-customerGroup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateCustomerGroupRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all or specific set of customer groups
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroups: async (q, id, options = {}) => {
            const localVarPath = `/v1-customerGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates new customer groups
         * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupsCreate: async (createCustomerGroupsRequest, options = {}) => {
            // verify required parameter 'createCustomerGroupsRequest' is not null or undefined
            (0, common_1.assertParamExists)('customerGroupsCreate', 'createCustomerGroupsRequest', createCustomerGroupsRequest);
            const localVarPath = `/v1-customerGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createCustomerGroupsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes multiple customer groups
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupsDelete: async (id, options = {}) => {
            const localVarPath = `/v1-customerGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates multiple customer groups
         * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupsUpdate: async (updateCustomerGroupsRequest, options = {}) => {
            // verify required parameter 'updateCustomerGroupsRequest' is not null or undefined
            (0, common_1.assertParamExists)('customerGroupsUpdate', 'updateCustomerGroupsRequest', updateCustomerGroupsRequest);
            const localVarPath = `/v1-customerGroups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateCustomerGroupsRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates a customer
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerUpdate: async (updateCustomerRequest, options = {}) => {
            // verify required parameter 'updateCustomerRequest' is not null or undefined
            (0, common_1.assertParamExists)('customerUpdate', 'updateCustomerRequest', updateCustomerRequest);
            const localVarPath = `/v1-customer`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateCustomerRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all or specific set of customers
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customers: async (q, id, options = {}) => {
            const localVarPath = `/v1-customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Creates new customers
         * @param {CreateCustomersRequest} createCustomersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCreate: async (createCustomersRequest, options = {}) => {
            // verify required parameter 'createCustomersRequest' is not null or undefined
            (0, common_1.assertParamExists)('customersCreate', 'createCustomersRequest', createCustomersRequest);
            const localVarPath = `/v1-customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(createCustomersRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Deletes multiple customers
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersDelete: async (id, options = {}) => {
            const localVarPath = `/v1-customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Updates multiple customers
         * @param {UpdateCustomersRequest} updateCustomersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersUpdate: async (updateCustomersRequest, options = {}) => {
            // verify required parameter 'updateCustomersRequest' is not null or undefined
            (0, common_1.assertParamExists)('customersUpdate', 'updateCustomersRequest', updateCustomersRequest);
            const localVarPath = `/v1-customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(updateCustomersRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes an entity with the specified type and ID.
         * @summary Delete an entity
         * @param {string} type
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntity: async (type, id, options = {}) => {
            // verify required parameter 'type' is not null or undefined
            (0, common_1.assertParamExists)('deleteEntity', 'type', type);
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('deleteEntity', 'id', id);
            const localVarPath = `/v1-entity/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Natural language prompt to resolve to a boolean value.
         * @param {MacroDidInput} macroDidInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        did: async (macroDidInput, options = {}) => {
            // verify required parameter 'macroDidInput' is not null or undefined
            (0, common_1.assertParamExists)('did', 'macroDidInput', macroDidInput);
            const localVarPath = `/v1-utils-macros-did`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(macroDidInput, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get an entity by type and ID
         * @param {string} type The type of the entity to fetch
         * @param {string} id The unique identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entity: async (type, id, options = {}) => {
            // verify required parameter 'type' is not null or undefined
            (0, common_1.assertParamExists)('entity', 'type', type);
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('entity', 'id', id);
            const localVarPath = `/v1-entity/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns a file
         * @param {string} purpose File categorical purpose
         * @param {string} [entity] File entity id
         * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        file: async (purpose, entity, agent, options = {}) => {
            // verify required parameter 'purpose' is not null or undefined
            (0, common_1.assertParamExists)('file', 'purpose', purpose);
            const localVarPath = `/v1-utils-file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (purpose !== undefined) {
                localVarQueryParameter['purpose'] = purpose;
            }
            if (entity !== undefined) {
                localVarQueryParameter['entity'] = entity;
            }
            if (agent !== undefined) {
                localVarQueryParameter['agent'] = agent;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Remove a file
         * @param {string} purpose File categorical purpose
         * @param {string} entity File entity id
         * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileRemove: async (purpose, entity, agent, options = {}) => {
            // verify required parameter 'purpose' is not null or undefined
            (0, common_1.assertParamExists)('fileRemove', 'purpose', purpose);
            // verify required parameter 'entity' is not null or undefined
            (0, common_1.assertParamExists)('fileRemove', 'entity', entity);
            const localVarPath = `/v1-utils-file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (purpose !== undefined) {
                localVarQueryParameter['purpose'] = purpose;
            }
            if (entity !== undefined) {
                localVarQueryParameter['entity'] = entity;
            }
            if (agent !== undefined) {
                localVarQueryParameter['agent'] = agent;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
         * @param {File} file
         * @param {PurposeEnum} [purpose]
         * @param {string} [context] Additional information about this file
         * @param {string} [entity] The entity id, if not provided the entity id becomes the provided file name
         * @param {string} [$agent] The agent that this file belongs to. Only used for entity.audio and entity.transcript files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileUpload: async (file, purpose, context, entity, $agent, options = {}) => {
            // verify required parameter 'file' is not null or undefined
            (0, common_1.assertParamExists)('fileUpload', 'file', file);
            const localVarPath = `/v1-utils-file`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();
            if (file !== undefined) {
                localVarFormParams.append('file', file);
            }
            if (purpose !== undefined) {
                localVarFormParams.append('purpose', new Blob([JSON.stringify(purpose)], { type: "application/json", }));
            }
            if (context !== undefined) {
                localVarFormParams.append('context', context);
            }
            if (entity !== undefined) {
                localVarFormParams.append('entity', entity);
            }
            if ($agent !== undefined) {
                localVarFormParams.append('$agent', $agent);
            }
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = localVarFormParams;
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns a list of files that belong to the user\'s organization.
         * @param {string} purpose File categorical purpose
         * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        files: async (purpose, agent, options = {}) => {
            // verify required parameter 'purpose' is not null or undefined
            (0, common_1.assertParamExists)('files', 'purpose', purpose);
            const localVarPath = `/v1-utils-files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (purpose !== undefined) {
                localVarQueryParameter['purpose'] = purpose;
            }
            if (agent !== undefined) {
                localVarQueryParameter['agent'] = agent;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Forwards a locked conversation to agent
         * @summary forwards a locked conversation to agent
         * @param {ForwardRequest} forwardRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forward: async (forwardRequest, options = {}) => {
            // verify required parameter 'forwardRequest' is not null or undefined
            (0, common_1.assertParamExists)('forward', 'forwardRequest', forwardRequest);
            const localVarPath = `/v1-forward`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(forwardRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
         * @summary Generate a message from conversation
         * @param {GenerateRequest} generateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate: async (generateRequest, options = {}) => {
            // verify required parameter 'generateRequest' is not null or undefined
            (0, common_1.assertParamExists)('generate', 'generateRequest', generateRequest);
            const localVarPath = `/v1-generate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(generateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns log data for a given range, specified by start and end Unix timestamps.
         * @summary Retrieve platform run time logs
         * @param {number} [start]
         * @param {number} [end]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logs: async (start, end, options = {}) => {
            const localVarPath = `/v1-utils-platform-logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }
            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
         * @summary Create and send message
         * @param {MessageCreateRequest} messageCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        message: async (messageCreateRequest, options = {}) => {
            // verify required parameter 'messageCreateRequest' is not null or undefined
            (0, common_1.assertParamExists)('message', 'messageCreateRequest', messageCreateRequest);
            const localVarPath = `/v1-messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(messageCreateRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get all messages from a conversation
         * @param {string} id id of entity to query
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messages: async (id, q, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('messages', 'id', id);
            const localVarPath = `/v1-messages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Get the results of a bulk API operation
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operation: async (id, options = {}) => {
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('operation', 'id', id);
            const localVarPath = `/v1-utils-operation`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Gets all or specific set of bulk API operations
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operations: async (q, id, options = {}) => {
            const localVarPath = `/v1-utils-operations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            if (q !== undefined) {
                localVarQueryParameter['q'] = q;
            }
            if (id) {
                localVarQueryParameter['id'] = id;
            }
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Parses a message\'s custom context relevant to your organization. This is useful for extracting information from a message to drive your auto reply workflows.
         * @summary Parse a message\'s custom context relevant to your organization
         * @param {ParseRequest} parseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parse: async (parseRequest, options = {}) => {
            // verify required parameter 'parseRequest' is not null or undefined
            (0, common_1.assertParamExists)('parse', 'parseRequest', parseRequest);
            const localVarPath = `/v1-parse`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(parseRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary This is used for the generator to include PurposeEnum, because for whatever reason, query params are not included in the generator.
         * @param {PingRequest} pingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping: async (pingRequest, options = {}) => {
            // verify required parameter 'pingRequest' is not null or undefined
            (0, common_1.assertParamExists)('ping', 'pingRequest', pingRequest);
            const localVarPath = `/v1-utils-ping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(pingRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Purchase phone for a given agent.
         * @param {PurchasePhoneRequest} [purchasePhoneRequest] If no agent id is provided, the phone will be purchased for the owner of the API key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhone: async (purchasePhoneRequest, options = {}) => {
            const localVarPath = `/v1-purchases-phone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(purchasePhoneRequest, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Replaces an existing entity with the specified type and ID with a new entity.
         * @summary Replace an existing entity
         * @param {string} type
         * @param {string} id
         * @param {EntityData} entityData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceEntity: async (type, id, entityData, options = {}) => {
            // verify required parameter 'type' is not null or undefined
            (0, common_1.assertParamExists)('replaceEntity', 'type', type);
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('replaceEntity', 'id', id);
            // verify required parameter 'entityData' is not null or undefined
            (0, common_1.assertParamExists)('replaceEntity', 'entityData', entityData);
            const localVarPath = `/v1-entity/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(entityData, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Runs your auto-reply app on the Scout9 platform.
         * @param {WorkflowEvent} workflowEvent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runPlatform: async (workflowEvent, options = {}) => {
            // verify required parameter 'workflowEvent' is not null or undefined
            (0, common_1.assertParamExists)('runPlatform', 'workflowEvent', workflowEvent);
            const localVarPath = `/v1-utils-platform-run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(workflowEvent, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *
         * @summary Returns the platform run config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runPlatformConfig: async (options = {}) => {
            const localVarPath = `/v1-utils-platform-run`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates an existing entity with the specified type and ID.
         * @summary Update an existing entity
         * @param {string} type
         * @param {string} id
         * @param {EntityData} entityData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntity: async (type, id, entityData, options = {}) => {
            // verify required parameter 'type' is not null or undefined
            (0, common_1.assertParamExists)('updateEntity', 'type', type);
            // verify required parameter 'id' is not null or undefined
            (0, common_1.assertParamExists)('updateEntity', 'id', id);
            // verify required parameter 'entityData' is not null or undefined
            (0, common_1.assertParamExists)('updateEntity', 'entityData', entityData);
            const localVarPath = `/v1-entity/{type}/{id}`
                .replace(`{${"type"}}`, encodeURIComponent(String(type)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, common_1.DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options };
            const localVarHeaderParameter = {};
            const localVarQueryParameter = {};
            localVarHeaderParameter['Content-Type'] = 'application/json';
            (0, common_1.setSearchParams)(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = (0, common_1.serializeDataIfNeeded)(entityData, localVarRequestOptions, configuration);
            return {
                url: (0, common_1.toPathString)(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};
exports.Scout9ApiAxiosParamCreator = Scout9ApiAxiosParamCreator;
/**
 * Scout9Api - functional programming interface
 * @export
 */
const Scout9ApiFp = function (configuration) {
    const localVarAxiosParamCreator = (0, exports.Scout9ApiAxiosParamCreator)(configuration);
    return {
        /**
         *
         * @summary Create a new entity
         * @param {string} type
         * @param {string} id The unique identifier of the entity
         * @param {EntityData} entityData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addEntity(type, id, entityData, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addEntity(type, id, entityData, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a agent
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agent(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agent(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a agent
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Registers a new agent
         * @param {CreateAgentRequest} createAgentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentRegister(createAgentRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentRegister(createAgentRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update a agent
         * @param {UpdateAgentRequest} updateAgentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentUpdate(updateAgentRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentUpdate(updateAgentRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets all or specific set of agents
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agents(q, id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agents(q, id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates new agents
         * @param {CreateAgentsRequest} createAgentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsCreate(createAgentsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsCreate(createAgentsRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes multiple agents
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates multiple agents
         * @param {UpdateAgentsRequest} updateAgentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsUpdate(updateAgentsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsUpdate(updateAgentsRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Natural language prompt to resolve a context value derived from the conversation.
         * @param {MacroContextInput} macroContextInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async captureContext(macroContextInput, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.captureContext(macroContextInput, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get the current project configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async config(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.config(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a context. Don\'t use, create your context entities within your Scout9 application.
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async context(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.context(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create a new context. Don\'t use, create your context entities within your Scout9 application.
         * @param {CreateContextRequest} createContextRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async contextCreate(createContextRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextCreate(createContextRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets context data
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextData(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextData(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create a new context data
         * @param {CreateContextDataRequest} createContextDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextDataCreate(createContextDataRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextDataCreate(createContextDataRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextDataDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextDataDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update a context data
         * @param {UpdateContextDataRequest} updateContextDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextDataUpdate(updateContextDataRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextDataUpdate(updateContextDataRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a context entity. Don\'t use, create your context entities within your Scout9 application.
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async contextDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Test a custom context before training
         * @param {ContextTestRequest} contextTestRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async contextTest(contextTestRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextTest(contextTestRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Update a context. . Don\'t use, create your context entities within your Scout9 application.
         * @summary Update a context
         * @param {UpdateContextRequest} updateContextRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async contextUpdate(updateContextRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextUpdate(updateContextRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets all or specific set of contexts. Don\'t use, create your context entities within your Scout9 application.
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async contexts(q, id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contexts(q, id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates new contexts. Don\'t use, create your context entities within your Scout9 application.
         * @param {CreateContextsRequest} createContextsRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async contextsCreate(createContextsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextsCreate(createContextsRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes multiple contexts. Don\'t use, create your context entities within your Scout9 application.
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async contextsDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextsDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates multiple contexts. Don\'t use, create your context entities within your Scout9 application.
         * @param {UpdateContextRequest} updateContextRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async contextsUpdate(updateContextRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.contextsUpdate(updateContextRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a conversation
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversation(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conversation(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Create a new conversation
         * @param {ConversationCreateRequest} conversationCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversationCreate(conversationCreateRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conversationCreate(conversationCreateRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversationDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conversationDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Update a conversation
         * @param {ConversationUpdateRequest} conversationUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversationUpdate(conversationUpdateRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conversationUpdate(conversationUpdateRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets all or specific set of conversations
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async conversations(q, id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.conversations(q, id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a customer
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customer(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customer(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a new customer
         * @param {Customer} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerCreate(body, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerCreate(body, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a customer
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets a customer group
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGroup(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroup(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates a new customer group
         * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGroupCreate(createCustomerGroupRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupCreate(createCustomerGroupRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes a customer group
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGroupDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates a customer group
         * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGroupUpdate(updateCustomerGroupRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupUpdate(updateCustomerGroupRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets all or specific set of customer groups
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGroups(q, id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroups(q, id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates new customer groups
         * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGroupsCreate(createCustomerGroupsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupsCreate(createCustomerGroupsRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes multiple customer groups
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGroupsDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupsDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates multiple customer groups
         * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerGroupsUpdate(updateCustomerGroupsRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerGroupsUpdate(updateCustomerGroupsRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates a customer
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customerUpdate(updateCustomerRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customerUpdate(updateCustomerRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets all or specific set of customers
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customers(q, id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customers(q, id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Creates new customers
         * @param {CreateCustomersRequest} createCustomersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersCreate(createCustomersRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersCreate(createCustomersRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Deletes multiple customers
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersDelete(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersDelete(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Updates multiple customers
         * @param {UpdateCustomersRequest} updateCustomersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async customersUpdate(updateCustomersRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.customersUpdate(updateCustomersRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Deletes an entity with the specified type and ID.
         * @summary Delete an entity
         * @param {string} type
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEntity(type, id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEntity(type, id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Natural language prompt to resolve to a boolean value.
         * @param {MacroDidInput} macroDidInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async did(macroDidInput, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.did(macroDidInput, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get an entity by type and ID
         * @param {string} type The type of the entity to fetch
         * @param {string} id The unique identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async entity(type, id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.entity(type, id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns a file
         * @param {string} purpose File categorical purpose
         * @param {string} [entity] File entity id
         * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async file(purpose, entity, agent, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.file(purpose, entity, agent, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Remove a file
         * @param {string} purpose File categorical purpose
         * @param {string} entity File entity id
         * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileRemove(purpose, entity, agent, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileRemove(purpose, entity, agent, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
         * @param {File} file
         * @param {PurposeEnum} [purpose]
         * @param {string} [context] Additional information about this file
         * @param {string} [entity] The entity id, if not provided the entity id becomes the provided file name
         * @param {string} [$agent] The agent that this file belongs to. Only used for entity.audio and entity.transcript files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async fileUpload(file, purpose, context, entity, $agent, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.fileUpload(file, purpose, context, entity, $agent, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns a list of files that belong to the user\'s organization.
         * @param {string} purpose File categorical purpose
         * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async files(purpose, agent, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.files(purpose, agent, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Forwards a locked conversation to agent
         * @summary forwards a locked conversation to agent
         * @param {ForwardRequest} forwardRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async forward(forwardRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.forward(forwardRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
         * @summary Generate a message from conversation
         * @param {GenerateRequest} generateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async generate(generateRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.generate(generateRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Returns log data for a given range, specified by start and end Unix timestamps.
         * @summary Retrieve platform run time logs
         * @param {number} [start]
         * @param {number} [end]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logs(start, end, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logs(start, end, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
         * @summary Create and send message
         * @param {MessageCreateRequest} messageCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async message(messageCreateRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.message(messageCreateRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get all messages from a conversation
         * @param {string} id id of entity to query
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async messages(id, q, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.messages(id, q, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Get the results of a bulk API operation
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operation(id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operation(id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Gets all or specific set of bulk API operations
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async operations(q, id, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.operations(q, id, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Parses a message\'s custom context relevant to your organization. This is useful for extracting information from a message to drive your auto reply workflows.
         * @summary Parse a message\'s custom context relevant to your organization
         * @param {ParseRequest} parseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async parse(parseRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.parse(parseRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary This is used for the generator to include PurposeEnum, because for whatever reason, query params are not included in the generator.
         * @param {PingRequest} pingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ping(pingRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ping(pingRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Purchase phone for a given agent.
         * @param {PurchasePhoneRequest} [purchasePhoneRequest] If no agent id is provided, the phone will be purchased for the owner of the API key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async purchasePhone(purchasePhoneRequest, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.purchasePhone(purchasePhoneRequest, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Replaces an existing entity with the specified type and ID with a new entity.
         * @summary Replace an existing entity
         * @param {string} type
         * @param {string} id
         * @param {EntityData} entityData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async replaceEntity(type, id, entityData, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.replaceEntity(type, id, entityData, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Runs your auto-reply app on the Scout9 platform.
         * @param {WorkflowEvent} workflowEvent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runPlatform(workflowEvent, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runPlatform(workflowEvent, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         *
         * @summary Returns the platform run config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async runPlatformConfig(options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.runPlatformConfig(options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
        /**
         * Updates an existing entity with the specified type and ID.
         * @summary Update an existing entity
         * @param {string} type
         * @param {string} id
         * @param {EntityData} entityData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEntity(type, id, entityData, options) {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEntity(type, id, entityData, options);
            return (0, common_1.createRequestFunction)(localVarAxiosArgs, axios_1.default, base_1.BASE_PATH, configuration);
        },
    };
};
exports.Scout9ApiFp = Scout9ApiFp;
/**
 * Scout9Api - factory interface
 * @export
 */
const Scout9ApiFactory = function (configuration, basePath, axios) {
    const localVarFp = (0, exports.Scout9ApiFp)(configuration);
    return {
        /**
         *
         * @summary Create a new entity
         * @param {string} type
         * @param {string} id The unique identifier of the entity
         * @param {EntityData} entityData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntity(type, id, entityData, options) {
            return localVarFp.addEntity(type, id, entityData, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a agent
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agent(id, options) {
            return localVarFp.agent(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a agent
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentDelete(id, options) {
            return localVarFp.agentDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Registers a new agent
         * @param {CreateAgentRequest} createAgentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentRegister(createAgentRequest, options) {
            return localVarFp.agentRegister(createAgentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a agent
         * @param {UpdateAgentRequest} updateAgentRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentUpdate(updateAgentRequest, options) {
            return localVarFp.agentUpdate(updateAgentRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all or specific set of agents
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agents(q, id, options) {
            return localVarFp.agents(q, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates new agents
         * @param {CreateAgentsRequest} createAgentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsCreate(createAgentsRequest, options) {
            return localVarFp.agentsCreate(createAgentsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes multiple agents
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsDelete(id, options) {
            return localVarFp.agentsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates multiple agents
         * @param {UpdateAgentsRequest} updateAgentsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsUpdate(updateAgentsRequest, options) {
            return localVarFp.agentsUpdate(updateAgentsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Natural language prompt to resolve a context value derived from the conversation.
         * @param {MacroContextInput} macroContextInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        captureContext(macroContextInput, options) {
            return localVarFp.captureContext(macroContextInput, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the current project configuration
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        config(options) {
            return localVarFp.config(options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a context. Don\'t use, create your context entities within your Scout9 application.
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        context(id, options) {
            return localVarFp.context(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new context. Don\'t use, create your context entities within your Scout9 application.
         * @param {CreateContextRequest} createContextRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        contextCreate(createContextRequest, options) {
            return localVarFp.contextCreate(createContextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets context data
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextData(id, options) {
            return localVarFp.contextData(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new context data
         * @param {CreateContextDataRequest} createContextDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDataCreate(createContextDataRequest, options) {
            return localVarFp.contextDataCreate(createContextDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDataDelete(id, options) {
            return localVarFp.contextDataDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a context data
         * @param {UpdateContextDataRequest} updateContextDataRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextDataUpdate(updateContextDataRequest, options) {
            return localVarFp.contextDataUpdate(updateContextDataRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a context entity. Don\'t use, create your context entities within your Scout9 application.
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        contextDelete(id, options) {
            return localVarFp.contextDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Test a custom context before training
         * @param {ContextTestRequest} contextTestRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contextTest(contextTestRequest, options) {
            return localVarFp.contextTest(contextTestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a context. . Don\'t use, create your context entities within your Scout9 application.
         * @summary Update a context
         * @param {UpdateContextRequest} updateContextRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        contextUpdate(updateContextRequest, options) {
            return localVarFp.contextUpdate(updateContextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all or specific set of contexts. Don\'t use, create your context entities within your Scout9 application.
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        contexts(q, id, options) {
            return localVarFp.contexts(q, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates new contexts. Don\'t use, create your context entities within your Scout9 application.
         * @param {CreateContextsRequest} createContextsRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        contextsCreate(createContextsRequest, options) {
            return localVarFp.contextsCreate(createContextsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes multiple contexts. Don\'t use, create your context entities within your Scout9 application.
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        contextsDelete(id, options) {
            return localVarFp.contextsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates multiple contexts. Don\'t use, create your context entities within your Scout9 application.
         * @param {UpdateContextRequest} updateContextRequest
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        contextsUpdate(updateContextRequest, options) {
            return localVarFp.contextsUpdate(updateContextRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a conversation
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversation(id, options) {
            return localVarFp.conversation(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Create a new conversation
         * @param {ConversationCreateRequest} conversationCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationCreate(conversationCreateRequest, options) {
            return localVarFp.conversationCreate(conversationCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a schedule
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationDelete(id, options) {
            return localVarFp.conversationDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Update a conversation
         * @param {ConversationUpdateRequest} conversationUpdateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversationUpdate(conversationUpdateRequest, options) {
            return localVarFp.conversationUpdate(conversationUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all or specific set of conversations
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        conversations(q, id, options) {
            return localVarFp.conversations(q, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a customer
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customer(id, options) {
            return localVarFp.customer(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a new customer
         * @param {Customer} body
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerCreate(body, options) {
            return localVarFp.customerCreate(body, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a customer
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerDelete(id, options) {
            return localVarFp.customerDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets a customer group
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroup(id, options) {
            return localVarFp.customerGroup(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates a new customer group
         * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupCreate(createCustomerGroupRequest, options) {
            return localVarFp.customerGroupCreate(createCustomerGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes a customer group
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupDelete(id, options) {
            return localVarFp.customerGroupDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a customer group
         * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupUpdate(updateCustomerGroupRequest, options) {
            return localVarFp.customerGroupUpdate(updateCustomerGroupRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all or specific set of customer groups
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroups(q, id, options) {
            return localVarFp.customerGroups(q, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates new customer groups
         * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupsCreate(createCustomerGroupsRequest, options) {
            return localVarFp.customerGroupsCreate(createCustomerGroupsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes multiple customer groups
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupsDelete(id, options) {
            return localVarFp.customerGroupsDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates multiple customer groups
         * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerGroupsUpdate(updateCustomerGroupsRequest, options) {
            return localVarFp.customerGroupsUpdate(updateCustomerGroupsRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates a customer
         * @param {UpdateCustomerRequest} updateCustomerRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customerUpdate(updateCustomerRequest, options) {
            return localVarFp.customerUpdate(updateCustomerRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all or specific set of customers
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customers(q, id, options) {
            return localVarFp.customers(q, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Creates new customers
         * @param {CreateCustomersRequest} createCustomersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersCreate(createCustomersRequest, options) {
            return localVarFp.customersCreate(createCustomersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Deletes multiple customers
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersDelete(id, options) {
            return localVarFp.customersDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Updates multiple customers
         * @param {UpdateCustomersRequest} updateCustomersRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        customersUpdate(updateCustomersRequest, options) {
            return localVarFp.customersUpdate(updateCustomersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deletes an entity with the specified type and ID.
         * @summary Delete an entity
         * @param {string} type
         * @param {string} id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntity(type, id, options) {
            return localVarFp.deleteEntity(type, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Natural language prompt to resolve to a boolean value.
         * @param {MacroDidInput} macroDidInput
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        did(macroDidInput, options) {
            return localVarFp.did(macroDidInput, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get an entity by type and ID
         * @param {string} type The type of the entity to fetch
         * @param {string} id The unique identifier of the entity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entity(type, id, options) {
            return localVarFp.entity(type, id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a file
         * @param {string} purpose File categorical purpose
         * @param {string} [entity] File entity id
         * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        file(purpose, entity, agent, options) {
            return localVarFp.file(purpose, entity, agent, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Remove a file
         * @param {string} purpose File categorical purpose
         * @param {string} entity File entity id
         * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileRemove(purpose, entity, agent, options) {
            return localVarFp.fileRemove(purpose, entity, agent, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
         * @param {File} file
         * @param {PurposeEnum} [purpose]
         * @param {string} [context] Additional information about this file
         * @param {string} [entity] The entity id, if not provided the entity id becomes the provided file name
         * @param {string} [$agent] The agent that this file belongs to. Only used for entity.audio and entity.transcript files.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        fileUpload(file, purpose, context, entity, $agent, options) {
            return localVarFp.fileUpload(file, purpose, context, entity, $agent, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns a list of files that belong to the user\'s organization.
         * @param {string} purpose File categorical purpose
         * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        files(purpose, agent, options) {
            return localVarFp.files(purpose, agent, options).then((request) => request(axios, basePath));
        },
        /**
         * Forwards a locked conversation to agent
         * @summary forwards a locked conversation to agent
         * @param {ForwardRequest} forwardRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        forward(forwardRequest, options) {
            return localVarFp.forward(forwardRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
         * @summary Generate a message from conversation
         * @param {GenerateRequest} generateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        generate(generateRequest, options) {
            return localVarFp.generate(generateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns log data for a given range, specified by start and end Unix timestamps.
         * @summary Retrieve platform run time logs
         * @param {number} [start]
         * @param {number} [end]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logs(start, end, options) {
            return localVarFp.logs(start, end, options).then((request) => request(axios, basePath));
        },
        /**
         * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
         * @summary Create and send message
         * @param {MessageCreateRequest} messageCreateRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        message(messageCreateRequest, options) {
            return localVarFp.message(messageCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get all messages from a conversation
         * @param {string} id id of entity to query
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        messages(id, q, options) {
            return localVarFp.messages(id, q, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Get the results of a bulk API operation
         * @param {string} id id of entity to query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operation(id, options) {
            return localVarFp.operation(id, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Gets all or specific set of bulk API operations
         * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
         * @param {Array<string>} [id] ids for the entities this id belongs to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        operations(q, id, options) {
            return localVarFp.operations(q, id, options).then((request) => request(axios, basePath));
        },
        /**
         * Parses a message\'s custom context relevant to your organization. This is useful for extracting information from a message to drive your auto reply workflows.
         * @summary Parse a message\'s custom context relevant to your organization
         * @param {ParseRequest} parseRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        parse(parseRequest, options) {
            return localVarFp.parse(parseRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary This is used for the generator to include PurposeEnum, because for whatever reason, query params are not included in the generator.
         * @param {PingRequest} pingRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ping(pingRequest, options) {
            return localVarFp.ping(pingRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Purchase phone for a given agent.
         * @param {PurchasePhoneRequest} [purchasePhoneRequest] If no agent id is provided, the phone will be purchased for the owner of the API key.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        purchasePhone(purchasePhoneRequest, options) {
            return localVarFp.purchasePhone(purchasePhoneRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Replaces an existing entity with the specified type and ID with a new entity.
         * @summary Replace an existing entity
         * @param {string} type
         * @param {string} id
         * @param {EntityData} entityData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        replaceEntity(type, id, entityData, options) {
            return localVarFp.replaceEntity(type, id, entityData, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Runs your auto-reply app on the Scout9 platform.
         * @param {WorkflowEvent} workflowEvent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runPlatform(workflowEvent, options) {
            return localVarFp.runPlatform(workflowEvent, options).then((request) => request(axios, basePath));
        },
        /**
         *
         * @summary Returns the platform run config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        runPlatformConfig(options) {
            return localVarFp.runPlatformConfig(options).then((request) => request(axios, basePath));
        },
        /**
         * Updates an existing entity with the specified type and ID.
         * @summary Update an existing entity
         * @param {string} type
         * @param {string} id
         * @param {EntityData} entityData
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntity(type, id, entityData, options) {
            return localVarFp.updateEntity(type, id, entityData, options).then((request) => request(axios, basePath));
        },
    };
};
exports.Scout9ApiFactory = Scout9ApiFactory;
/**
 * Scout9ApiGenerated - object-oriented interface
 * @export
 * @class Scout9ApiGenerated
 * @extends {BaseAPI}
 */
class Scout9ApiGenerated extends base_1.BaseAPI {
    /**
     *
     * @summary Create a new entity
     * @param {string} type
     * @param {string} id The unique identifier of the entity
     * @param {EntityData} entityData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    addEntity(type, id, entityData, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).addEntity(type, id, entityData, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    agent(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).agent(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a agent
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    agentDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).agentDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Registers a new agent
     * @param {CreateAgentRequest} createAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    agentRegister(createAgentRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).agentRegister(createAgentRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a agent
     * @param {UpdateAgentRequest} updateAgentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    agentUpdate(updateAgentRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).agentUpdate(updateAgentRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets all or specific set of agents
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    agents(q, id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).agents(q, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates new agents
     * @param {CreateAgentsRequest} createAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    agentsCreate(createAgentsRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).agentsCreate(createAgentsRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes multiple agents
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    agentsDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).agentsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates multiple agents
     * @param {UpdateAgentsRequest} updateAgentsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    agentsUpdate(updateAgentsRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).agentsUpdate(updateAgentsRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Natural language prompt to resolve a context value derived from the conversation.
     * @param {MacroContextInput} macroContextInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    captureContext(macroContextInput, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).captureContext(macroContextInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the current project configuration
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    config(options) {
        return (0, exports.Scout9ApiFp)(this.configuration).config(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets a context. Don\'t use, create your context entities within your Scout9 application.
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    context(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).context(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a new context. Don\'t use, create your context entities within your Scout9 application.
     * @param {CreateContextRequest} createContextRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextCreate(createContextRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextCreate(createContextRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets context data
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextData(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextData(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a new context data
     * @param {CreateContextDataRequest} createContextDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextDataCreate(createContextDataRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextDataCreate(createContextDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextDataDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextDataDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a context data
     * @param {UpdateContextDataRequest} updateContextDataRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextDataUpdate(updateContextDataRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextDataUpdate(updateContextDataRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a context entity. Don\'t use, create your context entities within your Scout9 application.
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Test a custom context before training
     * @param {ContextTestRequest} contextTestRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextTest(contextTestRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextTest(contextTestRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Update a context. . Don\'t use, create your context entities within your Scout9 application.
     * @summary Update a context
     * @param {UpdateContextRequest} updateContextRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextUpdate(updateContextRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextUpdate(updateContextRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets all or specific set of contexts. Don\'t use, create your context entities within your Scout9 application.
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contexts(q, id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contexts(q, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates new contexts. Don\'t use, create your context entities within your Scout9 application.
     * @param {CreateContextsRequest} createContextsRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextsCreate(createContextsRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextsCreate(createContextsRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes multiple contexts. Don\'t use, create your context entities within your Scout9 application.
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextsDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates multiple contexts. Don\'t use, create your context entities within your Scout9 application.
     * @param {UpdateContextRequest} updateContextRequest
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    contextsUpdate(updateContextRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).contextsUpdate(updateContextRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets a conversation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    conversation(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).conversation(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Create a new conversation
     * @param {ConversationCreateRequest} conversationCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    conversationCreate(conversationCreateRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).conversationCreate(conversationCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a schedule
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    conversationDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).conversationDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Update a conversation
     * @param {ConversationUpdateRequest} conversationUpdateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    conversationUpdate(conversationUpdateRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).conversationUpdate(conversationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets all or specific set of conversations
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    conversations(q, id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).conversations(q, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets a customer
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customer(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customer(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates a new customer
     * @param {Customer} body
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerCreate(body, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerCreate(body, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a customer
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerGroup(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerGroup(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates a new customer group
     * @param {CreateCustomerGroupRequest} createCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerGroupCreate(createCustomerGroupRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerGroupCreate(createCustomerGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes a customer group
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerGroupDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerGroupDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a customer group
     * @param {UpdateCustomerGroupRequest} updateCustomerGroupRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerGroupUpdate(updateCustomerGroupRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerGroupUpdate(updateCustomerGroupRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets all or specific set of customer groups
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerGroups(q, id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerGroups(q, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates new customer groups
     * @param {CreateCustomerGroupsRequest} createCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerGroupsCreate(createCustomerGroupsRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerGroupsCreate(createCustomerGroupsRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes multiple customer groups
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerGroupsDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerGroupsDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates multiple customer groups
     * @param {UpdateCustomerGroupsRequest} updateCustomerGroupsRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerGroupsUpdate(updateCustomerGroupsRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerGroupsUpdate(updateCustomerGroupsRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates a customer
     * @param {UpdateCustomerRequest} updateCustomerRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customerUpdate(updateCustomerRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customerUpdate(updateCustomerRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets all or specific set of customers
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customers(q, id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customers(q, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Creates new customers
     * @param {CreateCustomersRequest} createCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customersCreate(createCustomersRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customersCreate(createCustomersRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Deletes multiple customers
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customersDelete(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customersDelete(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Updates multiple customers
     * @param {UpdateCustomersRequest} updateCustomersRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    customersUpdate(updateCustomersRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).customersUpdate(updateCustomersRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Deletes an entity with the specified type and ID.
     * @summary Delete an entity
     * @param {string} type
     * @param {string} id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    deleteEntity(type, id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).deleteEntity(type, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Natural language prompt to resolve to a boolean value.
     * @param {MacroDidInput} macroDidInput
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    did(macroDidInput, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).did(macroDidInput, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get an entity by type and ID
     * @param {string} type The type of the entity to fetch
     * @param {string} id The unique identifier of the entity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    entity(type, id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).entity(type, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a file
     * @param {string} purpose File categorical purpose
     * @param {string} [entity] File entity id
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    file(purpose, entity, agent, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).file(purpose, entity, agent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Remove a file
     * @param {string} purpose File categorical purpose
     * @param {string} entity File entity id
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    fileRemove(purpose, entity, agent, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).fileRemove(purpose, entity, agent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Upload a file that contains document(s) to be used across various endpoints/features. Currently, the size of all the files uploaded by one organization can be up to 1 GB. Please contact us if you need to increase the storage limit.
     * @param {File} file
     * @param {PurposeEnum} [purpose]
     * @param {string} [context] Additional information about this file
     * @param {string} [entity] The entity id, if not provided the entity id becomes the provided file name
     * @param {string} [$agent] The agent that this file belongs to. Only used for entity.audio and entity.transcript files.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    fileUpload(file, purpose, context, entity, $agent, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).fileUpload(file, purpose, context, entity, $agent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns a list of files that belong to the user\'s organization.
     * @param {string} purpose File categorical purpose
     * @param {string} [agent] Agent id, only used if purpose is either agent-audio or agent-transcript
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    files(purpose, agent, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).files(purpose, agent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Forwards a locked conversation to agent
     * @summary forwards a locked conversation to agent
     * @param {ForwardRequest} forwardRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    forward(forwardRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).forward(forwardRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Generates a message in the agent\'s voice based on the state of the given conversation. This is useful for testing and debugging. The message will not be sent to the conversation, you must run .message() with the body of the generated message to send it to the conversation.
     * @summary Generate a message from conversation
     * @param {GenerateRequest} generateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    generate(generateRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).generate(generateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Returns log data for a given range, specified by start and end Unix timestamps.
     * @summary Retrieve platform run time logs
     * @param {number} [start]
     * @param {number} [end]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    logs(start, end, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).logs(start, end, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Creates a new message and sends it to the conversation. If the conversation is scheduled, the message will be scheduled as well. @TODO does not support the ability to mute or delay send
     * @summary Create and send message
     * @param {MessageCreateRequest} messageCreateRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    message(messageCreateRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).message(messageCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get all messages from a conversation
     * @param {string} id id of entity to query
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    messages(id, q, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).messages(id, q, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Get the results of a bulk API operation
     * @param {string} id id of entity to query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    operation(id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).operation(id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Gets all or specific set of bulk API operations
     * @param {string} [q] Query search string to filter results ({field},{operator},{value}) (example firstName,equals,Patrick)
     * @param {Array<string>} [id] ids for the entities this id belongs to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    operations(q, id, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).operations(q, id, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Parses a message\'s custom context relevant to your organization. This is useful for extracting information from a message to drive your auto reply workflows.
     * @summary Parse a message\'s custom context relevant to your organization
     * @param {ParseRequest} parseRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    parse(parseRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).parse(parseRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary This is used for the generator to include PurposeEnum, because for whatever reason, query params are not included in the generator.
     * @param {PingRequest} pingRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    ping(pingRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).ping(pingRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Purchase phone for a given agent.
     * @param {PurchasePhoneRequest} [purchasePhoneRequest] If no agent id is provided, the phone will be purchased for the owner of the API key.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    purchasePhone(purchasePhoneRequest, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).purchasePhone(purchasePhoneRequest, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Replaces an existing entity with the specified type and ID with a new entity.
     * @summary Replace an existing entity
     * @param {string} type
     * @param {string} id
     * @param {EntityData} entityData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    replaceEntity(type, id, entityData, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).replaceEntity(type, id, entityData, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Runs your auto-reply app on the Scout9 platform.
     * @param {WorkflowEvent} workflowEvent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    runPlatform(workflowEvent, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).runPlatform(workflowEvent, options).then((request) => request(this.axios, this.basePath));
    }
    /**
     *
     * @summary Returns the platform run config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    runPlatformConfig(options) {
        return (0, exports.Scout9ApiFp)(this.configuration).runPlatformConfig(options).then((request) => request(this.axios, this.basePath));
    }
    /**
     * Updates an existing entity with the specified type and ID.
     * @summary Update an existing entity
     * @param {string} type
     * @param {string} id
     * @param {EntityData} entityData
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Scout9Api
     */
    updateEntity(type, id, entityData, options) {
        return (0, exports.Scout9ApiFp)(this.configuration).updateEntity(type, id, entityData, options).then((request) => request(this.axios, this.basePath));
    }
}
exports.Scout9ApiGenerated = Scout9ApiGenerated;
const stream_1 = require("stream");
/**
 * Scout9Api - object-oriented interface
 * @export
 * @class Scout9Api
 * @extends {Scout9ApiGenerated}
 */
class Scout9Api extends Scout9ApiGenerated {
    organizationLogo(file) {
        (0, common_1.assertParamExists)('organizationLogo', 'file', file);
        const formData = new ((this.configuration && this.configuration.formDataCtor) || FormData)();
        if (Buffer.isBuffer(file)) {
            // Convert Buffer to Blob
            file = new Blob([file], { type: 'application/octet-stream' });
            // Convert Blob to Stream
            const fileStream = stream_1.Readable.from(file.stream());
            formData.append('file', fileStream, 'logo');
        }
        else {
            formData.append('file', file, file?.name || 'logo');
        }
        return this.axios.request({
            method: 'POST',
            url: `${this.configuration?.basePath || base_1.BASE_PATH}/v1-organizationLogo`,
            data: formData,
            headers: {
                'Content-Type': 'multipart/form-data',
                'Authorization': 'Bearer ' + this.configuration?.apiKey || '',
            }
        });
    }
    organizationIcon(file) {
        (0, common_1.assertParamExists)('organizationLogo', 'file', file);
        const formData = new ((this.configuration && this.configuration.formDataCtor) || FormData)();
        if (Buffer.isBuffer(file)) {
            // Convert Buffer to Blob
            file = new Blob([file], { type: 'application/octet-stream' });
            // Convert Blob to Stream
            const fileStream = stream_1.Readable.from(file.stream());
            formData.append('file', fileStream, 'icon');
        }
        else {
            formData.append('file', file, file?.name || 'icon');
        }
        return this.axios.request({
            method: 'POST',
            url: `${this.configuration?.basePath || base_1.BASE_PATH}/v1-organizationIcon`,
            data: formData,
            headers: {
                'Content-Type': 'multipart/form-data',
                'Authorization': 'Bearer ' + this.configuration?.apiKey || '',
            }
        });
    }
    agentProfileUpload(agentId = '', file) {
        // assertParamExists('agentProfileUpload', 'agentId', agentId);
        (0, common_1.assertParamExists)('agentProfileUpload', 'file', file);
        const formData = new ((this.configuration && this.configuration.formDataCtor) || FormData)();
        if (Buffer.isBuffer(file)) {
            // Convert Buffer to Blob
            file = new Blob([file], { type: "application/octet-stream" });
            // Convert Blob to Stream
            const fileStream = stream_1.Readable.from(file.stream());
            formData.append('file', fileStream, 'profile');
        }
        else {
            formData.append('file', file, file?.name || 'profile');
        }
        if (agentId) {
            formData.append('agentId', agentId);
        }
        return this.axios.request({
            method: 'POST',
            url: `${this.configuration?.basePath || base_1.BASE_PATH}/v1-agentImg`,
            data: formData,
            headers: {
                'Content-Type': 'multipart/form-data',
                'Authorization': 'Bearer ' + this.configuration?.apiKey || '',
            }
        });
    }
    agentTranscriptUpload(agentId = '', transcripts) {
        // assertParamExists('agentProfileUpload', 'agentId', agentId);
        (0, common_1.assertParamExists)('agentProfileUpload', 'transcripts', transcripts);
        const formData = new ((this.configuration && this.configuration.formDataCtor) || FormData)();
        if (agentId) {
            formData.append('agentId', agentId);
        }
        transcripts.forEach((file, i) => {
            if (Buffer.isBuffer(file)) {
                // Convert Buffer to Blob
                file = new Blob([file], { type: "text/plain" });
                // Convert Blob to Stream
                const fileStream = stream_1.Readable.from(file.stream());
                formData.append(`transcripts[${i}]`, fileStream, file?.name || 'transcript' + i);
            }
            else {
                formData.append(`transcripts[${i}]`, file, file?.name || 'transcript' + i);
            }
        });
        return this.axios.request({
            method: 'POST',
            url: `${this.configuration?.basePath || base_1.BASE_PATH}/v1-agentTranscripts`,
            data: formData,
            headers: {
                'Content-Type': 'multipart/form-data',
                'Authorization': 'Bearer ' + this.configuration?.apiKey || '',
            }
        });
    }
    agentAudioUpload(agentId = '', audios) {
        // assertParamExists('agentProfileUpload', 'agentId', agentId);
        (0, common_1.assertParamExists)('agentProfileUpload', 'audios', audios);
        const formData = new ((this.configuration && this.configuration.formDataCtor) || FormData)();
        if (agentId) {
            formData.append('agentId', agentId);
        }
        audios.forEach((file, i) => {
            if (Buffer.isBuffer(file)) {
                // Convert Buffer to Blob
                file = new Blob([file], { type: "application/octet-stream" });
                // Convert Blob to Stream
                const fileStream = stream_1.Readable.from(file.stream());
                formData.append(`audios[${i}]`, fileStream, file?.name || 'audio' + i);
            }
            else {
                formData.append(`audios[${i}]`, file, file?.name || 'audio' + i);
            }
        });
        return this.axios.request({
            method: 'POST',
            url: `${this.configuration?.basePath || base_1.BASE_PATH}/v1-agentAudios`,
            data: formData,
            headers: {
                'Content-Type': 'multipart/form-data',
                'Authorization': 'Bearer ' + this.configuration?.apiKey || '',
            }
        });
    }
}
exports.Scout9Api = Scout9Api;
